<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lwt&#39;s Blog</title>
  
  
  <link href="https://www.lwt-server.cn/atom.xml" rel="self"/>
  
  <link href="https://www.lwt-server.cn/"/>
  <updated>2023-08-29T14:22:28.939Z</updated>
  <id>https://www.lwt-server.cn/</id>
  
  <author>
    <name>Lwt</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode题解——16.最接近的三数之和</title>
    <link href="https://www.lwt-server.cn/2023/08/29/LeetCode_16/"/>
    <id>https://www.lwt-server.cn/2023/08/29/LeetCode_16/</id>
    <published>2023-08-29T14:10:55.000Z</published>
    <updated>2023-08-29T14:22:28.939Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="最接近的三数之和">最接近的三数之和</h2><h3 id="题目预览">题目预览：</h3><p>给你一个长度为 <span class="math inline">\(n\)</span> 的整数数组<span class="math inline">\(nums\)</span> 和 一个目标值 <spanclass="math inline">\(target\)</span>。请你从 <spanclass="math inline">\(nums\)</span> 中选出三个整数，使它们的和与 <spanclass="math inline">\(target\)</span> 最接近。</p><p>返回这三个数的和。</p><p>假定每组输入只存在恰好一个解。</p><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>nums = [-1,2,1,-4], target = 1<br /><b>输出：</b>2<br /><b>解释：</b>与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>nums = [0,0,0], target = 1<br /><b>输出：</b>0</p></blockquote><p>提示：</p><ul><li><p><span class="math inline">\(3 &lt;= nums.length &lt;=1000\)</span></p></li><li><p><span class="math inline">\(-1000 &lt;= nums[i] &lt;=1000\)</span></p></li><li><p><span class="math inline">\(-10^4 &lt;= target &lt;=10^4\)</span></p></li></ul><hr /><p>以下是题解：</p><h3 id="解题思路">解题思路:</h3><p><b>排序 + 双指针</b></p><p>基本思路与前一题(<ahref="/2023/08/29/LeetCode_15/">LeetCode_15</a>)类似</p><p>除此以外，还有以下几个优化：</p><p>设 <span class="math inline">\(s=nums[i]+nums[i+1]+nums[i+2]\)</span>。如果 <span class="math inline">\(s&gt;target\)</span>，由于数组已经排序，后面无论怎么选，选出的三个数的和不会比 <spanclass="math inline">\(s\)</span> 还小，所以不会找到比 <spanclass="math inline">\(s\)</span> 更优的答案了。所以只要 <spanclass="math inline">\(s&gt;target\)</span> ，就可以直接 <spanclass="math inline">\(break\)</span> 外层循环了。在 <spanclass="math inline">\(break\)</span> 前判断 <spanclass="math inline">\(s\)</span> 是否离 <spanclass="math inline">\(target\)</span> 更近，如果更近，那么更新答案为<span class="math inline">\(s\)</span>。</p><p>设 <span class="math inline">\(s=nums[i]+nums[n−2]+nums[n−1]\)</span>。如果 <span class="math inline">\(s&lt;targets\)</span>，由于数组已经排序，<span class="math inline">\(nums[i]\)</span>加上后面任意两个数都不超过 <spanclass="math inline">\(s\)</span>，所以下面的双指针就不需要跑了，无法找到比<span class="math inline">\(s\)</span> 更优的答案。但是后面还有更大的<span class="math inline">\(nums[i]\)</span> ，可能找到一个离 <spanclass="math inline">\(target\)</span>更近的三数之和，所以还需要继续枚举，<spanclass="math inline">\(continue\)</span> 外层循环。在 <spanclass="math inline">\(continue\)</span> 前判断 <spanclass="math inline">\(s\)</span> 是否离 <spanclass="math inline">\(target\)</span> 更近，如果更近，那么更新答案为<span class="math inline">\(s\)</span></p><p>如果 <span class="math inline">\(i&gt;0\)</span> 且 <spanclass="math inline">\(nums[i]=nums[i−1]\)</span> ，那么 <spanclass="math inline">\(nums[i]\)</span>和后面数字相加的结果，必然在之前算出过，所以无需跑下面的双指针，直接<span class="math inline">\(continue\)</span>外层循环。（可以放在循环开头判断。）</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">threeSumClosest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> Len=nums.<span class="built_in">size</span>(),ans=<span class="number">1e7</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Len<span class="number">-2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> Left=i+<span class="number">1</span>,Right=Len<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(Left&lt;Right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> sum=nums[i]+nums[Left]+nums[Right];</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(sum-target)&lt;<span class="built_in">abs</span>(ans-target))</span><br><span class="line">                    ans=sum;</span><br><span class="line">                <span class="keyword">if</span>(sum&gt;target)</span><br><span class="line">                    Right--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;target)</span><br><span class="line">                    Left++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> target;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPdteiR"><imgsrc="https://s1.ax1x.com/2023/08/29/pPdteiR.png"alt="pPdteiR.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/29 22:10:55</p>]]></content>
    
    
    <summary type="html">最接近的三数之和</summary>
    
    
    
    <category term="程序" scheme="https://www.lwt-server.cn/categories/%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="LeetCode题解" scheme="https://www.lwt-server.cn/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解——823.带因子的二叉树</title>
    <link href="https://www.lwt-server.cn/2023/08/29/LeetCode_823/"/>
    <id>https://www.lwt-server.cn/2023/08/29/LeetCode_823/</id>
    <published>2023-08-29T05:06:24.000Z</published>
    <updated>2023-08-29T05:30:18.359Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="带因子的二叉树">带因子的二叉树</h2><h3 id="题目预览">题目预览：</h3><p>给出一个含有不重复整数元素的数组 <spanclass="math inline">\(arr\)</span> ，每个整数 <spanclass="math inline">\(arr[i]\)</span> 均大于 <spanclass="math inline">\(1\)</span>。</p><p>用这些整数来构建二叉树，每个整数可以使用任意次数。其中：每个非叶结点的值应等于它的两个子结点的值的乘积。</p><p>满足条件的二叉树一共有多少个？答案可能很大，返回 <b>对 <spanclass="math inline">\(10^9 + 7\)</span> 取余</b> 的结果。</p><h4 id="示例-1">示例 1:</h4><blockquote><p><b>输入:</b> arr = [2, 4]<br /><b>输出:</b> 3<br /><b>解释:</b> 可以得到这些二叉树: [2], [4], [4, 2, 2]</p></blockquote><h4 id="示例-2">示例 2:</h4><blockquote><p><b>输入:</b> arr = [2, 4, 5, 10]<br /><b>输出:</b> 7<br /><b>解释:</b> 可以得到这些二叉树: [2], [4], [5], [10], [4, 2, 2], [10, 2,5], [10, 5, 2].</p></blockquote><p>提示：</p><ul><li><p><span class="math inline">\(1 &lt;= arr.length &lt;=1000\)</span></p></li><li><p><span class="math inline">\(2 &lt;= arr[i] &lt;=10^9\)</span></p></li><li><p><span class="math inline">\(arr\)</span> 中的所有值<b>互不相同</b></p></li></ul><hr /><p>以下是题解：</p><h3 id="思路-递推">思路: 递推</h3><p>对于每个根节点，由题意可以确定其值一定大于它的任意一个子节点，因此我们可以先将容器按<b>升序</b> 排序，然后依次计算其中的数据：</p><ul><li><p>我们可以直接停止构建，此时二叉树只有一个根节点，这算 <spanclass="math inline">\(1\)</span> 个方案。</p></li><li><p>记 <span class="math inline">\(val=arr[i]\)</span> 。枚举 <spanclass="math inline">\(x=arr[j]\)</span> ，如果 <spanclass="math inline">\(val\)</span> 能被 <spanclass="math inline">\(x\)</span> 整除且 <spanclass="math inline">\(\frac{val}{x}\)</span> 在 <spanclass="math inline">\(arr\)</span> 中（设其下标为 <spanclass="math inline">\(k\)</span>），那么分解 <spanclass="math inline">\(val=x×\frac{val}{x}\)</span> ，方案数等于 <spanclass="math inline">\(f[j]×f[k]\)</span> 。</p></li><li><p>把这些方案数全部加起来，就得到了 <spanclass="math inline">\(f[i]\)</span> 。</p></li><li><p>由于 <span class="math inline">\(j&lt;i\)</span> 且 <spanclass="math inline">\(k&lt;i\)</span> ，我们要从小到大遍历计算每个状态<span class="math inline">\(f[i]\)</span> 。</p></li></ul><p>初始值：所有 <span class="math inline">\(f[i]\)</span> 都初始化成<span class="math inline">\(1\)</span> 。</p><p>答案为: <span class="math inline">\(\sum_{n-1}^{i=0}f[i]\)</span></p><p>代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numFactoredBinaryTrees</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> Mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">        <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> Len=arr.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; idx;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            idx[arr[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;<span class="built_in">f</span>(Len,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> val=arr[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> tmp=arr[j];</span><br><span class="line">                <span class="keyword">if</span>(val%tmp==<span class="number">0</span>&amp;&amp;idx.<span class="built_in">count</span>(val/tmp))</span><br><span class="line">                    f[i]+=f[j]*f[idx[val/tmp]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">accumulate</span>(f.<span class="built_in">begin</span>(),f.<span class="built_in">end</span>(),<span class="number">0LL</span>)%Mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPaHwDK"><imgsrc="https://s1.ax1x.com/2023/08/29/pPaHwDK.png"alt="pPaHwDK.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/29 13:06:24</p>]]></content>
    
    
    <summary type="html">带因子的二叉树</summary>
    
    
    
    <category term="程序" scheme="https://www.lwt-server.cn/categories/%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="LeetCode题解" scheme="https://www.lwt-server.cn/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
    <category term="LeetCode每日一题" scheme="https://www.lwt-server.cn/tags/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解——15.三数之和</title>
    <link href="https://www.lwt-server.cn/2023/08/29/LeetCode_15/"/>
    <id>https://www.lwt-server.cn/2023/08/29/LeetCode_15/</id>
    <published>2023-08-29T01:09:05.000Z</published>
    <updated>2023-08-29T14:13:33.018Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="三数之和">三数之和</h2><h3 id="题目预览">题目预览：</h3><p>给你一个整数数组 <span class="math inline">\(nums\)</span>，判断是否存在三元组 <span class="math inline">\([nums[i], nums[j],nums[k]]\)</span> 满足 <span class="math inline">\(i !=j\)</span>、<span class="math inline">\(i != k\)</span> 且 <spanclass="math inline">\(j != k\)</span> ，同时还满足 <spanclass="math inline">\(nums[i] + nums[j] + nums[k] == 0\)</span> 。请</p><p>你返回所有和为 <span class="math inline">\(0\)</span>且不重复的三元组。</p><p><b>注意：</b>答案中不可以包含重复的三元组。</p><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>nums = [-1,0,1,2,-1,-4]<br /><b>输出：</b>[[-1,-1,2],[-1,0,1]]<br /><b>解释：</b><br />nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。<br />nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。<br />nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。<br />不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。<br />注意，输出的顺序和三元组的顺序并不重要。</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>nums = [0,1,1]<br /><b>输出：</b>[]<br /><b>解释：</b>唯一可能的三元组和不为 0 。</p></blockquote><h4 id="示例-3">示例 3：</h4><blockquote><p><b>输入：</b>nums = [0,0,0]<br /><b>输出：</b>[[0,0,0]]<br /><b>解释：</b>唯一可能的三元组和为 0 。</p></blockquote><p>提示：</p><ul><li><span class="math inline">\(3 &lt;= nums.length &lt;=3000\)</span></li><li><span class="math inline">\(-10^5 &lt;= nums[i] &lt;=10^5\)</span></li></ul><hr /><p>以下是题解：</p><h3 id="解题思路">解题思路:</h3><p><b>排序 + 双指针</b></p><p>本题的难点在于 <b>如何去除重复解</b> 。</p><h4 id="算法流程">算法流程：</h4><ol type="1"><li><p>特判，对于数组长度 <spanclass="math inline">\(n\)</span>，如果数组为 <spanclass="math inline">\(null\)</span> 或者数组长度小于 <spanclass="math inline">\(3\)</span>，返回 <spanclass="math inline">\([]\)</span>。</p></li><li><p>对数组进行排序。</p></li><li><p>遍历排序后数组：</p><ul><li><p>若 <spanclass="math inline">\(nums[i]&gt;0\)</span>：因为已经排序好，所以后面不可能有三个数加和等于<span class="math inline">\(0\)</span>，直接返回结果。</p></li><li><p>对于重复元素：跳过，避免出现重复解</p></li><li><p>令左指针 <span class="math inline">\(Left=i+1\)</span>，右指针<span class="math inline">\(Right=n−1\)</span>，当 <spanclass="math inline">\(Left&lt;Right\)</span> 时，执行循环：</p><ul><li><p>当 <spanclass="math inline">\(nums[i]+nums[Left]+nums[Right]==0\)</span>，执行循环，判断左界和右界是否和下一位置重复，去除重复解。并同时将<span class="math inline">\(Left,Right\)</span>移到下一位置，寻找新的解</p></li><li><p>若和大于 <span class="math inline">\(0\)</span>，说明 <spanclass="math inline">\(nums[Right]\)</span> 太大，<spanclass="math inline">\(Right\)</span> 左移</p></li><li><p>若和小于 <span class="math inline">\(0\)</span>，说明 <spanclass="math inline">\(nums[Left]\)</span> 太小，<spanclass="math inline">\(Left\)</span> 右移</p></li></ul></li></ul></li></ol><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="type">int</span> Len=nums.<span class="built_in">size</span>(),Left=<span class="number">0</span>,Right=<span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(Len&lt;<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i<span class="number">-1</span>]==nums[i])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                Left=i+<span class="number">1</span>,Right=Len<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span>(Left&lt;Right)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> x=nums[i],y=nums[Left],z=nums[Right];</span><br><span class="line">                    <span class="keyword">if</span>(x+y+z==<span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        ans.<span class="built_in">push_back</span>(&#123;nums[i],nums[Left],nums[Right]&#125;);</span><br><span class="line">                        <span class="keyword">while</span>(Left&lt;Right&amp;&amp;y==nums[Left+<span class="number">1</span>])</span><br><span class="line">                            Left++;</span><br><span class="line">                        <span class="keyword">while</span>(Left&lt;Right&amp;&amp;nums[Right<span class="number">-1</span>]==z)</span><br><span class="line">                            Right--;</span><br><span class="line">                        Left++;</span><br><span class="line">                        Right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(x+y+z&gt;<span class="number">0</span>)</span><br><span class="line">                        Right--;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        Left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i+<span class="number">1</span>&lt;Len&amp;&amp;nums[i]==nums[i+<span class="number">1</span>])</span><br><span class="line">                i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPaR2wR"><imgsrc="https://s1.ax1x.com/2023/08/29/pPaR2wR.png"alt="pPaR2wR.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/29 09:09:05</p>]]></content>
    
    
    <summary type="html">三数之和</summary>
    
    
    
    <category term="程序" scheme="https://www.lwt-server.cn/categories/%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="LeetCode题解" scheme="https://www.lwt-server.cn/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解——14.最长公共前缀</title>
    <link href="https://www.lwt-server.cn/2023/08/28/LeetCode_14/"/>
    <id>https://www.lwt-server.cn/2023/08/28/LeetCode_14/</id>
    <published>2023-08-28T12:46:08.000Z</published>
    <updated>2023-08-28T13:04:33.339Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="最长公共前缀">最长公共前缀</h2><h3 id="题目预览">题目预览：</h3><p>编写一个函数来查找字符串数组中的 <b>最长公共前缀</b> 。</p><p>如果不存在公共前缀，返回空字符串 <code>""</code>。</p><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>strs = ["flower","flow","flight"] <b>输出：</b>"fl"</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>strs = ["dog","racecar","car"] <b>输出：</b>""<b>解释：</b>输入不存在公共前缀。</p></blockquote><p>提示：</p><ul><li><p><span class="math inline">\(1 &lt;= strs.length &lt;=200\)</span></p></li><li><p><span class="math inline">\(0 &lt;= strs[i].length &lt;=200\)</span></p></li><li><p><span class="math inline">\(strs[i]仅由小写英文字母组成\)</span></p></li></ul><hr /><p>以下是题解：</p><h3 id="解题思路">解题思路:</h3><p>本题思路较清晰，对于若干个字符串，我们可以先储存第一个的字符串的字符，然后依次比较后面字符串的相应部分。</p><p>特殊情况包括： 1. 字符串容器为空：返回<code>""</code> 2.字符串为空：返回<code>""</code></p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> Len=strs.<span class="built_in">size</span>(),tag=<span class="number">0</span>,flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(Len==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(strs[<span class="number">0</span>]==<span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        string ans=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">char</span> tmp=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        flag=strs[<span class="number">0</span>].<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">while</span>(tag&lt;flag)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp=strs[<span class="number">0</span>][tag];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;Len;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(tag&gt;=strs[i].<span class="built_in">length</span>())</span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">                <span class="keyword">if</span>(strs[i][tag]!=tmp)</span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">            ans+=tmp;</span><br><span class="line">            tag++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPaNpVJ"><imgsrc="https://s1.ax1x.com/2023/08/28/pPaNpVJ.png"alt="pPaNpVJ.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/28 20:46:08</p>]]></content>
    
    
    <summary type="html">最长公共前缀</summary>
    
    
    
    <category term="程序" scheme="https://www.lwt-server.cn/categories/%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="LeetCode题解" scheme="https://www.lwt-server.cn/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解——13.罗马数字转整数</title>
    <link href="https://www.lwt-server.cn/2023/08/28/LeetCode_13/"/>
    <id>https://www.lwt-server.cn/2023/08/28/LeetCode_13/</id>
    <published>2023-08-28T11:46:48.000Z</published>
    <updated>2023-08-28T12:54:21.755Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="罗马数字转整数">罗马数字转整数</h2><h3 id="题目预览">题目预览：</h3><p>罗马数字包含以下七种字符: <spanclass="math inline">\(I\)</span>，<spanclass="math inline">\(V\)</span>，<spanclass="math inline">\(X\)</span>，<spanclass="math inline">\(L\)</span>，<spanclass="math inline">\(C\)</span>，<span class="math inline">\(D\)</span>和 <span class="math inline">\(M\)</span>。</p><table><thead><tr class="header"><th style="text-align: center;">字符</th><th style="text-align: center;">数值</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">I</td><td style="text-align: center;">1</td></tr><tr class="even"><td style="text-align: center;">V</td><td style="text-align: center;">5</td></tr><tr class="odd"><td style="text-align: center;">X</td><td style="text-align: center;">10</td></tr><tr class="even"><td style="text-align: center;">L</td><td style="text-align: center;">50</td></tr><tr class="odd"><td style="text-align: center;">C</td><td style="text-align: center;">100</td></tr><tr class="even"><td style="text-align: center;">D</td><td style="text-align: center;">500</td></tr><tr class="odd"><td style="text-align: center;">M</td><td style="text-align: center;">1000</td></tr></tbody></table><p>例如， 罗马数字 <span class="math inline">\(2\)</span> 写做 <spanclass="math inline">\(II\)</span> ，即为两个并列的 <spanclass="math inline">\(1\)</span>。<spanclass="math inline">\(12\)</span> 写做 <spanclass="math inline">\(XII\)</span> ，即为 <span class="math inline">\(X+ II\)</span> 。 <span class="math inline">\(27\)</span> 写做 <spanclass="math inline">\(XXVII\)</span>, 即为 <spanclass="math inline">\(XX + V + II\)</span> 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如<span class="math inline">\(4\)</span> 不写做 <spanclass="math inline">\(IIII\)</span>，而是 <spanclass="math inline">\(IV\)</span>。数字 <spanclass="math inline">\(1\)</span> 在数字 <spanclass="math inline">\(5\)</span> 的左边，所表示的数等于大数 <spanclass="math inline">\(5\)</span> 减小数 <spanclass="math inline">\(1\)</span> 得到的数值 <spanclass="math inline">\(4\)</span> 。同样地，数字 <spanclass="math inline">\(9\)</span> 表示为 <spanclass="math inline">\(IX\)</span>。这个特殊的规则只适用于以下六种情况：</p><ul><li><p><span class="math inline">\(I\)</span> 可以放在 <spanclass="math inline">\(V\ (5)\)</span> 和 <span class="math inline">\(X\(10)\)</span> 的左边，来表示 <span class="math inline">\(4\)</span> 和<span class="math inline">\(9\)</span>。</p></li><li><p><span class="math inline">\(X\)</span> 可以放在 <spanclass="math inline">\(L\ (50)\)</span> 和 <span class="math inline">\(C\(100)\)</span> 的左边，来表示 <span class="math inline">\(40\)</span> 和<span class="math inline">\(90\)</span>。</p></li><li><p><span class="math inline">\(C\)</span> 可以放在 <spanclass="math inline">\(D\ (500)\)</span> 和 <spanclass="math inline">\(M\ (1000)\)</span> 的左边，来表示 <spanclass="math inline">\(400\)</span> 和 <spanclass="math inline">\(900\)</span>。</p></li></ul><p>给定一个罗马数字，将其转换成整数。</p><h4 id="示例-1">示例 1:</h4><blockquote><p><b>输入:</b> s = "III"<br /><b>输出:</b> 3</p></blockquote><h4 id="示例-2">示例 2:</h4><blockquote><p><b>输入:</b> s = "IV"<br /><b>输出:</b> 4</p></blockquote><h4 id="示例-3">示例 3:</h4><blockquote><p><b>输入:</b> s = "IX"<br /><b>输出:</b> 9</p></blockquote><h4 id="示例-4">示例 4:</h4><blockquote><p><b>输入:</b> s = "LVIII"<br /><b>输出:</b> 58<br /><b>解释:</b> L = 50, V= 5, III = 3.</p></blockquote><h4 id="示例-5">示例 5:</h4><blockquote><p><b>输入:</b> s = "MCMXCIV"<br /><b>输出:</b> 1994<br /><b>解释:</b> M = 1000, CM = 900, XC = 90, IV = 4.</p></blockquote><p>提示：</p><ul><li><p><span class="math inline">\(1 &lt;= s.length &lt;=15\)</span></p></li><li><p><span class="math inline">\(s 仅含字符 (&#39;I&#39;, &#39;V&#39;,&#39;X&#39;, &#39;L&#39;, &#39;C&#39;, &#39;D&#39;,&#39;M&#39;)\)</span></p></li><li><p>题目数据保证 <span class="math inline">\(s\)</span>是一个有效的罗马数字，且表示整数在范围 <span class="math inline">\([1,3999]\)</span> 内</p></li><li><p>题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。</p></li><li><p><span class="math inline">\(IL\)</span> 和 <spanclass="math inline">\(IM\)</span> 这样的例子并不符合题目要求，<spanclass="math inline">\(49\)</span> 应该写作 <spanclass="math inline">\(XLIX\)</span> ，<spanclass="math inline">\(999\)</span> 应该写作 <spanclass="math inline">\(CMXCIX\)</span> 。</p></li></ul><hr /><p>以下是题解：</p><h3 id="解题思路">解题思路:</h3><p>该题与前一题(<ahref="/2023/08/28/LeetCode_12/">LeetCode_12</a>)十分相似，过程也完全是之前的逆过程，由此我们可以轻松得出相应的计算过程，即：依次遍历每一个字符，对于一些特殊字符（如<spanclass="math inline">\(I\)</span>，<spanclass="math inline">\(X\)</span>，<spanclass="math inline">\(C\)</span>），我们多搜索一位以进行匹配。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">romanToInt</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> Len=s.<span class="built_in">length</span>(),Num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i+<span class="number">1</span>]==<span class="string">&#x27;V&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Num+=<span class="number">4</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s[i+<span class="number">1</span>]==<span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Num+=<span class="number">9</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    Num+=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;V&#x27;</span>)</span><br><span class="line">                Num+=<span class="number">5</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i+<span class="number">1</span>]==<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Num+=<span class="number">40</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s[i+<span class="number">1</span>]==<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Num+=<span class="number">90</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    Num+=<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">                Num+=<span class="number">50</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i+<span class="number">1</span>]==<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Num+=<span class="number">400</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s[i+<span class="number">1</span>]==<span class="string">&#x27;M&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Num+=<span class="number">900</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    Num+=<span class="number">100</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">                Num+=<span class="number">500</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;M&#x27;</span>)</span><br><span class="line">                Num+=<span class="number">1000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPaG9pT"><imgsrc="https://s1.ax1x.com/2023/08/28/pPaG9pT.png"alt="pPaG9pT.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/28 19:46:48</p>]]></content>
    
    
    <summary type="html">罗马数字转整数</summary>
    
    
    
    <category term="程序" scheme="https://www.lwt-server.cn/categories/%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="LeetCode题解" scheme="https://www.lwt-server.cn/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解——12.整数转罗马数字</title>
    <link href="https://www.lwt-server.cn/2023/08/28/LeetCode_12/"/>
    <id>https://www.lwt-server.cn/2023/08/28/LeetCode_12/</id>
    <published>2023-08-28T09:13:06.000Z</published>
    <updated>2023-08-28T13:01:16.205Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="整数转罗马数字">整数转罗马数字</h2><h3 id="题目预览">题目预览：</h3><p>罗马数字包含以下七种字符： <span class="math inline">\(I\)</span>，<span class="math inline">\(V\)</span>， <spanclass="math inline">\(X\)</span>， <spanclass="math inline">\(L\)</span>，<spanclass="math inline">\(C\)</span>，<span class="math inline">\(D\)</span>和 <span class="math inline">\(M\)</span>。</p><table><thead><tr class="header"><th style="text-align: center;">字符</th><th style="text-align: center;">数值</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">I</td><td style="text-align: center;">1</td></tr><tr class="even"><td style="text-align: center;">V</td><td style="text-align: center;">5</td></tr><tr class="odd"><td style="text-align: center;">X</td><td style="text-align: center;">10</td></tr><tr class="even"><td style="text-align: center;">L</td><td style="text-align: center;">50</td></tr><tr class="odd"><td style="text-align: center;">C</td><td style="text-align: center;">100</td></tr><tr class="even"><td style="text-align: center;">D</td><td style="text-align: center;">500</td></tr><tr class="odd"><td style="text-align: center;">M</td><td style="text-align: center;">1000</td></tr></tbody></table><p>例如， 罗马数字 <span class="math inline">\(2\)</span> 写做 <spanclass="math inline">\(II\)</span> ，即为两个并列的 <spanclass="math inline">\(1\)</span>。<spanclass="math inline">\(12\)</span> 写做 <spanclass="math inline">\(XII\)</span> ，即为 <span class="math inline">\(X+ II\)</span> 。 <span class="math inline">\(27\)</span> 写做 <spanclass="math inline">\(XXVII\)</span>, 即为 <spanclass="math inline">\(XX + V + II\)</span> 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如<span class="math inline">\(4\)</span> 不写做 <spanclass="math inline">\(IIII\)</span>，而是 <spanclass="math inline">\(IV\)</span>。数字 <spanclass="math inline">\(1\)</span> 在数字 <spanclass="math inline">\(5\)</span> 的左边，所表示的数等于大数 <spanclass="math inline">\(5\)</span> 减小数 <spanclass="math inline">\(1\)</span> 得到的数值 <spanclass="math inline">\(4\)</span> 。同样地，数字 <spanclass="math inline">\(9\)</span> 表示为 <spanclass="math inline">\(IX\)</span>。这个特殊的规则只适用于以下六种情况：</p><ul><li><p><span class="math inline">\(I\)</span> 可以放在 <spanclass="math inline">\(V\ (5)\)</span> 和 <span class="math inline">\(X\(10)\)</span> 的左边，来表示 <span class="math inline">\(4\)</span> 和<span class="math inline">\(9\)</span>。</p></li><li><p><span class="math inline">\(X\)</span> 可以放在 <spanclass="math inline">\(L\ (50)\)</span> 和 <span class="math inline">\(C\(100)\)</span> 的左边，来表示 <span class="math inline">\(40\)</span> 和<span class="math inline">\(90\)</span>。</p></li><li><p><span class="math inline">\(C\)</span> 可以放在 <spanclass="math inline">\(D\ (500)\)</span> 和 <spanclass="math inline">\(M\ (1000)\)</span> 的左边，来表示 <spanclass="math inline">\(400\)</span> 和 <spanclass="math inline">\(900\)</span>。</p></li></ul><p>给你一个整数，将其转为罗马数字。</p><h4 id="示例-1">示例 1:</h4><p><b>输入:</b> num = 3 <b>输出:</b> "III"</p><h4 id="示例-2">示例 2:</h4><p><b>输入:</b> num = 4 <b>输出:</b> "IV"</p><h4 id="示例-3">示例 3:</h4><p><b>输入:</b> num = 9 <b>输出:</b> "IX"</p><h4 id="示例-4">示例 4:</h4><p><b>输入:</b> num = 58 <b>输出:</b> "LVIII" <b>解释:</b> L = 50, V =5, III = 3.</p><h4 id="示例-5">示例 5:</h4><p><b>输入:</b> num = 1994 <b>输出:</b> "MCMXCIV" <b>解释:</b> M = 1000,CM = 900, XC = 90, IV = 4.</p><p>提示：</p><ul><li><span class="math inline">\(1 &lt;= num &lt;= 3999\)</span></li></ul><hr /><p>以下是题解：</p><h3 id="解题思路模拟">解题思路:模拟：</h3><p>按照题意，优先满足大数对应的转换可以保证答案正确，剩下的只是简单的模拟：</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">while</span>(num&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(num<span class="number">-1000</span>&gt;=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                num-=<span class="number">1000</span>;</span><br><span class="line">                ans+=<span class="string">&#x27;M&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num<span class="number">-900</span>&gt;=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                num-=<span class="number">900</span>;</span><br><span class="line">                ans+=<span class="string">&quot;CM&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num<span class="number">-500</span>&gt;=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                num-=<span class="number">500</span>;</span><br><span class="line">                ans+=<span class="string">&quot;D&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num<span class="number">-400</span>&gt;=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                num-=<span class="number">400</span>;</span><br><span class="line">                ans+=<span class="string">&quot;CD&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num<span class="number">-100</span>&gt;=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                num-=<span class="number">100</span>;</span><br><span class="line">                ans+=<span class="string">&quot;C&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num<span class="number">-90</span>&gt;=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                num-=<span class="number">90</span>;</span><br><span class="line">                ans+=<span class="string">&quot;XC&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num<span class="number">-50</span>&gt;=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                num-=<span class="number">50</span>;</span><br><span class="line">                ans+=<span class="string">&quot;L&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num<span class="number">-40</span>&gt;=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                num-=<span class="number">40</span>;</span><br><span class="line">                ans+=<span class="string">&quot;XL&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num<span class="number">-10</span>&gt;=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                num-=<span class="number">10</span>;</span><br><span class="line">                ans+=<span class="string">&quot;X&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num<span class="number">-9</span>&gt;=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                num-=<span class="number">9</span>;</span><br><span class="line">                ans+=<span class="string">&quot;IX&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num<span class="number">-5</span>&gt;=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                num-=<span class="number">5</span>;</span><br><span class="line">                ans+=<span class="string">&quot;V&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num<span class="number">-4</span>&gt;=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                num-=<span class="number">4</span>;</span><br><span class="line">                ans+=<span class="string">&quot;IV&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                num-=<span class="number">1</span>;</span><br><span class="line">                ans+=<span class="string">&quot;I&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果：</h4><p><a href="https://imgse.com/i/pPaKb6A"><imgsrc="https://s1.ax1x.com/2023/08/28/pPaKb6A.png"alt="pPaKb6A.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/28 17:13:06</p>]]></content>
    
    
    <summary type="html">整数转罗马数字</summary>
    
    
    
    <category term="程序" scheme="https://www.lwt-server.cn/categories/%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="LeetCode题解" scheme="https://www.lwt-server.cn/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解——11.盛最多水的容器</title>
    <link href="https://www.lwt-server.cn/2023/08/28/LeetCode_11/"/>
    <id>https://www.lwt-server.cn/2023/08/28/LeetCode_11/</id>
    <published>2023-08-28T09:12:55.000Z</published>
    <updated>2023-08-28T09:41:15.788Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="盛最多水的容器">盛最多水的容器</h2><h3 id="题目预览">题目预览：</h3><p>给定一个长度为 <span class="math inline">\(n\)</span> 的整数数组<span class="math inline">\(height\)</span> 。有 <spanclass="math inline">\(n\)</span> 条垂线，第 <spanclass="math inline">\(i\)</span> 条线的两个端点是 <spanclass="math inline">\((i, 0)\)</span> 和 <span class="math inline">\((i,height[i])\)</span> 。</p><p>找出其中的两条线，使得它们与 <span class="math inline">\(x\)</span>轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p>说明：你不能倾斜容器。</p><h4 id="示例-1">示例 1：</h4><p><a href="https://imgse.com/i/pPaK5FO"><imgsrc="https://s1.ax1x.com/2023/08/28/pPaK5FO.jpg"alt="pPaK5FO.jpg" /></a></p><blockquote><p><b>输入：</b>[1,8,6,2,5,4,8,3,7]<br /><b>输出：</b>49<br /><b>解释：</b>图中垂直线代表输入数组[1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为49。</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>height = [1,1]<br /><b>输出：</b>1</p></blockquote><p>提示：</p><ul><li><p><span class="math inline">\(n == height.length\)</span></p></li><li><p><span class="math inline">\(2 &lt;= n &lt;= 105\)</span></p></li><li><p><span class="math inline">\(0 &lt;= height[i] &lt;=10^4\)</span></p></li></ul><hr /><p>以下是题解：</p><h3 id="解题思路双指针法">解题思路:双指针法：</h3><ol type="1"><li>定义两个分别指向容器两端的指针；<br /></li><li>依次向内收缩对应高度最短的一边；<br /></li><li>更新最大值；<br /></li><li>重复上述 <span class="math inline">\(2 , 3\)</span>步骤直到两个指针相遇。</li></ol><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>,Left=<span class="number">0</span>,Right=height.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(Left&lt;Right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> Len=Right-Left;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,<span class="built_in">min</span>(height[Left],height[Right])*Len);</span><br><span class="line">            <span class="keyword">if</span>(height[Left]&gt;height[Right])</span><br><span class="line">                Right--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                Left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPaKofe"><imgsrc="https://s1.ax1x.com/2023/08/28/pPaKofe.png"alt="pPaKofe.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/28 17:12:55</p>]]></content>
    
    
    <summary type="html">盛最多水的容器</summary>
    
    
    
    <category term="程序" scheme="https://www.lwt-server.cn/categories/%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="LeetCode题解" scheme="https://www.lwt-server.cn/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解——10.正则表达式匹配</title>
    <link href="https://www.lwt-server.cn/2023/08/28/LeetCode_10/"/>
    <id>https://www.lwt-server.cn/2023/08/28/LeetCode_10/</id>
    <published>2023-08-28T07:19:08.000Z</published>
    <updated>2023-08-28T09:32:51.838Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="字符串转换整数-atoi">字符串转换整数 (atoi)</h2><h3 id="题目预览">题目预览：</h3><p>给你一个字符串 <span class="math inline">\(s\)</span> 和一个字符规律<span class="math inline">\(p\)</span>，请你来实现一个支持<code>'.'</code> 和 <code>'*'</code> 的正则表达式匹配。</p><ul><li><p><code>'.'</code> 匹配任意单个字符</p></li><li><p><code>'*'</code> 匹配零个或多个前面的那一个元素</p></li></ul><p>所谓匹配，是要涵盖 <b>整个</b> 字符串 <spanclass="math inline">\(s\)</span> 的，而不是部分字符串。</p><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>s = <code>"aa"</code>, p = <code>"a"</code><br /><b>输出：</b>false<br /><b>解释：</b><code>"a"</code> 无法匹配 <code>"aa"</code>整个字符串。</p></blockquote><h4 id="示例-2">示例 2:</h4><blockquote><p><b>输入：</b>s = <code>"aa"</code>, p = <code>"a*"</code><br /><b>输出：</b>true<br /><b>解释：</b>因为 <code>'*'</code>代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是<code>'a'</code>。因此，字符串 <code>"aa"</code> 可被视为<code>'a'</code> 重复了一次。</p></blockquote><h4 id="示例-3">示例 3：</h4><blockquote><p><b>输入：</b>s = <code>"ab"</code>, p = <code>".*"</code><br /><b>输出：</b>true<br /><b>解释：</b><code>".*"</code>表示可匹配零个或多个（<code>'*'</code>）任意字符（<code>'.'</code>）。</p></blockquote><p>提示：</p><ul><li><p><span class="math inline">\(1 &lt;= s.length &lt;=20\)</span></p></li><li><p><span class="math inline">\(1 &lt;= p.length &lt;=20\)</span></p></li><li><p><span class="math inline">\(s\)</span> 只包含从 <spanclass="math inline">\(a-z\)</span> 的小写字母。</p></li><li><p><span class="math inline">\(p\)</span> 只包含从 <spanclass="math inline">\(a-z\)</span> 的小写字母，以及字符 <code>.</code>和 <code>*</code>。 保证每次出现字符 <code>*</code>时，前面都匹配到有效的字符</p></li></ul><hr /><p>以下是题解：</p><h3 id="解题思路动态规划">解题思路:动态规划</h3><h4 id="状态转移方程如下">状态转移方程如下：</h4><p><span class="math display">\[    dp[i][j]=    \begin{cases}        dp[i−1][j−1], &amp; s[i]=p[j]\\        dp[i][j−2], &amp; p[j]=‘∗‘\ \&amp;\ s[i]=p[j−1] \\        dp[i][j−2] \ or \ dp[i−1][j], &amp; p[j]=‘∗‘\ \&amp;\s[i]=p[j−1]\\    \end{cases}\]</span></p><h4 id="初始化">初始化</h4><p>记 <span class="math inline">\(s\)</span> 的长度为 <spanclass="math inline">\(m\)</span>，<span class="math inline">\(p\)</span>的长度为 <span class="math inline">\(n\)</span>。为便于状态更新，减少对边界的判断，初始二维 <spanclass="math inline">\(dp\)</span> 数组维度为 <spanclass="math inline">\((m+1)×(n+1)\)</span>，其中第一行和第一列的状态分别表示字符串 <spanclass="math inline">\(s\)</span> 和 <spanclass="math inline">\(p\)</span> 为空时的情况。</p><p>显然，<span class="math inline">\(dp[0][0]=True\)</span> 。对于其他<span class="math inline">\(dp[0][j]\)</span> ，当 <spanclass="math inline">\(p[j]≠\)</span><code>'*'</code> 时，<spanclass="math inline">\(s[0,...,j]\)</span> 无法与空字符匹配，因此有 <spanclass="math inline">\(dp[0][j]=False\)</span> ；而当 <spanclass="math inline">\(p[j]=\)</span><code>'*'</code>时，则有 <spanclass="math inline">\(dp[0][j]\)</span>=<spanclass="math inline">\(dp[0][j-2]\)</span> 。</p><blockquote><p>⚠️ 需要特别注意的是，由于 <span class="math inline">\(dp\)</span>数组维度为 <span class="math inline">\((m+1)×(n+1)\)</span>，在具体代码实现时，<span class="math inline">\(s[i−1]\)</span> 和 <spanclass="math inline">\(p[j−1]\)</span> 才是分别表示 <spanclass="math inline">\(s\)</span> 和 <spanclass="math inline">\(p\)</span> 中的第 <spanclass="math inline">\(i\)</span> 和第 <spanclass="math inline">\(j\)</span> 个字符。</p></blockquote><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> sLen=s.<span class="built_in">length</span>(),pLen=p.<span class="built_in">length</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(sLen+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(pLen+<span class="number">1</span>,<span class="literal">false</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=pLen;j++)</span><br><span class="line">            <span class="keyword">if</span>(p[j<span class="number">-1</span>]==<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                dp[<span class="number">0</span>][j]=dp[<span class="number">0</span>][j<span class="number">-2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=sLen;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=pLen;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>]==p[j<span class="number">-1</span>]||p[j<span class="number">-1</span>]==<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(p[j<span class="number">-1</span>]==<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(s[i<span class="number">-1</span>]!=p[j<span class="number">-2</span>]&amp;&amp;p[j<span class="number">-2</span>]!=<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                        dp[i][j]=dp[i][j<span class="number">-2</span>];</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        dp[i][j]=dp[i][j<span class="number">-2</span>]|dp[i<span class="number">-1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[sLen][pLen];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPa9W6g"><imgsrc="https://s1.ax1x.com/2023/08/28/pPa9W6g.png"alt="pPa9W6g.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/28 15:19:08</p>]]></content>
    
    
    <summary type="html">正则表达式匹配</summary>
    
    
    
    <category term="程序" scheme="https://www.lwt-server.cn/categories/%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="LeetCode题解" scheme="https://www.lwt-server.cn/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解——9.回文数</title>
    <link href="https://www.lwt-server.cn/2023/08/28/LeetCode_9/"/>
    <id>https://www.lwt-server.cn/2023/08/28/LeetCode_9/</id>
    <published>2023-08-28T06:45:03.000Z</published>
    <updated>2023-08-28T09:32:48.349Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="回文数">回文数</h2><h3 id="题目预览">题目预览：</h3><p>给你一个整数 <span class="math inline">\(x\)</span> ，如果 <spanclass="math inline">\(x\)</span> 是一个回文整数，返回 <spanclass="math inline">\(true\)</span> ；否则，返回 <spanclass="math inline">\(false\)</span> 。</p><p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><ul><li>例如，<span class="math inline">\(121\)</span> 是回文，而 <spanclass="math inline">\(123\)</span> 不是。</li></ul><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>x = 121<br /><b>输出：</b>true</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>x = -121<br /><b>输出：</b>false<br /><b>解释：</b>从左向右读, 为 -121 。 从右向左读, 为 121-。因此它不是一个回文数。</p></blockquote><h4 id="示例-3">示例 3：</h4><blockquote><p><b>输入：</b>x = 10<br /><b>输出：</b>false<br /><b>解释：</b>从右向左读, 为 01 。因此它不是一个回文数。</p></blockquote><p>提示：</p><ul><li><span class="math inline">\(-2^{31} &lt;= x &lt;= 2^{31} -1\)</span></li></ul><p><b>进阶：</b>你能不将整数转为字符串来解决这个问题吗？</p><hr /><p>以下是题解：</p><h3 id="解题思路">解题思路:</h3><p>通过经典对10取模法求得其对应逆序数字的值，与原值比较。</p><blockquote><p>这里使用长整型应对溢出问题</p></blockquote><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> Num=<span class="number">0</span>,tmp=x;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(tmp/<span class="number">10</span>!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Num=Num*<span class="number">10</span>+(tmp%<span class="number">10</span>);</span><br><span class="line">            tmp/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Num=Num*<span class="number">10</span>+tmp;</span><br><span class="line">        <span class="keyword">if</span>(Num==x)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPakxFs"><imgsrc="https://s1.ax1x.com/2023/08/28/pPakxFs.png"alt="pPakxFs.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/28 14:45:03</p>]]></content>
    
    
    <summary type="html">回文数</summary>
    
    
    
    <category term="程序" scheme="https://www.lwt-server.cn/categories/%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="LeetCode题解" scheme="https://www.lwt-server.cn/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解——57.插入区间</title>
    <link href="https://www.lwt-server.cn/2023/08/28/LeetCode_57/"/>
    <id>https://www.lwt-server.cn/2023/08/28/LeetCode_57/</id>
    <published>2023-08-28T01:23:09.000Z</published>
    <updated>2023-08-29T05:07:32.541Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="插入区间">插入区间</h2><h3 id="题目预览">题目预览：</h3><p>给你一个 <b>无重叠的</b> ，按照区间起始端点排序的区间列表。</p><p>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>intervals = [[1,3],[6,9]], newInterval = [2,5]<br /><b>输出：</b>[[1,5],[6,9]]</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]],newInterval = [4,8]<br /><b>输出：</b>[[1,2],[3,10],[12,16]]<br /><b>解释：</b>这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。</p></blockquote><h4 id="示例-3">示例 3：</h4><blockquote><p><b>输入：</b>intervals = [], newInterval = [5,7]<br /><b>输出：</b>[[5,7]]</p></blockquote><h4 id="示例-4">示例 4：</h4><blockquote><p><b>输入：</b>intervals = [[1,5]], newInterval = [2,3]<br /><b>输出：</b>[[1,5]]</p></blockquote><h4 id="示例-5">示例 5：</h4><blockquote><p><b>输入：</b>intervals = [[1,5]], newInterval = [2,7]<br /><b>输出：</b>[[1,7]]</p></blockquote><p>提示：</p><ul><li><p><span class="math inline">\(0 &lt;= intervals.length &lt;=10^4\)</span></p></li><li><p><span class="math inline">\(intervals[i].length ==2\)</span></p></li><li><p><span class="math inline">\(0 &lt;= intervals[i][0] &lt;=intervals[i][1] &lt;= 10^5\)</span></p></li><li><p><span class="math inline">\(intervals\)</span> 根据 <spanclass="math inline">\(intervals[i][0]\)</span> 按 <b>升序</b>排列</p></li><li><p><span class="math inline">\(newInterval.length ==2\)</span></p></li><li><p><span class="math inline">\(0 &lt;= newInterval[0] &lt;=newInterval[1] &lt;= 10^5\)</span></p></li></ul><hr /><p>以下是题解：</p><h3 id="思路">思路:</h3><p>该题与上一题(<ahref="/2023/08/27/LeetCode_56/">LeetCode_56</a>)类似，不同的是该题的intervals容器默认是有序的，而我们只需将newInterval插入对应的位置，新问题就转化成了我们已经解决的问题。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="type">int</span> Len = <span class="number">0</span>, Head = <span class="number">-1</span>, Tail = <span class="number">-1</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">insert</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals, vector&lt;<span class="type">int</span>&gt;&amp; newInterval) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123; newInterval &#125;;</span><br><span class="line">        Len = intervals.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;::iterator pos = intervals.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span> ((*pos)[<span class="number">0</span>] &lt; newInterval[<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            pos++;</span><br><span class="line">            <span class="keyword">if</span> (pos == intervals.<span class="built_in">end</span>())</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        intervals.<span class="built_in">insert</span>(pos,newInterval);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((intervals[i])[<span class="number">0</span>] &gt; Tail)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (Tail != <span class="number">-1</span>)</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(&#123; Head,Tail &#125;);</span><br><span class="line">                Head = intervals[i][<span class="number">0</span>];</span><br><span class="line">                Tail = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Tail = <span class="built_in">max</span>(Tail, intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(&#123; Head,Tail &#125;);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPU7E3q"><imgsrc="https://s1.ax1x.com/2023/08/28/pPU7E3q.png"alt="pPU7E3q.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/28 09:23:09</p>]]></content>
    
    
    <summary type="html">插入区间</summary>
    
    
    
    <category term="程序" scheme="https://www.lwt-server.cn/categories/%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="LeetCode题解" scheme="https://www.lwt-server.cn/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
    <category term="LeetCode每日一题" scheme="https://www.lwt-server.cn/tags/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解——8.字符串转换整数 (atoi)</title>
    <link href="https://www.lwt-server.cn/2023/08/27/LeetCode_8/"/>
    <id>https://www.lwt-server.cn/2023/08/27/LeetCode_8/</id>
    <published>2023-08-27T14:48:52.000Z</published>
    <updated>2023-08-28T09:32:42.404Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="字符串转换整数-atoi">字符串转换整数 (atoi)</h2><h3 id="题目预览">题目预览：</h3><p>请你来实现一个 <span class="math inline">\(myAtoi(string s)\)</span>函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 <spanclass="math inline">\(atoi\)</span> 函数）。</p><p>函数 <span class="math inline">\(myAtoi(string s)\)</span>的算法如下：</p><ol type="1"><li>读入字符串并丢弃无用的 <b>前导空格</b><br /></li><li>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。<br /></li><li>读入下一个字符，直到到达下一个 <b>非数字字符</b> 或到达输入的<b>结尾</b> 。字符串的其余部分将被 <b>忽略</b> 。<br /></li><li>将前面步骤读入的这些数字转换为整数（即，"123" -&gt; 123， "0032"-&gt; 32）。如果 <b>没有读入数字</b> ，则整数为 0。必要时更改符号（从步骤 2 开始）。<br /></li><li>如果整数数超过 32 位有符号整数范围 <spanclass="math inline">\([−2^{31}, 2^{31} − 1]\)</span>，需要截断这个整数，使其保持在这个范围内。具体来说，小于 <spanclass="math inline">\(−2^{31}\)</span> 的整数应该被固定为 <spanclass="math inline">\(−2^{31}\)</span> ，大于 <spanclass="math inline">\(2^{31} − 1\)</span> 的整数应该被固定为 <spanclass="math inline">\(2^{31} − 1\)</span> 。<br /></li><li>返回整数作为最终结果。</li></ol><p>注意：</p><p>本题中的空白字符只包括空格字符<code>' '</code>。除前导空格或数字后的其余字符串外，<b>请勿忽略</b>任何其他字符。</p><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>s = "42"<br /><b>输出：</b>42</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>s = " -42"<br /><b>输出：</b>-42</p></blockquote><h4 id="示例-3">示例 3：</h4><blockquote><p><b>输入：</b>s = "4193 with words"<br /><b>输出：</b>4193</p></blockquote><p>提示：</p><ul><li><span class="math inline">\(0 &lt;= s.length &lt;= 200\)</span></li><li><span class="math inline">\(s\)</span>由英文字母（大写和小写）、数字（<spanclass="math inline">\(0-9\)</span>）、' '、'+'、'-' 和 '.' 组成</li></ul><hr /><p>以下是题解：</p><h3 id="解题思路">解题思路:</h3><p>对字符串<span class="math inline">\(s\)</span>执行以下步骤：</p><ol type="1"><li><p>去除空格</p></li><li><p>判断正负</p></li><li><p>去除前导零（注意只有零的情况）</p></li><li><p>对每一位字符计算对应数字并累加求和</p></li></ol><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">myAtoi</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> Start=<span class="number">0</span>;</span><br><span class="line">        <span class="type">bool</span> isNegative=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(s[Start]==<span class="string">&#x27; &#x27;</span>)    <span class="comment">//去除空格</span></span><br><span class="line">            Start++;</span><br><span class="line">        <span class="keyword">if</span>(s[Start]==<span class="string">&#x27;-&#x27;</span>)   <span class="comment">//判断正负</span></span><br><span class="line">        &#123;</span><br><span class="line">            isNegative=<span class="literal">true</span>;</span><br><span class="line">            Start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[Start]==<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">            Start++;</span><br><span class="line">        <span class="keyword">while</span>(s[Start]==<span class="string">&#x27;0&#x27;</span>)    <span class="comment">//去除前导零</span></span><br><span class="line">            Start++;</span><br><span class="line">        <span class="keyword">if</span>(s[Start]&lt;<span class="string">&#x27;0&#x27;</span>||s[Start]&gt;<span class="string">&#x27;9&#x27;</span>)  <span class="comment">//判断只有零的情况</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> Len=<span class="number">0</span>;</span><br><span class="line">        string str=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(s[Start+Len]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;s[Start+Len]&lt;=<span class="string">&#x27;9&#x27;</span>) <span class="comment">//提取纯数字</span></span><br><span class="line">        &#123;</span><br><span class="line">            str+=s[Start+Len];</span><br><span class="line">            Len++;</span><br><span class="line">            <span class="keyword">if</span>(Len&gt;<span class="number">10</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> Num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=Len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)   <span class="comment">//求和</span></span><br><span class="line">            Num=Num*<span class="number">10</span>+(str[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(isNegative)  <span class="comment">//判断溢出</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Num&gt;<span class="number">2147483648</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-2147483648</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> -Num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Num&gt;<span class="number">2147483647</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2147483647</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> Num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPU2onA"><imgsrc="https://s1.ax1x.com/2023/08/27/pPU2onA.png"alt="pPU2onA.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/27 22:48:52</p>]]></content>
    
    
    <summary type="html">字符串转换整数 (atoi)</summary>
    
    
    
    <category term="程序" scheme="https://www.lwt-server.cn/categories/%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="LeetCode题解" scheme="https://www.lwt-server.cn/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解——7.整数反转</title>
    <link href="https://www.lwt-server.cn/2023/08/27/LeetCode_7/"/>
    <id>https://www.lwt-server.cn/2023/08/27/LeetCode_7/</id>
    <published>2023-08-27T11:31:56.000Z</published>
    <updated>2023-08-28T09:32:40.273Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="整数反转">整数反转</h2><h3 id="题目预览">题目预览：</h3><p>给你一个 32 位的有符号整数 <span class="math inline">\(x\)</span>，返回将 <span class="math inline">\(x\)</span>中的数字部分反转后的结果。</p><p>如果反转后整数超过 32 位的有符号整数的范围 <spanclass="math inline">\([−2^{31}, 2^{31} − 1]\)</span> ，就返回 0。</p><p>假设环境不允许存储 64 位整数（有符号或无符号）。</p><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>x = 123<br /><b>输出：</b>321</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>x = -123<br /><b>输出：</b>-321</p></blockquote><h4 id="示例-3">示例 3：</h4><blockquote><p><b>输入：</b>x = 120<br /><b>输出：</b>21</p></blockquote><h4 id="示例-4">示例 4：</h4><blockquote><p><b>输入：</b>x = 0<br /><b>输出：</b>0</p></blockquote><p>提示：</p><ul><li><span class="math inline">\({-2}^{31} &lt;= x &lt;={2}^{31}-1\)</span></li></ul><hr /><p>以下是题解：</p><h3 id="解题思路">解题思路:</h3><p>逆序可以通过对数字重复对10取余，除以10的步骤。本题难点在于不使用64位整数判断数据是否溢出。</p><p>这里直接引用LeetCode官方的解释：</p><p><a href="https://imgse.com/i/pPUwgx0"><imgsrc="https://s1.ax1x.com/2023/08/27/pPUwgx0.png"alt="pPUwgx0.png" /></a></p><p>代码如下： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rev &lt; INT_MIN / <span class="number">10</span> || rev &gt; INT_MAX / <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> digit = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            rev = rev * <span class="number">10</span> + digit;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPUwc2q"><imgsrc="https://s1.ax1x.com/2023/08/27/pPUwc2q.png"alt="pPUwc2q.png" /></a></p><h3id="这里补充一个我感觉很巧妙的一个方法">这里补充一个我感觉很“巧妙”的一个方法</h3><p>巧妙的利用了异常捕获</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        string s=<span class="built_in">to_string</span>(x);<span class="comment">//变成字符串</span></span><br><span class="line">        std::<span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());<span class="comment">//翻转字符串</span></span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ans=<span class="built_in">stoi</span>(s);<span class="comment">//变回数字</span></span><br><span class="line">            <span class="keyword">if</span> (x&lt;<span class="number">0</span>) ans=-ans;<span class="comment">//x是负数，加上负号</span></span><br><span class="line">        &#125;<span class="built_in">catch</span>(exception ex)&#123;&#125;<span class="comment">//溢出，啥也不做，返回零</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div style="text-align:right;"><p>本篇博客撰写于2023/8/27 19:31:56</p>]]></content>
    
    
    <summary type="html">整数反转</summary>
    
    
    
    <category term="程序" scheme="https://www.lwt-server.cn/categories/%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="LeetCode题解" scheme="https://www.lwt-server.cn/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解——6.N字形变换</title>
    <link href="https://www.lwt-server.cn/2023/08/27/LeetCode_6/"/>
    <id>https://www.lwt-server.cn/2023/08/27/LeetCode_6/</id>
    <published>2023-08-27T08:36:23.000Z</published>
    <updated>2023-08-27T09:04:31.188Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="n字形变换">N字形变换</h2><h3 id="题目预览">题目预览：</h3><p>将一个给定字符串 <span class="math inline">\(s\)</span>根据给定的行数 <span class="math inline">\(numRows\)</span>，以从上往下、从左到右进行 <span class="math inline">\(Z\)</span>字形排列。</p><p>比如输入字符串为 "PAYPALISHIRING" 行数为 3 时，排列如下：</p><table><thead><tr class="header"><th style="text-align: center;">P</th><th style="text-align: center;"></th><th style="text-align: center;">A</th><th style="text-align: center;"></th><th style="text-align: center;">H</th><th style="text-align: center;"></th><th style="text-align: center;">N</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">A</td><td style="text-align: center;">P</td><td style="text-align: center;">L</td><td style="text-align: center;">S</td><td style="text-align: center;">I</td><td style="text-align: center;">I</td><td style="text-align: center;">G</td></tr><tr class="even"><td style="text-align: center;">Y</td><td style="text-align: center;"></td><td style="text-align: center;">I</td><td style="text-align: center;"></td><td style="text-align: center;">R</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr></tbody></table><p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如："PAHNAPLSIIGYIR"。</p><p>请你实现这个将字符串进行指定行数变换的函数：</p><p>string convert(string s, int numRows);</p><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>s = "PAYPALISHIRING", numRows = 3<br /><b>输出：</b>"PAHNAPLSIIGYIR"</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>s = "PAYPALISHIRING", numRows = 4<br /><b>输出：</b>"PINALSIGYAHRPI"<br /><b>解释：</b></p></blockquote><table><thead><tr class="header"><th style="text-align: center;">P</th><th style="text-align: center;"></th><th style="text-align: center;"></th><th style="text-align: center;">I</th><th style="text-align: center;"></th><th style="text-align: center;"></th><th style="text-align: center;">N</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">A</td><td style="text-align: center;"></td><td style="text-align: center;">L</td><td style="text-align: center;">S</td><td style="text-align: center;"></td><td style="text-align: center;">I</td><td style="text-align: center;">G</td></tr><tr class="even"><td style="text-align: center;">Y</td><td style="text-align: center;">A</td><td style="text-align: center;"></td><td style="text-align: center;">H</td><td style="text-align: center;">R</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">P</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">I</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr></tbody></table><h4 id="示例-3">示例 3：</h4><blockquote><p><b>输入：</b>s = "A", numRows = 1 <b>输出：</b>"A"</p></blockquote><p>提示：</p><ul><li><span class="math inline">\(1 &lt;= s.length &lt;=1000\)</span></li><li><span class="math inline">\(s\)</span> 由英文字母（小写和大写）、','和 '.' 组成</li><li><span class="math inline">\(1 &lt;= numRows &lt;= 1000\)</span></li></ul><hr /><p>以下是题解：</p><h3 id="解题思路">解题思路:</h3><p>字符串 <span class="math inline">\(s\)</span> 是以 <spanclass="math inline">\(N\)</span>字形为顺序存储的字符串，目标是按行打印。</p><p>设 <span class="math inline">\(numRows\)</span> 行字符串分别为 <spanclass="math inline">\(s_1 , s_2 , … , s_n\)</span>则容易发现：按顺序遍历字符串 <span class="math inline">\(s\)</span>时,每个字符 <span class="math inline">\(c\)</span> 在 <spanclass="math inline">\(N\)</span> 字形中对应的 <b>行索引</b> 先从 <spanclass="math inline">\(s_1\)</span> 增大至 <spanclass="math inline">\(s_n\)</span> ,再从 <spanclass="math inline">\(s_n\)</span> 减小至 <spanclass="math inline">\(s_1 ……\)</span> 如此反复。</p><p>因此解决方案为：模拟这个行索引的变化，在遍历 <spanclass="math inline">\(s\)</span> 中把每个字符填到正确的行 <spanclass="math inline">\(res[i]\)</span> 。</p><h3 id="算法流程">算法流程：</h3><p>按顺序遍历字符串 <span class="math inline">\(s\)</span> ：</p><ul><li><p><span class="math inline">\(res[i] += c：\)</span> 把每个字符<span class="math inline">\(c\)</span> 填入对应行 <spanclass="math inline">\(s_i\)</span> ；</p></li><li><p><span class="math inline">\(i += flag：\)</span> 更新当前字符<span class="math inline">\(c\)</span> 对应的行索引；</p></li><li><p><span class="math inline">\(flag = - flag：\)</span> 在达到 <spanclass="math inline">\(N\)</span> 字形转折点时，执行反向。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">convert</span><span class="params">(string s, <span class="type">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numRows &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">rows</span><span class="params">(numRows)</span></span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, flag = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s) &#123;</span><br><span class="line">            rows[i].<span class="built_in">push_back</span>(c);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || i == numRows <span class="number">-1</span>)</span><br><span class="line">                flag = - flag;</span><br><span class="line">            i += flag;</span><br><span class="line">        &#125;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> string &amp;row : rows)</span><br><span class="line">            res += row;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPUJtmj"><imgsrc="https://s1.ax1x.com/2023/08/27/pPUJtmj.png"alt="pPUJtmj.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/27 16:36:23</p>]]></content>
    
    
    <summary type="html">N字形变换</summary>
    
    
    
    <category term="程序" scheme="https://www.lwt-server.cn/categories/%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="LeetCode题解" scheme="https://www.lwt-server.cn/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解——56.合并区间</title>
    <link href="https://www.lwt-server.cn/2023/08/27/LeetCode_56/"/>
    <id>https://www.lwt-server.cn/2023/08/27/LeetCode_56/</id>
    <published>2023-08-27T02:43:10.000Z</published>
    <updated>2023-08-29T05:07:33.450Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="合并区间">合并区间</h2><h3 id="题目预览">题目预览：</h3><p>以数组 <span class="math inline">\(intervals\)</span>表示若干个区间的集合，其中单个区间为 <spanclass="math inline">\(intervals[i] = [starti, endi]\)</span>。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>intervals = [[1,3],[2,6],[8,10],[15,18]]<br /><b>输出：</b>[[1,6],[8,10],[15,18]]<br /><b>解释：</b>区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]。</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>intervals = [[1,4],[4,5]]<br /><b>输出：</b>[[1,5]]<br /><b>解释：</b>区间 [1,4] 和 [4,5] 可被视为重叠区间。</p></blockquote><p>提示：</p><ul><li><span class="math inline">\(1 &lt;= intervals.length &lt;=10^4\)</span></li><li><span class="math inline">\(intervals[i].length == 2\)</span></li><li><span class="math inline">\(0 &lt;= start_i &lt;= end_i &lt;=10^4\)</span></li></ul><hr /><p>以下是题解：</p><h3 id="思路">思路:</h3><p>先按照起点升序排列，然后比较新的起点与原有的终点之间的关系：</p><ul><li><p>若新起点包含于原有终点，则原有终点=max(原有终点，新终点)</p></li><li><p>若新起点不包含于原有终点，则将当前范围压入ans容器，并令起点更新</p></li></ul><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="type">int</span> Len = <span class="number">0</span>, Head = <span class="number">-1</span>, Tail = <span class="number">-1</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        Len = intervals.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), [&amp;](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b)-&gt;<span class="type">bool</span> &#123; <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>]; &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((intervals[i])[<span class="number">0</span>] &gt; Tail)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (Tail != <span class="number">-1</span>)</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(&#123; Head,Tail &#125;);</span><br><span class="line">                Head = (intervals[i])[<span class="number">0</span>];</span><br><span class="line">                Tail = (intervals[i])[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Tail = <span class="built_in">max</span>(Tail, (intervals[i])[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(&#123; Head,Tail &#125;);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPUEOkd"><imgsrc="https://s1.ax1x.com/2023/08/27/pPUEOkd.png"alt="pPUEOkd.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/27 10:43:10</p>]]></content>
    
    
    <summary type="html">合并区间</summary>
    
    
    
    <category term="程序" scheme="https://www.lwt-server.cn/categories/%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="LeetCode题解" scheme="https://www.lwt-server.cn/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
    <category term="LeetCode每日一题" scheme="https://www.lwt-server.cn/tags/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解——228.汇总区间</title>
    <link href="https://www.lwt-server.cn/2023/08/26/LeetCode_228/"/>
    <id>https://www.lwt-server.cn/2023/08/26/LeetCode_228/</id>
    <published>2023-08-26T14:13:48.000Z</published>
    <updated>2023-08-29T05:10:54.918Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="汇总区间">汇总区间</h2><h3 id="题目预览">题目预览：</h3><p>给定一个 <b>无重复元素</b> 的 <b>有序</b> 整数数组 <spanclass="math inline">\(nums\)</span> 。</p><p>返回 <b>恰好覆盖数组中所有数字</b> 的 <b>最小有序</b> 区间范围列表。也就是说，<span class="math inline">\(nums\)</span>的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于<span class="math inline">\(nums\)</span> 的数字 <spanclass="math inline">\(x\)</span> 。</p><p>列表中的每个区间范围 <span class="math inline">\([a,b]\)</span>应该按如下格式输出：</p><ul><li>"a-&gt;b" ，如果 <span class="math inline">\(a != b\)</span></li><li>"a" ，如果 <span class="math inline">\(a == b\)</span></li></ul><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>nums = [0,1,2,4,5,7]<br /><b>输出：</b>["0-&gt;2","4-&gt;5","7"]<br /><b>解释：</b>区间范围是：<br />[0,2] --&gt; "0-&gt;2"<br />[4,5] --&gt; "4-&gt;5"<br />[7,7] --&gt; "7"</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>nums = [0,2,3,4,6,8,9]<br /><b>输出：</b>["0","2-&gt;4","6","8-&gt;9"]<br /><b>解释：</b>区间范围是：<br />[0,0] --&gt; "0"<br />[2,4] --&gt; "2-&gt;4"<br />[6,6] --&gt; "6"<br />[8,9] --&gt; "8-&gt;9"</p></blockquote><p>提示：</p><ul><li><span class="math inline">\(0 &lt;= nums.length &lt;=20\)</span><br /></li><li><span class="math inline">\(-2^{31} &lt;= nums[i] &lt;= 2^{31} -1\)</span><br /></li><li><span class="math inline">\(nums\)</span> 中的所有值都互不相同<br /></li><li><span class="math inline">\(nums\)</span> 按升序排列</li></ul><hr /><p>以下是题解：</p><h3 id="思路">思路:</h3><p>从头开始遍历，当遇到连续数字时使<spanclass="math inline">\(Len\)</span>增加，当遇到不同数字时根据<spanclass="math inline">\(Len\)</span>的值处理：<br />* <span class="math inline">\(Len==1：\)</span><br />不增加"-&gt;"，直接令<span class="math inline">\(Str\)</span>为该数字 *<span class="math inline">\(Len&gt;1：\)</span> 增加"-&gt;",令<spanclass="math inline">\(Str\)</span>为"X-&gt;Y"型</p><h4id="编写一个函数将整型转换成字符串">编写一个函数，将整型转换成字符串:</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">intToString</span><span class="params">(<span class="type">int</span> Num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Num == <span class="number">-2147483648</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;-2147483648&quot;</span>;</span><br><span class="line">    <span class="type">bool</span> Key = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (Num &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Num = -Num;</span><br><span class="line">        Key = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    string temp = <span class="string">&quot;&quot;</span>, ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (Key)</span><br><span class="line">        ans += <span class="string">&quot;-&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (Num / <span class="number">10</span> != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        temp += <span class="built_in">char</span>(Num % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        Num /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    temp += <span class="built_in">char</span>(Num + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="type">int</span> length = temp.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        ans += temp[length - i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完整代码">完整代码:</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt;ans;</span><br><span class="line">    <span class="function">string <span class="title">intToString</span><span class="params">(<span class="type">int</span> Num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Num == <span class="number">-2147483648</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;-2147483648&quot;</span>;</span><br><span class="line">        <span class="type">bool</span> Key = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (Num &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Num = -Num;</span><br><span class="line">            Key = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        string temp = <span class="string">&quot;&quot;</span>, ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (Key)</span><br><span class="line">            ans += <span class="string">&quot;-&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (Num / <span class="number">10</span> != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp += <span class="built_in">char</span>(Num % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            Num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp += <span class="built_in">char</span>(Num + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="type">int</span> length = temp.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">            ans += temp[length - i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">summaryRanges</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="type">int</span> Len = nums.<span class="built_in">size</span>(), Front = nums[<span class="number">0</span>], L = <span class="number">1</span>;</span><br><span class="line">        string Str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        Str += <span class="built_in">intToString</span>(Front);</span><br><span class="line">        <span class="keyword">if</span> (Len == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(Str);</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; Len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> tmp = nums[i];</span><br><span class="line">            <span class="keyword">if</span> (tmp != Front + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (L==<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                    Str += <span class="built_in">intToString</span>(Front);</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(Str);</span><br><span class="line">                    Str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                    Str += <span class="built_in">intToString</span>(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Str.<span class="built_in">append</span>(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">                    Str += <span class="built_in">intToString</span>(Front);</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(Str);</span><br><span class="line">                    Str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                    Str += <span class="built_in">intToString</span>(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">                L = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                L++;</span><br><span class="line">            &#125;</span><br><span class="line">            Front = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> temp = nums[Len - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (L != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Str.<span class="built_in">append</span>(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            Str += <span class="built_in">intToString</span>(Front);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(Str);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPNjlut"><imgsrc="https://s1.ax1x.com/2023/08/26/pPNjlut.png"alt="pPNjlut.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/26 22:13:48</p>]]></content>
    
    
    <summary type="html">汇总区间</summary>
    
    
    
    <category term="程序" scheme="https://www.lwt-server.cn/categories/%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="LeetCode题解" scheme="https://www.lwt-server.cn/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
    <category term="LeetCode每日一题" scheme="https://www.lwt-server.cn/tags/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解——5.最长回文子串</title>
    <link href="https://www.lwt-server.cn/2023/08/26/LeetCode_5/"/>
    <id>https://www.lwt-server.cn/2023/08/26/LeetCode_5/</id>
    <published>2023-08-26T09:31:18.000Z</published>
    <updated>2023-08-28T09:32:45.204Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="最长回文子串">最长回文子串</h2><h3 id="题目预览">题目预览：</h3><p>给你一个字符串 <span class="math inline">\(s\)</span>，找到 <spanclass="math inline">\(s\)</span> 中最长的回文子串。</p><p>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>s = "babad"<br /><b>输出：</b>"bab"<br /><b>解释：</b>"aba" 同样是符合题意的答案。</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>s = "cbbd"<br /><b>输出：</b>"bb"</p></blockquote><p>提示：</p><ul><li><span class="math inline">\(1 &lt;= s.length &lt;=1000\)</span></li><li><span class="math inline">\(s\)</span> 仅由数字和英文字母组成</li></ul><hr /><p>以下是题解：</p><h3 id="思路中心扩散">思路:中心扩散</h3><p>本题最容易想到的一种方法应该就是 <code>中心扩散法</code>。中心扩散法怎么去找回文串？从每一个位置出发，向两边扩散即可。遇到不是回文的时候结束。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//使用双指针法</span></span><br><span class="line">    <span class="type">int</span> maxLen=<span class="number">0</span>,begin=<span class="number">0</span>;<span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">extend</span><span class="params">(string &amp;s,<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;j&lt;n&amp;&amp;s[i]==s[j])&#123;<span class="comment">//只要符合条件便继续</span></span><br><span class="line">            <span class="keyword">if</span>(j-i+<span class="number">1</span>&gt;maxLen)&#123;<span class="comment">//至少要大于当前最大的那个子串才记录</span></span><br><span class="line">                maxLen=j-i+<span class="number">1</span>;</span><br><span class="line">                begin=i;         </span><br><span class="line">            &#125;</span><br><span class="line">            --i;<span class="comment">//注意在最后指针才移动</span></span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="built_in">extend</span>(s,i,i,s.<span class="built_in">size</span>());<span class="comment">//以一个元素向两端扩散</span></span><br><span class="line">            <span class="built_in">extend</span>(s,i,i+<span class="number">1</span>,s.<span class="built_in">size</span>());<span class="comment">//以两个元素为中心向两端扩散（因为每次只会向两端扩散一层，所以要分为两种情况）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(begin,maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPN28KA"><imgsrc="https://s1.ax1x.com/2023/08/26/pPN28KA.png"alt="pPN28KA.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/26 17:31:18</p>]]></content>
    
    
    <summary type="html">最长回文子串</summary>
    
    
    
    <category term="程序" scheme="https://www.lwt-server.cn/categories/%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="LeetCode题解" scheme="https://www.lwt-server.cn/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解——4.寻找两个正序数组的中位数</title>
    <link href="https://www.lwt-server.cn/2023/08/26/LeetCode_4/"/>
    <id>https://www.lwt-server.cn/2023/08/26/LeetCode_4/</id>
    <published>2023-08-26T04:35:43.000Z</published>
    <updated>2023-08-28T09:32:46.571Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="无重复字符的最长子串">无重复字符的最长子串</h2><h3 id="题目预览">题目预览：</h3><p>给定两个大小分别为 <span class="math inline">\(m\)</span> 和 <spanclass="math inline">\(n\)</span> 的正序（从小到大）数组 <spanclass="math inline">\(nums1\)</span> 和 <spanclass="math inline">\(nums2\)</span>。请你找出并返回这两个正序数组的中位数 。</p><p>算法的时间复杂度应该为 <span class="math inline">\(O(log(m+n))\)</span> 。</p><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>nums1 = [1,3], nums2 = [2]<br /><b>输出：</b>2.00000<br /><b>解释：</b>合并数组 = [1,2,3] ，中位数 2</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>nums1 = [1,2], nums2 = [3,4]<br /><b>输出：</b>2.50000<br /><b>解释：</b>合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5</p></blockquote><p>提示：</p><ul><li><span class="math inline">\(nums1.length == m\)</span></li><li><span class="math inline">\(nums2.length == n\)</span></li><li><span class="math inline">\(0 &lt;= m &lt;= 1000\)</span></li><li><span class="math inline">\(0 &lt;= n &lt;= 1000\)</span></li><li><span class="math inline">\(1 &lt;= m + n &lt;= 2000\)</span></li><li><span class="math inline">\(-10^6 &lt;= nums1[i], nums2[i] &lt;=10^6\)</span></li></ul><hr /><p>以下是题解：</p><h3 id="思路二分查找">思路:二分查找</h3><p>根据中位数的定义，当 <span class="math inline">\(m+n\)</span>是奇数时，中位数是两个有序数组中的第 <spanclass="math inline">\((m+n)/2\)</span> 个元素，当 <spanclass="math inline">\(m+n\)</span> 是偶数时，中位数是两个有序数组中的第<span class="math inline">\((m+n)/2\)</span> 个元素和第 <spanclass="math inline">\((m+n)/2+1\)</span>个元素的平均值。因此，这道题可以转化成寻找两个有序数组中的第 <spanclass="math inline">\(k\)</span> 小的数，其中 <spanclass="math inline">\(k\)</span> 为 <spanclass="math inline">\((m+n)/2\)</span> 或 <spanclass="math inline">\((m+n)/2+1\)</span>。</p><p>假设两个有序数组分别是 <span class="math inline">\(A\)</span> 和<span class="math inline">\(B\)</span>。要找到第 <spanclass="math inline">\(k\)</span> 个元素，我们可以比较 <spanclass="math inline">\(A[k/2−1]\)</span> 和 <spanclass="math inline">\(B[k/2−1]\)</span>，其中 / 表示整数除法。由于 <spanclass="math inline">\(A[k/2−1]\)</span> 和 <spanclass="math inline">\(B[k/2−1]\)</span> 的前面分别有 <spanclass="math inline">\(A[0 .. k/2−2]\)</span> 和 <spanclass="math inline">\(B[0 .. k/2−2]\)</span>，即 <spanclass="math inline">\(k/2−1\)</span> 个元素，对于 <spanclass="math inline">\(A[k/2−1]\)</span> 和 <spanclass="math inline">\(B[k/2−1]\)</span> 中的较小值，最多只会有 <spanclass="math inline">\((k/2−1)+(k/2−1)≤k−2\)</span>个元素比它小，那么它就不能是第 <span class="math inline">\(k\)</span>小的数了。</p><p>因此我们可以归纳出三种情况：</p><ul><li><p>如果 <spanclass="math inline">\(A[k/2−1]&lt;B[k/2−1]\)</span>，则比 <spanclass="math inline">\(A[k/2−1]\)</span> 小的数最多只有 <spanclass="math inline">\(A\)</span> 的前 <spanclass="math inline">\(k/2−1\)</span> 个数和 <spanclass="math inline">\(B\)</span> 的前 <spanclass="math inline">\(k/2−1\)</span> 个数，即比 <spanclass="math inline">\(A[k/2−1]\)</span> 小的数最多只有 <spanclass="math inline">\(k−2\)</span> 个，因此 <spanclass="math inline">\(A[k/2−1]\)</span> 不可能是第 <spanclass="math inline">\(k\)</span> 个数，<spanclass="math inline">\(A[0]\)</span> 到 <spanclass="math inline">\(A[k/2−1]\)</span> 也都不可能是第 <spanclass="math inline">\(k\)</span> 个数，可以全部排除。</p></li><li><p>如果 <spanclass="math inline">\(A[k/2−1]&gt;B[k/2−1]\)</span>，则可以排除 <spanclass="math inline">\(B[0]\)</span> 到 <spanclass="math inline">\(B[k/2−1]\)</span>。</p></li><li><p>如果 <spanclass="math inline">\(A[k/2−1]=B[k/2−1]\)</span>，则可以归入第一种情况处理。</p></li></ul><p><a href="https://imgse.com/i/pPNN4it"><imgsrc="https://s1.ax1x.com/2023/08/26/pPNN4it.png"alt="pPNN4it.png" /></a></p><p>可以看到，比较 <span class="math inline">\(A[k/2−1]\)</span> 和 <spanclass="math inline">\(B[k/2−1]\)</span> 之后，可以排除 <spanclass="math inline">\(k/2\)</span> 个不可能是第 <spanclass="math inline">\(k\)</span>小的数，查找范围缩小了一半。同时，我们将在排除后的新数组上继续进行二分查找，并且根据我们排除数的个数，减少<span class="math inline">\(k\)</span>的值，这是因为我们排除的数都不大于第 <spanclass="math inline">\(k\)</span> 小的数。</p><p>有以下三种情况需要特殊处理：</p><ul><li><p>如果 <span class="math inline">\(A[k/2−1]\)</span> 或者 <spanclass="math inline">\(B[k/2−1]\)</span>越界，那么我们可以选取对应数组中的最后一个元素。在这种情况下，我们必须根据排除数的个数减少<span class="math inline">\(k\)</span> 的值，而不能直接将 <spanclass="math inline">\(k\)</span> 减去 <spanclass="math inline">\(k/2\)</span>。</p></li><li><p>如果一个数组为空，说明该数组中的所有元素都被排除，我们可以直接返回另一个数组中第<span class="math inline">\(k\)</span> 小的元素。</p></li><li><p>如果 <spanclass="math inline">\(k=1\)</span>，我们只要返回两个数组首元素的最小值即可。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getKthElement</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> index1 = <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index1 == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums2[index2 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index2 == n) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums1[index1 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">min</span>(nums1[index1], nums2[index2]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> newIndex1 = <span class="built_in">min</span>(index1 + k / <span class="number">2</span> - <span class="number">1</span>, m - <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> newIndex2 = <span class="built_in">min</span>(index2 + k / <span class="number">2</span> - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> pivot1 = nums1[newIndex1];</span><br><span class="line">            <span class="type">int</span> pivot2 = nums2[newIndex2];</span><br><span class="line">            <span class="keyword">if</span> (pivot1 &lt;= pivot2) &#123;</span><br><span class="line">                k -= newIndex1 - index1 + <span class="number">1</span>;</span><br><span class="line">                index1 = newIndex1 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                k -= newIndex2 - index2 + <span class="number">1</span>;</span><br><span class="line">                index2 = newIndex2 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> totalLength = nums1.<span class="built_in">size</span>() + nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (totalLength % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getKthElement</span>(nums1, nums2, (totalLength + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">return</span> (<span class="built_in">getKthElement</span>(nums1, nums2, totalLength / <span class="number">2</span>) + <span class="built_in">getKthElement</span>(nums1, nums2, totalLength / <span class="number">2</span> + <span class="number">1</span>)) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPNNfII"><imgsrc="https://s1.ax1x.com/2023/08/26/pPNNfII.png"alt="pPNNfII.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/26 12:35:43</p>]]></content>
    
    
    <summary type="html">寻找两个正序数组的中位数</summary>
    
    
    
    <category term="程序" scheme="https://www.lwt-server.cn/categories/%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="LeetCode题解" scheme="https://www.lwt-server.cn/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解——3.无重复字符的最长子串</title>
    <link href="https://www.lwt-server.cn/2023/08/26/LeetCode_3/"/>
    <id>https://www.lwt-server.cn/2023/08/26/LeetCode_3/</id>
    <published>2023-08-26T02:42:24.000Z</published>
    <updated>2023-08-27T05:30:02.646Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="无重复字符的最长子串">无重复字符的最长子串</h2><h3 id="题目预览">题目预览：</h3><p>给定一个字符串 <span class="math inline">\(s\)</span>，请你找出其中不含有重复字符的 最长子串 的长度。</p><h4 id="示例1">示例1:</h4><blockquote><p><b>输入:</b> s = "abcabcbb"<br /><b>输出:</b> 3<br /><b>解释:</b> 因为无重复字符的最长子串是 "abc"，所以其长度为 3。</p></blockquote><h4 id="示例2">示例2</h4><blockquote><p><b>输入:</b> s = "bbbbb"<br /><b>输出:</b> 1<br /><b>解释:</b> 因为无重复字符的最长子串是 "b"，所以其长度为 1。</p></blockquote><h4 id="示例3">示例3</h4><blockquote><p><b>输入:</b> s = "pwwkew"<br /><b>输出:</b> 3<br /><b>解释:</b> 因为无重复字符的最长子串是 "wke"，所以其长度为 3。请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。</p></blockquote><p>提示：</p><ul><li><span class="math inline">\(0 &lt;= s.length &lt;= 5 ×10^4\)</span></li><li>s 由英文字母、数字、符号和空格组成</li></ul><hr /><p>以下是题解：</p><h3 id="思路">思路:</h3><p>定义两个变量<code>Start</code>=<code>End</code>=0，从头开始，定义一个哈希表储存每个字符的出现的个数，让<code>End</code>不断增加，记录字符直到出现重复字符，然后<code>Start</code>增加，同时记录排除的字符直到重新变成无重复字符的字串，然后重复<code>End</code>增加。当<code>End</code>到达字符串的尾部时停止，输出最长的无重复字串<br />代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> Start = <span class="number">0</span>, End = <span class="number">0</span>, Letter[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        Letter[s[<span class="number">0</span>]]++;</span><br><span class="line">        <span class="keyword">while</span> (End &lt; s.<span class="built_in">length</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Start == End)</span><br><span class="line">            &#123;</span><br><span class="line">                End++;</span><br><span class="line">                Letter[s[End]]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (End &lt; s.<span class="built_in">length</span>() &amp;&amp; Start &lt; End)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (Letter[s[End]] &lt;= <span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="type">int</span> tmp=End-Start+<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span>(ans &lt; tmp)</span><br><span class="line">                            ans = tmp;</span><br><span class="line">                        End++;</span><br><span class="line">                        Letter[s[End]]++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        Letter[s[Start]]--;</span><br><span class="line">                        Start++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPN1ntU"><imgsrc="https://s1.ax1x.com/2023/08/26/pPN1ntU.png"alt="pPN1ntU.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/26 10:42:24</p>]]></content>
    
    
    <summary type="html">无重复字符的最长子串</summary>
    
    
    
    <category term="程序" scheme="https://www.lwt-server.cn/categories/%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="LeetCode题解" scheme="https://www.lwt-server.cn/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解——2.两数相加</title>
    <link href="https://www.lwt-server.cn/2023/08/25/LeetCode_2/"/>
    <id>https://www.lwt-server.cn/2023/08/25/LeetCode_2/</id>
    <published>2023-08-25T07:16:28.000Z</published>
    <updated>2023-08-27T05:31:25.785Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="两数相加">两数相加</h2><h3 id="题目预览">题目预览：</h3><p>给你两个<b>非空</b>的链表，表示两个非负的整数。它们每位数字都是按照<b>逆序</b>的方式存储的，并且每个节点只能存储<b>一位</b>数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 <span class="math inline">\(0\)</span>之外，这两个数都不会以 <span class="math inline">\(0\)</span> 开头。</p><h4 id="示例1">示例1</h4><blockquote><p><b>输入</b>：l1 = [2,4,3], l2 = [5,6,4]<br /><b>输出</b>：[7,0,8]<br /><b>解释</b>：342 + 465 = 807</p></blockquote><h4 id="示例2">示例2</h4><blockquote><p><b>输入</b>：l1 = [0], l2 = [0]<br /><b>输出</b>：[0]</p></blockquote><h4 id="示例3">示例3</h4><blockquote><p><b>输入</b>：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]<br /><b>输出</b>：[8,9,9,9,0,0,0,1]</p></blockquote><p><b>提示：</b></p><ul><li>每个链表中的节点数在范围<span class="math inline">\([1,100]\)</span>内<br /></li><li><span class="math inline">\(0 &lt;= Node.val &lt;= 9\)</span></li><li>题目数据保证列表表示的数字不含前导零</li></ul><hr /><p>以下是题解：</p><h2 id="思路">思路:</h2><p>创建一个链表<code>ans</code>储存结果，对<code>l1</code>,<code>l2</code>依次逆序相加，同时用<code>cache</code>记录进位。<br />思路比较清晰，主要难点在于如何生成链表</p><h3 id="生成一个链表">生成一个链表：</h3><hr /><h4 id="创建链表的总体思路">创建链表的总体思路：</h4><ul><li>创建一个结构体或多个结构体，结构体里面包含数据域和指针域。</li><li>创建一个表头，可以是空表头，也可以是存放数据的表头。</li><li>创建一个节点，用来后续对链表进行增删改查等操作。</li><li>将各个功能模块化，封装成一个个函数。</li></ul><hr /><h4 id="创建结构体">创建结构体</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="comment">//可替换为任意类型+data</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span>* next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结构体中的data用来存放数据，next为另一结构体的地址，用于访问其中储存的数据内容。</p><hr /><h4 id="创建表头">创建表头</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">creatList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* headNode = <span class="keyword">new</span> Node;</span><br><span class="line">    <span class="comment">//变量使用前必须被初始化</span></span><br><span class="line">    headNode-&gt;data = <span class="number">1</span>; <span class="comment">//不包含该语句即创建空表头</span></span><br><span class="line">    headNode-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回表头地址</span></span><br><span class="line">    <span class="keyword">return</span> headNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h4 id="创建节点">创建节点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">creatNode</span><span class="params">(<span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* newNode = <span class="keyword">new</span> Node;</span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h4 id="链表的增加">链表的增加</h4><p><b>头插法：</b></p><p><a href="https://imgse.com/i/pPt5D1S"><imgsrc="https://s1.ax1x.com/2023/08/25/pPt5D1S.png"alt="pPt5D1S.png" /></a></p><p>根据上图我们可以看出，通过头插的方法插入的数据是逆序的，这点需要注意。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertNodeByHead</span><span class="params">(Node *headNode, <span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* newNode = <span class="built_in">creatNode</span>(data);</span><br><span class="line">    newNode-&gt;next = headNode-&gt;next;</span><br><span class="line">    headNode-&gt;next = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数是无返回值类型的，函数有两个参数，一个是头结点的地址，一个是需要写入的数据。</p><p>函数实现过程为：</p><ol type="1"><li>创建一个新节点并对数据域赋值。</li><li>将新节点的next指向头结点的next。</li><li>将头节点的next指向新节点。</li></ol><p><b>尾插法：</b></p><p><a href="https://imgse.com/i/pPt5fhV"><imgsrc="https://s1.ax1x.com/2023/08/25/pPt5fhV.png"alt="pPt5fhV.png" /></a></p><p>根据上图我们可以看出，通过尾插的方法插入的数据是正序的，这点正好和头插法相反，在数据输出时更方便，但是其具体实现代码与头插法相比会稍微复杂一点点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertNodeByTail</span><span class="params">(Node *headNode, <span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* newNode = <span class="built_in">creatNode</span>(data);</span><br><span class="line">    Node* tailNode = headNode;</span><br><span class="line">    <span class="keyword">while</span>(tailNode-&gt;next!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tailNode = tailNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    tailNode-&gt;next = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数是无返回值类型的，函数有两个参数，一个是头结点的地址，一个是需要写入的数据。</p><p>函数实现的过程为：</p><ol type="1"><li><p>找到表尾。</p></li><li><p>写入数据。</p></li></ol><p><b>指定位置插入(在去除表头的第<code>posData</code>位前增加)</b></p><p>函数插入数据过程：</p><ol type="1"><li><p>判断链表是否为空，为空则返回链表为空。</p></li><li><p>链表不为空：</p><ul><li>寻找目标位置，如果没找到，则返回数据不存在。</li><li>找到了目标，则写入数据。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertNodeByPos</span><span class="params">(Node *headNode, <span class="type">int</span> insertData, <span class="type">int</span> posData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* newNode = <span class="built_in">creatNode</span>(insertData);</span><br><span class="line">    Node* posNode = headNode;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(posNode-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;链表为空&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(num &lt; posData - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(posNode == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;数据越界&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            posNode = posNode-&gt;next;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        newNode-&gt;next = posNode-&gt;next;</span><br><span class="line">        posNode-&gt;next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数是无返回值类型的，函数有三个参数，一个是头结点的地址，一个是写入的数据，最后一个是目标位置的数据。</p><hr /><h4 id="链表的删除">链表的删除</h4><p>链表的删除即节点的删除，由于每个节点都是通过指针来实现连接的，所以我们只需要将被删除的节点的前驱节点和后继节点的指针域指向做适当的更改即可完成删除</p><p><a href="https://imgse.com/i/pPtIhVA"><imgsrc="https://s1.ax1x.com/2023/08/25/pPtIhVA.png"alt="pPtIhVA.png" /></a></p><p><b>表头删除</b></p><p>函数实现过程：</p><ol type="1"><li><p>找到头结点。</p></li><li><p>删除头结点。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteNodeByHead</span><span class="params">(Node* headNode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* deletNode = headNode-&gt;next;</span><br><span class="line">    headNode-&gt;next = deletNode-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> deletNode;</span><br><span class="line">    deletNode = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数是无返回值类型的，函数只有一个参数，即头结点的地址。</p><p><b>注：删除的表头是带数据的头结点，而不是整个链表的那个空表头。</b></p><p><b>表尾删除</b></p><p>函数的实现过程：</p><ol type="1"><li>创建一个尾节点，该尾节点初始指向头结点（表示从表头开始寻找）。<br /></li><li>创建一个尾节点的前驱节点，初始指向NULL。<br /></li><li>寻找尾节点。<br /></li><li>删除尾节点。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteNodeByTail</span><span class="params">(Node *headNode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* tailNode = headNode;</span><br><span class="line">    Node* tailNodeFront = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(headNode-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tailNodeFront = tailNode;</span><br><span class="line">        tailNode = tailNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    tailNodeFront-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">delete</span> tailNode;</span><br><span class="line">    tailNode = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数无返回值，有一个参数，即链表的头结点。</p><p><b>指定位置删除(删除去除表头的第<code>posData</code>位数据)</b></p><p>函数实现过程：</p><ol type="1"><li>判断链表是否为空，为空则结束。</li><li>不为空，则寻找目标数据。</li><li>找到目标数据后删除该节点。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteNodeByPos</span><span class="params">(Node* headNode, <span class="type">int</span> posData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* posNode = headNode-&gt;next;</span><br><span class="line">    Node* posNodeFront = headNode;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(posNode == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;无法删除，链表为空&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(num &lt; posData - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(posNode == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;数据越界&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            posNodeFront = posNode;</span><br><span class="line">            posNode = posNode-&gt;next;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        posNodeFront-&gt;next = posNode-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> posNode;</span><br><span class="line">        posNode = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数无返回值，有两个参数，一个是链表的头结点，一个的目标位置的数据。</p><hr /><h4 id="链表的修改">链表的修改</h4><p>函数的实现过程：</p><ol type="1"><li>判断链表是否为空，为空则结束。</li><li>不为空则寻找被修改的数据在链表中的位置。</li><li>没找到对应数据，则结束。</li><li>找到了，则把数据写入进去。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">changeNode</span><span class="params">(Node *headNode, <span class="type">int</span> changeData, <span class="type">int</span> posData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* posNode = headNode-&gt;next;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(posNode == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;无法删除，链表为空&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(num &lt; posData - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(posNode-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;数据越界&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            posNode = posNode-&gt;next;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        posNode-&gt;data = changeData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数是无返回值类型的额，有三个参数，一个是链表的表头，一个是写入的数据，最后一个是被修改的数据。</p><hr /><h4 id="链表的查询">链表的查询</h4><p>链表查询的实现其实和链表的修改差不多，在代码上会比链表的修改更简单，当我们找到目标数据后，根据需求返回相应的信息即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询并返回目标数据第一次出现的位置，不存在则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FindNode</span><span class="params">(Node *headNode, <span class="type">int</span> findData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* posNode = headNode-&gt;next;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(posNode == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;链表为空&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(posNode-&gt;data != findData)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(posNode-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;未找到该数据&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            posNode = posNode-&gt;next;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数返回目标数据第一次出现的位置，有两个参数，一个是链表的表头，一个是查询的数据。</p><hr /><h4 id="链表的打印">链表的打印</h4><p>链表的打印就是通过遍历将链表的中的数据一个一个输出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(Node *headNode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *p = headNode-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;p-&gt;data;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数是无返回值类型的，仅有一个参数，即需要打印的链表的表头。</p><hr /><h2 id="真正的题解">真正的题解：</h2><blockquote><p>正所谓“工欲善其事必先利其器”，在完成了链表的创建后，我们终于可以开始正式解题了！</p></blockquote><p>首先声明出操作链表的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">creatNode</span><span class="params">(<span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode* newNode = <span class="keyword">new</span> ListNode;</span><br><span class="line">    newNode-&gt;val = data;</span><br><span class="line">    newNode-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(ListNode* headNode, <span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode* newNode = <span class="built_in">creatNode</span>(data);</span><br><span class="line">    ListNode* tailNode = headNode;</span><br><span class="line">    <span class="keyword">while</span> (tailNode-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tailNode = tailNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    tailNode-&gt;next = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迫于题目的需求，我们这里要使用非空表头，对第一组数据特殊处理：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ListNode* ans;</span><br><span class="line"><span class="type">int</span> cache = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (l1-&gt;val + l2-&gt;val &gt;= <span class="number">10</span>)</span><br><span class="line">    cache = <span class="number">1</span>;</span><br><span class="line">ans = <span class="built_in">creatNode</span>(l1-&gt;val + l2-&gt;val - cache * <span class="number">10</span>);</span><br><span class="line">l1 = l1-&gt;next;</span><br><span class="line">l2 = l2-&gt;next;</span><br></pre></td></tr></table></figure><p>剩下的数据正常处理：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 != <span class="literal">nullptr</span> &amp;&amp; l2 != <span class="literal">nullptr</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//两链表均未用尽，相加并计算进位</span></span><br><span class="line">        <span class="type">int</span> sum = l1-&gt;val + l2-&gt;val + cache;</span><br><span class="line">        sum &gt;= <span class="number">10</span> ? cache = <span class="number">1</span>, sum -= <span class="number">10</span> : cache = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">push_back</span>(ans, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (l1 == <span class="literal">nullptr</span> &amp;&amp; l2 == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//两链表都用尽，若有进位则向后再输出一位，返回ans</span></span><br><span class="line">        <span class="keyword">if</span> (cache == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">push_back</span>(ans, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (l1 == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//l1尽l2未尽，计算进位并合并l2剩余部分</span></span><br><span class="line">        <span class="keyword">while</span> (l2 != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> num = l2-&gt;val + cache;</span><br><span class="line">            num &gt;= <span class="number">10</span> ? cache = <span class="number">1</span>, num -= <span class="number">10</span> : cache = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">push_back</span>(ans, num);</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cache == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">push_back</span>(ans, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//l2尽l1未尽，计算进位并合并l1剩余部分</span></span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> num = l1-&gt;val + cache;</span><br><span class="line">            num &gt;= <span class="number">10</span> ? cache = <span class="number">1</span>, num -= <span class="number">10</span> : cache = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">push_back</span>(ans, num);</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cache == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">push_back</span>(ans, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    l1 = l1-&gt;next;</span><br><span class="line">    l2 = l2-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPNCw4K"><imgsrc="https://s1.ax1x.com/2023/08/25/pPNCw4K.png"alt="pPNCw4K.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/25 15:16:28</p>]]></content>
    
    
    <summary type="html">两数相加</summary>
    
    
    
    <category term="程序" scheme="https://www.lwt-server.cn/categories/%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="LeetCode题解" scheme="https://www.lwt-server.cn/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解——1.两数之和</title>
    <link href="https://www.lwt-server.cn/2023/08/24/LeetCode_1/"/>
    <id>https://www.lwt-server.cn/2023/08/24/LeetCode_1/</id>
    <published>2023-08-24T15:05:26.000Z</published>
    <updated>2023-08-26T09:36:32.470Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="两数之和">两数之和</h2><h3 id="题目预览">题目预览：</h3><p>给定一个整数数组 <span class="math inline">\(nums\)</span>和一个整数目标值 <span class="math inline">\(target\)</span>，请你在该数组中找出和为目标值 <spanclass="math inline">\(target\)</span>的那两个整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><h4 id="示例1">示例1</h4><blockquote><p><b>输入</b>：nums = [2,7,11,15], target = 9<br /><b>输出</b>：[0,1]<br /><b>解释</b>：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</p></blockquote><h4 id="示例2">示例2</h4><blockquote><p><b>输入</b>：nums = [3,2,4], target = 6<br /><b>输出</b>：[1,2]</p></blockquote><h4 id="示例3">示例3</h4><blockquote><p><b>输入</b>：nums = [3,3], target = 6<br /><b>输出</b>：[0,1]</p></blockquote><p><b>提示</b>： * <span class="math inline">\(2\)</span> &lt;=nums.length &lt;= <span class="math inline">\({10}^{4}\)</span> * <spanclass="math inline">\({-10}^{9}\)</span> &lt;= nums[i] &lt;= <spanclass="math inline">\({10}^{9}\)</span> * <spanclass="math inline">\({-10}^{9}\)</span> &lt;= target &lt;= <spanclass="math inline">\({10}^{9}\)</span> * 只会存在一个有效答案</p><p><b>进阶</b>：你可以想出一个时间复杂度小于<spanclass="math inline">\(O({n}^{2})\)</span>的算法吗？</p><hr /><p>以下是题解：</p><h3 id="思路一">思路一：</h3><p>大力出奇迹——嵌套for循环<br />#### 优点: 1. 思路清晰 2. 空间复杂度低至<spanclass="math inline">\(O(1)\)</span></p><h4 id="缺点">缺点:</h4><ol type="1"><li>时间复杂度高达<span class="math inline">\(O({n}^{2})\)</span></li></ol><h4 id="思路简析">思路简析：</h4><p>两层for循环，一层控制一个数，从前往后搜，直到查找到相加为<code>target</code>的两数为止<br />代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;nums.<span class="built_in">size</span>();j++)</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]==target)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(j);</span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPtUn3T"><imgsrc="https://s1.ax1x.com/2023/08/25/pPtUn3T.png"alt="pPtUn3T.png" /></a></p><h3 id="思路一升级版">思路一(升级版)：</h3><p>快速排序+二分查找 #### 优点: 1. 对时间复杂度进行了优化，实现了<spanclass="math inline">\(O(nlogn)\)</span>的时间复杂度</p><h4 id="缺点-1">缺点:</h4><ol type="1"><li>与原思路一相比，过程更复杂</li><li>牺牲空间换时间，需要一个结构体容器储存下标，空间复杂度为<spanclass="math inline">\(O(n)\)</span></li></ol><h3 id="历程">历程：</h3><h4 id="第一版">第一版</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="type">int</span> Len=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//快排部分</span></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>())</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//计算要查找的数</span></span><br><span class="line">            <span class="type">int</span> Num = target - nums[i];</span><br><span class="line">            <span class="comment">//二分查找</span></span><br><span class="line">            <span class="type">int</span> Low = i + <span class="number">1</span>, High = Len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (Low &lt;= High)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> Middle = (High + Low) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (nums[Middle] == Num)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(Middle);</span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (Num &lt; nums[Middle])</span><br><span class="line">                    High = Middle - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    Low = Middle + <span class="number">1</span>;</span><br><span class="line">            &#125;                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试发现致命问题——排序后数组下标发生了改变，输出的答案是排序后的下标。于是加入结构体，同时修改<code>sort</code>排序的逻辑：</p><h4 id="第二版">第二版</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">+   <span class="keyword">struct</span> <span class="title class_">Num</span> &#123;</span><br><span class="line">+       <span class="type">int</span> Value;</span><br><span class="line">+       <span class="type">int</span> id;</span><br><span class="line">+       <span class="built_in">Num</span>(<span class="type">int</span> Value,<span class="type">int</span> id): <span class="built_in">Value</span>(Value),<span class="built_in">id</span>(id) &#123;&#125;;</span><br><span class="line">+   &#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">+       vector&lt;Num&gt; temp;</span><br><span class="line">        <span class="type">int</span> Len=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Len;i++)</span><br><span class="line">            temp.<span class="built_in">push_back</span>(<span class="built_in">Num</span>(nums[i],i));</span><br><span class="line">+       <span class="built_in">sort</span>(temp.<span class="built_in">begin</span>(),temp.<span class="built_in">end</span>(),[&amp;](<span class="type">const</span> Num&amp;a,<span class="type">const</span> Num&amp;b)-&gt;<span class="type">bool</span>&#123;</span><br><span class="line">+           <span class="keyword">return</span> a.Value&lt;b.Value;</span><br><span class="line">+       &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> Num = target - temp[i].Value;</span><br><span class="line">            <span class="type">int</span> Low = i + <span class="number">1</span>, High = Len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (Low &lt;= High)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> Middle = (High + Low) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (temp[Middle].Value == Num)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(temp[i].id);</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(temp[Middle].id);</span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (Num &lt; temp[Middle].Value)</span><br><span class="line">                    High = Middle - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    Low = Middle + <span class="number">1</span>;</span><br><span class="line">            &#125;                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结果-1">结果</h4><p><a href="https://imgse.com/i/pPtUmCV"><imgsrc="https://s1.ax1x.com/2023/08/25/pPtUmCV.png"alt="pPtUmCV.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/24 23:05:26</p>]]></content>
    
    
    <summary type="html">两数之和</summary>
    
    
    
    <category term="程序" scheme="https://www.lwt-server.cn/categories/%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="LeetCode题解" scheme="https://www.lwt-server.cn/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
</feed>
