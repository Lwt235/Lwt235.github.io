<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lwt&#39;s Blog</title>
  
  
  <link href="https://www.lwt-server.cn/atom.xml" rel="self"/>
  
  <link href="https://www.lwt-server.cn/"/>
  <updated>2023-09-03T11:40:10.407Z</updated>
  <id>https://www.lwt-server.cn/</id>
  
  <author>
    <name>Lwt</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode题解——33.搜索旋转排序数组</title>
    <link href="https://www.lwt-server.cn/2023/09/03/LeetCode_33/"/>
    <id>https://www.lwt-server.cn/2023/09/03/LeetCode_33/</id>
    <published>2023-09-03T11:29:39.000Z</published>
    <updated>2023-09-03T11:40:10.407Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="搜索旋转排序数组">搜索旋转排序数组</h2><h3 id="题目预览">题目预览：</h3><p>整数数组 <span class="math inline">\(nums\)</span>按升序排列，数组中的值 <b>互不相同</b> 。</p><p>在传递给函数之前，<span class="math inline">\(nums\)</span>在预先未知的某个下标 <span class="math inline">\(k\)</span>（<spanclass="math inline">\(0 &lt;= k &lt; nums.length\)</span>）上进行了<b>旋转</b>，使数组变为 <span class="math inline">\([nums[k], nums[k+1],..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]\)</span>（下标 <b>从<span class="math inline">\(0\)</span> 开始</b> 计数）。例如， <spanclass="math inline">\([0,1,2,4,5,6,7]\)</span> 在下标 <spanclass="math inline">\(3\)</span> 处经旋转后可能变为 <spanclass="math inline">\([4,5,6,7,0,1,2]\)</span> 。</p><p>给你 <b>旋转后</b> 的数组 <b>nums</b> 和一个整数 <b>target</b> ，如果<b>nums</b> 中存在这个目标值 <b>target</b> ，则返回它的下标，否则返回<span class="math inline">\(-1\)</span> 。</p><p>你必须设计一个时间复杂度为 <span class="math inline">\(O(logn)\)</span> 的算法解决此问题。</p><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>nums = [4,5,6,7,0,1,2], target = 0<br /><b>输出：</b>4</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>nums = [4,5,6,7,0,1,2], target = 3<br /><b>输出：</b>-1</p></blockquote><h4 id="示例-3">示例 3：</h4><blockquote><p><b>输入：</b>nums = [1], target = 0<br /><b>输出：</b>-1</p></blockquote><p>提示：</p><ul><li><p><span class="math inline">\(1 &lt;= nums.length &lt;=5000\)</span></p></li><li><p><span class="math inline">\(-10^4 &lt;= nums[i] &lt;=10^4\)</span></p></li><li><p><span class="math inline">\(nums\)</span> 中的每个值都<b>独一无二</b></p></li><li><p>题目数据保证 <span class="math inline">\(nums\)</span>在预先未知的某个下标上进行了旋转</p></li><li><p><span class="math inline">\(-10^4 &lt;= target &lt;=10^4\)</span></p></li></ul><hr /><p>以下是题解：</p><h3 id="解题思路">解题思路：</h3><p>拿到题，嗯，搜索，嗯，<span class="math inline">\(O(logn)\)</span>，直接联想到 <b>二分查找</b>这里难点在于如何抛弃无用的部分。我们可以发现数组一定可以以mid为分界线，分成有序和无序的两部分。我们只需比较<span class="math inline">\(target\)</span> 是否位于 <b>有序的那部分</b>的范围内即可判断出下次搜索的搜索区间</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> Len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(Len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(Len == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>] == target ? <span class="number">0</span> : <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> Left = <span class="number">0</span>, Right = Len - <span class="number">1</span>, Middle = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (Left &lt;= Right)</span><br><span class="line">        &#123;</span><br><span class="line">            Middle = (Left + Right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[Middle] == target)</span><br><span class="line">                <span class="keyword">return</span> Middle;</span><br><span class="line">            <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt;= nums[Middle])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (target &gt;= nums[<span class="number">0</span>] &amp;&amp; target &lt; nums[Middle])</span><br><span class="line">                    Right = Middle - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    Left = Middle + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (target &gt; nums[Middle] &amp;&amp; target &lt;= nums[Len - <span class="number">1</span>])</span><br><span class="line">                    Left = Middle + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    Right = Middle - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPDdEHP"><imgsrc="https://s1.ax1x.com/2023/09/03/pPDdEHP.png"alt="pPDdEHP.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/9/3 19:29:39</p>]]></content>
    
    
    <summary type="html">搜索旋转排序数组</summary>
    
    
    
    <category term="程序" scheme="https://www.lwt-server.cn/categories/%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="LeetCode题解" scheme="https://www.lwt-server.cn/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解——32.最长有效括号</title>
    <link href="https://www.lwt-server.cn/2023/09/03/LeetCode_32/"/>
    <id>https://www.lwt-server.cn/2023/09/03/LeetCode_32/</id>
    <published>2023-09-03T08:30:44.000Z</published>
    <updated>2023-09-03T08:36:52.584Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="最长有效括号">最长有效括号</h2><h3 id="题目预览">题目预览：</h3><p>给你一个只包含 '(' 和 ')'的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><h4 id="示例-1">示例 1：</h4><p><b>输入：</b>s = "(()" <b>输出：</b>2 <b>解释：</b>最长有效括号子串是"()"</p><h4 id="示例-2">示例 2：</h4><p><b>输入：</b>s = ")()())" <b>输出：</b>4<b>解释：</b>最长有效括号子串是 "()()"</p><h4 id="示例-3">示例 3：</h4><p><b>输入：</b>s = "" <b>输出：</b>0</p><p>提示：</p><ul><li><p><span class="math inline">\(0 &lt;= s.length &lt;= 3 ×10^4\)</span></p></li><li><p><span class="math inline">\(s[i]\)</span> 为 <code>'('</code> 或<code>')'</code></p></li></ul><hr /><p>以下是题解：</p><h3 id="解题思路">解题思路：</h3><p>考虑使用两个计数器风别从前后从后遍历整个字符串，当 <spanclass="math inline">\(left==right\)</span>时，记录当前字符串，当从前遍历且 <spanclass="math inline">\(left&lt;right\)</span> 时令 <spanclass="math inline">\(left=right=0\)</span>，当从后遍历且 <spanclass="math inline">\(left&gt;right\)</span> 时令 <spanclass="math inline">\(left=right=0\)</span> 。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestValidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, Len = s.<span class="built_in">length</span>(), tag = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(tag&lt;Len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[tag] == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">                right++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left++;</span><br><span class="line">            <span class="keyword">if</span>(left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                left = <span class="number">0</span>;</span><br><span class="line">                right = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(left == right)</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, <span class="number">2</span> * right);</span><br><span class="line">            tag++;</span><br><span class="line">        &#125;</span><br><span class="line">        left = <span class="number">0</span>;</span><br><span class="line">        right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(tag&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[tag] == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">                right++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left++;</span><br><span class="line">            <span class="keyword">if</span>(left &gt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                left = <span class="number">0</span>;</span><br><span class="line">                right = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(left == right)</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, <span class="number">2</span> * left);</span><br><span class="line">            tag--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPDJC11"><imgsrc="https://s1.ax1x.com/2023/09/03/pPDJC11.png"alt="pPDJC11.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/9/3 16:30:44</p>]]></content>
    
    
    <summary type="html">最长有效括号</summary>
    
    
    
    <category term="程序" scheme="https://www.lwt-server.cn/categories/%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="LeetCode题解" scheme="https://www.lwt-server.cn/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解——1921.消灭怪物的最大数量</title>
    <link href="https://www.lwt-server.cn/2023/09/03/LeetCode_1921/"/>
    <id>https://www.lwt-server.cn/2023/09/03/LeetCode_1921/</id>
    <published>2023-09-03T05:27:22.000Z</published>
    <updated>2023-09-03T06:55:45.826Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="消灭怪物的最大数量">消灭怪物的最大数量</h2><h3 id="题目预览">题目预览：</h3><p>你正在玩一款电子游戏，在游戏中你需要保护城市免受怪物侵袭。给你一个<b>下标从 <span class="math inline">\(0\)</span> 开始</b> 且长度为 <spanclass="math inline">\(n\)</span> 的整数数组 <spanclass="math inline">\(dist\)</span> ，其中 <spanclass="math inline">\(dist[i]\)</span> 是第 <spanclass="math inline">\(i\)</span> 个怪物与城市的<b>初始距离</b>（单位：米）。</p><p>怪物以 <b>恒定</b> 的速度走向城市。给你一个长度为 <spanclass="math inline">\(n\)</span> 的整数数组 <spanclass="math inline">\(speed\)</span> 表示每个怪物的速度，其中 <spanclass="math inline">\(speed[i]\)</span> 是第 <spanclass="math inline">\(i\)</span> 个怪物的速度（单位：米/分）。</p><p>怪物从 第 <span class="math inline">\(0\)</span> 分钟时开始移动。你有一把武器，并可以 <b>选择</b>在每一分钟的开始时使用，包括第 <b>0</b>分钟。但是你无法在一分钟的中间使用武器。这种武器威力惊人，一次可以消灭任一还活着的怪物。</p><p>一旦任一怪物到达城市，你就输掉了这场游戏。如果某个怪物 <b>恰</b>在某一分钟开始时到达城市，这会被视为 <b>输掉</b>游戏，在你可以使用武器之前，游戏就会结束。</p><p>返回在你输掉游戏前可以消灭的怪物的 <b>最大</b>数量。如果你可以在所有怪物到达城市前将它们全部消灭，返回 <spanclass="math inline">\(n\)</span> 。</p><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>dist = [1,3,4], speed = [1,1,1]<br /><b>输出：</b>3<br /><b>解释：</b><br />第 0 分钟开始时，怪物的距离是 [1,3,4]，你消灭了第一个怪物。<br />第 1 分钟开始时，怪物的距离是 [X,2,3]，你没有消灭任何怪物。<br />第 2 分钟开始时，怪物的距离是 [X,1,2]，你消灭了第二个怪物。<br />第 3 分钟开始时，怪物的距离是 [X,X,1]，你消灭了第三个怪物。<br />所有 3 个怪物都可以被消灭。</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>dist = [1,1,2,3], speed = [1,1,1,1]<br /><b>输出：</b>1<br /><b>解释：</b><br />第 0 分钟开始时，怪物的距离是 [1,1,2,3]，你消灭了第一个怪物。<br />第 1 分钟开始时，怪物的距离是 [X,0,1,2]，你输掉了游戏。<br />你只能消灭 1 个怪物。</p></blockquote><h4 id="示例-3">示例 3：</h4><blockquote><p><b>输入：</b>dist = [3,2,4], speed = [5,3,2]<br /><b>输出：</b>1<br /><b>解释：</b><br />第 0 分钟开始时，怪物的距离是 [3,2,4]，你消灭了第一个怪物。<br />第 1 分钟开始时，怪物的距离是 [X,0,2]，你输掉了游戏。<br />你只能消灭 1 个怪物。</p></blockquote><p>提示：</p><ul><li><span class="math inline">\(n == dist.length ==speed.length\)</span></li><li><span class="math inline">\(1 &lt;= n &lt;= 10^5\)</span></li><li><span class="math inline">\(1 &lt;= dist[i], speed[i] &lt;=10^5\)</span></li></ul><hr /><p>以下是题解：</p><h3 id="解题思路">解题思路：</h3><p>使用贪心算法，我们分别计算出每一个怪兽到达城市所需的时间，排序后从小到大消灭。将我方的攻击时间序列和排序后的怪物到达时间依次进行比较，当第一次出现到达时间小于等于攻击时间，即表示怪物到达城市，我方会输掉游戏。在比较时，因为我方的攻击时间为整数，因此可以将怪物到达时间向上取整，可以达到避免浮点数误差的效果。如果遍历完序列都没有出现这种情况，则表示我方可以消灭全部怪物。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">eliminateMaximum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; dist, vector&lt;<span class="type">int</span>&gt;&amp; speed)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = dist.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arrivalTimes</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            arrivalTimes[i] = (dist[i] - <span class="number">1</span>) / speed[i] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(arrivalTimes.<span class="built_in">begin</span>(), arrivalTimes.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arrivalTimes[i] &lt;= i) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPDQxDe"><imgsrc="https://s1.ax1x.com/2023/09/03/pPDQxDe.png"alt="pPDQxDe.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/9/3 13:27:22</p>]]></content>
    
    
    <summary type="html">消灭怪物的最大数量</summary>
    
    
    
    <category term="程序" scheme="https://www.lwt-server.cn/categories/%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="LeetCode题解" scheme="https://www.lwt-server.cn/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
    <category term="LeetCode每日一题" scheme="https://www.lwt-server.cn/tags/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第112场双周赛</title>
    <link href="https://www.lwt-server.cn/2023/09/03/LeetCode_DoubleWeekCompetition_112/"/>
    <id>https://www.lwt-server.cn/2023/09/03/LeetCode_DoubleWeekCompetition_112/</id>
    <published>2023-09-03T01:33:40.000Z</published>
    <updated>2023-09-03T06:59:23.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="a">A</h1><h2 id="判断通过操作能否让字符串相等-i">判断通过操作能否让字符串相等I</h2><h3 id="题目预览">题目预览：</h3><p>给你两个字符串 <span class="math inline">\(s1\)</span> 和 <spanclass="math inline">\(s2\)</span> ，两个字符串的长度都为 <spanclass="math inline">\(4\)</span> ，且只包含 <b>小写</b> 英文字母。</p><p>你可以对两个字符串中的 <b>任意一个</b> 执行以下操作 <b>任意</b>次：</p><ul><li>选择两个下标 <span class="math inline">\(i\)</span> 和 <spanclass="math inline">\(j\)</span> 且满足 <span class="math inline">\(j -i = 2\)</span> ，然后 <b>交换</b> 这个字符串中两个下标对应的字符。如果你可以让字符串 <span class="math inline">\(s1\)</span> 和 <spanclass="math inline">\(s2\)</span> 相等，那么返回 <spanclass="math inline">\(true\)</span> ，否则返回 <spanclass="math inline">\(false\)</span> 。</li></ul><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>s1 = "abcd", s2 = "cdab"<br /><b>输出：</b>true<br /><b>解释：</b> 我们可以对 s1 执行以下操作：<br />- 选择下标 i = 0 ，j = 2 ，得到字符串 s1 = "cbad" 。<br />- 选择下标 i = 1 ，j = 3 ，得到字符串 s1 = "cdab" = s2 。</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>s1 = "abcd", s2 = "dacb" <b>输出：</b>false<b>解释：</b>无法让两个字符串相等。</p></blockquote><p>提示：</p><ul><li><p><span class="math inline">\(s1.length == s2.length ==4\)</span></p></li><li><p><span class="math inline">\(s1\)</span> 和 <spanclass="math inline">\(s2\)</span> 只包含小写英文字母。</p></li></ul><h4 id="思路">思路</h4><p>题目都特殊到这份上了，这还不投机取巧？？？</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canBeEqual</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1[<span class="number">0</span>]==s2[<span class="number">0</span>]&amp;&amp;s1[<span class="number">1</span>]==s2[<span class="number">1</span>]&amp;&amp;s1[<span class="number">2</span>]==s2[<span class="number">2</span>]&amp;&amp;s1[<span class="number">3</span>]==s2[<span class="number">3</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s1[<span class="number">0</span>]==s2[<span class="number">2</span>]&amp;&amp;s1[<span class="number">1</span>]==s2[<span class="number">1</span>]&amp;&amp;s1[<span class="number">2</span>]==s2[<span class="number">0</span>]&amp;&amp;s1[<span class="number">3</span>]==s2[<span class="number">3</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s1[<span class="number">0</span>]==s2[<span class="number">0</span>]&amp;&amp;s1[<span class="number">1</span>]==s2[<span class="number">3</span>]&amp;&amp;s1[<span class="number">2</span>]==s2[<span class="number">2</span>]&amp;&amp;s1[<span class="number">3</span>]==s2[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s1[<span class="number">0</span>]==s2[<span class="number">2</span>]&amp;&amp;s1[<span class="number">1</span>]==s2[<span class="number">3</span>]&amp;&amp;s1[<span class="number">2</span>]==s2[<span class="number">0</span>]&amp;&amp;s1[<span class="number">3</span>]==s2[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="b">B</h1><h2 id="判断通过操作能否让字符串相等-ii">判断通过操作能否让字符串相等II</h2><h3 id="题目预览-1">题目预览：</h3><p>给你两个字符串 <span class="math inline">\(s1\)</span> 和 <spanclass="math inline">\(s2\)</span> ，两个字符串长度都为 <spanclass="math inline">\(n\)</span> ，且只包含 <b>小写</b> 英文字母。</p><p>你可以对两个字符串中的 <b>任意一个</b> 执行以下操作 <b>任意</b>次：</p><p>选择两个下标 <span class="math inline">\(i\)</span> 和 <spanclass="math inline">\(j\)</span> ，满足 <span class="math inline">\(i&lt; j\)</span> 且 <span class="math inline">\(j - i\)</span> 是<b>偶数</b> ，然后 <b>交换</b> 这个字符串中两个下标对应的字符。</p><p>如果你可以让字符串 <span class="math inline">\(s1\)</span> 和 <spanclass="math inline">\(s2\)</span> 相等，那么返回 <spanclass="math inline">\(true\)</span> ，否则返回 <spanclass="math inline">\(false\)</span> 。</p><h4 id="示例-1-1">示例 1：</h4><blockquote><p><b>输入：</b>s1 = "abcdba", s2 = "cabdab"<br /><b>输出：</b>true<br /><b>解释：</b>我们可以对 s1 执行以下操作：<br />- 选择下标 i = 0 ，j = 2 ，得到字符串 s1 = "cbadba" 。<br />- 选择下标 i = 2 ，j = 4 ，得到字符串 s1 = "cbbdaa" 。<br />- 选择下标 i = 1 ，j = 5 ，得到字符串 s1 = "cabdab" = s2 。</p></blockquote><h4 id="示例-2-1">示例 2：</h4><blockquote><p><b>输入：</b>s1 = "abe", s2 = "bea"<br /><b>输出：</b>false<br /><b>解释：</b>无法让两个字符串相等。</p></blockquote><p>提示：</p><ul><li><p><span class="math inline">\(n == s1.length ==s2.length\)</span></p></li><li><p><span class="math inline">\(1 &lt;= n &lt;=10^5\)</span></p></li><li><p><span class="math inline">\(s1\)</span> 和 <spanclass="math inline">\(s2\)</span> 只包含小写英文字母。</p></li></ul><h4 id="思路-1">思路</h4><p>对于原有两个字符串，我们将其分别按照奇数与偶数分为四个字串，排序后两两比较，相等则可以通过操作使两个字串相同。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkStrings</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        string a1=<span class="string">&quot;&quot;</span>,b1=<span class="string">&quot;&quot;</span>,a2=<span class="string">&quot;&quot;</span>,b2=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> Len = s1.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&amp;<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                a1+=s1[i];</span><br><span class="line">                a2+=s2[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                b1+=s1[i];</span><br><span class="line">                b2+=s2[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(a1.<span class="built_in">begin</span>(),a1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(a2.<span class="built_in">begin</span>(),a2.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(b1.<span class="built_in">begin</span>(),b1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(b2.<span class="built_in">begin</span>(),b2.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span>(a1==a2&amp;&amp;b1==b2)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="c">C</h1><h2 id="几乎唯一子数组的最大和">几乎唯一子数组的最大和</h2><h3 id="题目预览-2">题目预览：</h3><p>给你一个整数数组 <span class="math inline">\(nums\)</span>和两个正整数 <span class="math inline">\(m\)</span> 和 <spanclass="math inline">\(k\)</span> 。</p><p>请你返回 <span class="math inline">\(nums\)</span> 中长度为 <spanclass="math inline">\(k\)</span> 的 <b>几乎唯一</b> 子数组的<b>最大和</b> ，如果不存在几乎唯一子数组，请你返回 <spanclass="math inline">\(0\)</span> 。</p><p>如果 <span class="math inline">\(nums\)</span> 的一个子数组有至少<span class="math inline">\(m\)</span> 个互不相同的元素，我们称它是<b>几乎唯一</b> 子数组。</p><p>子数组指的是一个数组中一段连续 <b>非空</b> 的元素序列。</p><h4 id="示例-1-2">示例 1：</h4><p><b>输入：</b>nums = [2,6,7,3,1,7], m = 3, k = 4<br /><b>输出：</b>18<br /><b>解释：</b>总共有 3 个长度为 k = 4 的几乎唯一子数组。分别为 [2, 6, 7,3] ，[6, 7, 3, 1] 和 [7, 3, 1, 7] 。这些子数组中，和最大的是 [2, 6, 7,3] ，和为 18 。</p><h4 id="示例-2-2">示例 2：</h4><p><b>输入：</b>nums = [5,9,9,2,4,5,4], m = 1, k = 3<br /><b>输出：</b>23<br /><b>解释：</b>总共有 5 个长度为 k = 3 的几乎唯一子数组。分别为 [5, 9, 9]，[9, 9, 2] ，[9, 2, 4] ，[2, 4, 5] 和 [4, 5, 4]。这些子数组中，和最大的是 [5, 9, 9] ，和为 23 。</p><h4 id="示例-3">示例 3：</h4><p><b>输入：</b>nums = [1,2,1,2,1,2,1], m = 3, k = 3<br /><b>输出：</b>0<br /><b>解释：</b>输入数组中不存在长度为 k = 3 的子数组含有至少 m = 3个互不相同元素的子数组。所以不存在几乎唯一子数组，最大和为 0 。</p><p>提示：</p><ul><li><p><span class="math inline">\(1 &lt;= nums.length &lt;= 2 ×10^4\)</span></p></li><li><p><span class="math inline">\(1 &lt;= m &lt;= k &lt;=nums.length\)</span></p></li><li><p><span class="math inline">\(1 &lt;= nums[i] &lt;=10^9\)</span></p></li></ul><h4 id="思路-2">思路</h4><p>滑动窗口+哈希表</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">maxSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> m, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> Len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>, plus = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> Left = <span class="number">0</span>, Right = k - <span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            plus += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (map.<span class="built_in">count</span>(nums[i]))</span><br><span class="line">                map[nums[i]]++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                map[nums[i]] = <span class="number">1</span>;</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (Right &lt; Len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt;= m)</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, plus);</span><br><span class="line"></span><br><span class="line">            plus -= nums[Left];</span><br><span class="line">            <span class="keyword">if</span> (map[nums[Left]] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                map.<span class="built_in">erase</span>(nums[Left]);</span><br><span class="line">                sum--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                map[nums[Left]]--;</span><br><span class="line">            Left++;</span><br><span class="line"></span><br><span class="line">            Right++;</span><br><span class="line">            <span class="keyword">if</span> (Right &gt;= Len)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            plus += nums[Right];</span><br><span class="line">            <span class="keyword">if</span> (map.<span class="built_in">count</span>(nums[Right]))</span><br><span class="line">                map[nums[Right]]++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                map[nums[Right]] = <span class="number">1</span>;</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div style="text-align:right;"><p>本篇博客撰写于2023/9/3 09:33:40</p>]]></content>
    
    
    <summary type="html">LeetCode第112场双周赛</summary>
    
    
    
    <category term="程序" scheme="https://www.lwt-server.cn/categories/%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="LeetCode题解" scheme="https://www.lwt-server.cn/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
    <category term="LeetCode双周赛" scheme="https://www.lwt-server.cn/tags/LeetCode%E5%8F%8C%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解——31.下一个排列</title>
    <link href="https://www.lwt-server.cn/2023/09/02/LeetCode_31/"/>
    <id>https://www.lwt-server.cn/2023/09/02/LeetCode_31/</id>
    <published>2023-09-02T11:02:10.000Z</published>
    <updated>2023-09-03T02:01:05.498Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="下一个排列">下一个排列</h2><h3 id="题目预览">题目预览：</h3><p>整数数组的一个 <b>排列</b> 就是将其所有成员以序列或线性顺序排列。</p><p>例如，<span class="math inline">\(arr = [1,2,3]\)</span>，以下这些都可以视作 <span class="math inline">\(arr\)</span>的排列：<span class="math inline">\([1,2,3]\)</span>、<spanclass="math inline">\([1,3,2]\)</span>、<spanclass="math inline">\([3,1,2]\)</span>、<spanclass="math inline">\([2,3,1]\)</span> 。</p><p>整数数组的 <b>下一个排列</b>是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的<b>下一个排列</b>就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p><p>例如，<span class="math inline">\(arr = [1,2,3]\)</span>的下一个排列是 <span class="math inline">\([1,3,2]\)</span> 。</p><p>类似地，<span class="math inline">\(arr = [2,3,1]\)</span>的下一个排列是 <span class="math inline">\([3,1,2]\)</span> 。</p><p>而 <span class="math inline">\(arr = [3,2,1]\)</span> 的下一个排列是<span class="math inline">\([1,2,3]\)</span> ，因为 <spanclass="math inline">\([3,2,1]\)</span> 不存在一个字典序更大的排列。</p><p>给你一个整数数组 <span class="math inline">\(nums\)</span> ，找出<span class="math inline">\(nums\)</span> 的下一个排列。</p><p>必须 <b>原地</b> 修改，只允许使用额外常数空间。</p><h4 id="示例-1">示例 1：</h4><p><b>输入：</b>nums = [1,2,3]<br /><b>输出：</b>[1,3,2]</p><h4 id="示例-2">示例 2：</h4><p><b>输入：</b>nums = [3,2,1]<br /><b>输出：</b>[1,2,3]</p><h4 id="示例-3">示例 3：</h4><p><b>输入：</b>nums = [1,1,5]<br /><b>输出：</b>[1,5,1]</p><p>提示：</p><ul><li><p><span class="math inline">\(1 &lt;= nums.length &lt;=100\)</span></p></li><li><p><span class="math inline">\(0 &lt;= nums[i] &lt;=100\)</span></p></li></ul><hr /><p>以下是题解：</p><h3 id="解题思路">解题思路：</h3><p>对于长度为 <span class="math inline">\(n\)</span> 的排列 <spanclass="math inline">\(a\)</span>：</p><p>首先从后向前查找第一个顺序对 <spanclass="math inline">\((i,i+1)\)</span>，满足 <spanclass="math inline">\(a[i]&lt;a[i+1]\)</span> 。这样「较小数」即为 <spanclass="math inline">\(a[i]\)</span>。此时 <spanclass="math inline">\([i+1,n)\)</span> 必然是下降序列。</p><p>如果找到了顺序对，那么在区间 <spanclass="math inline">\([i+1,n)\)</span> 中从后向前查找第一个元素 <spanclass="math inline">\(j\)</span> 满足 <spanclass="math inline">\(a[i]&lt;a[j]\)</span> 。这样「较大数」即为 <spanclass="math inline">\(a[j]\)</span> 。</p><p>交换 <span class="math inline">\(a[i]\)</span> 与 <spanclass="math inline">\(a[j]\)</span> ，此时可以证明区间 <spanclass="math inline">\([i+1,n)\)</span>必为降序。我们可以直接使用双指针反转区间 <spanclass="math inline">\([i+1,n)\)</span>使其变为升序，而无需对该区间进行排序。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i+<span class="number">1</span>])</span><br><span class="line">            i--;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &lt;= nums[i])</span><br><span class="line">                j--;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i],nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>() + i + <span class="number">1</span>, nums.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPB4pB8"><imgsrc="https://s1.ax1x.com/2023/09/02/pPB4pB8.png"alt="pPB4pB8.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/9/2 19:02:10</p>]]></content>
    
    
    <summary type="html">下一个排列</summary>
    
    
    
    <category term="程序" scheme="https://www.lwt-server.cn/categories/%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="LeetCode题解" scheme="https://www.lwt-server.cn/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解——29.两数相除</title>
    <link href="https://www.lwt-server.cn/2023/09/02/LeetCode_29/"/>
    <id>https://www.lwt-server.cn/2023/09/02/LeetCode_29/</id>
    <published>2023-09-02T04:33:09.000Z</published>
    <updated>2023-09-02T04:50:59.053Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="两数相除">两数相除</h2><h3 id="题目预览">题目预览：</h3><p>给你两个整数，被除数 <span class="math inline">\(dividend\)</span>和除数 <span class="math inline">\(divisor\)</span>。将两数相除，要求<b>不使用</b> 乘法、除法和取余运算。</p><p>整数除法应该向零截断，也就是截去（truncate）其小数部分。例如，<spanclass="math inline">\(8.345\)</span> 将被截断为 <spanclass="math inline">\(8\)</span> ，<spanclass="math inline">\(-2.7335\)</span> 将被截断至 <spanclass="math inline">\(-2\)</span> 。</p><p>返回被除数 <span class="math inline">\(dividend\)</span> 除以除数<span class="math inline">\(divisor\)</span> 得到的 <b>商</b> 。</p><p>注意：假设我们的环境只能存储 <b><spanclass="math inline">\(32\)</span> 位</b> 有符号整数，其数值范围是 <spanclass="math inline">\([−2^{31}, 2^{31} − 1]\)</span> 。本题中，如果商<b>严格大于</b> <span class="math inline">\(2^{31} − 1\)</span> ，则返回<span class="math inline">\(2^{31} − 1\)</span> ；如果商 <b>严格小于</b><span class="math inline">\(-2^{31}\)</span> ，则返回 <spanclass="math inline">\(-2^{31}\)</span> 。</p><h4 id="示例-1">示例 1:</h4><blockquote><p><b>输入:</b> dividend = 10, divisor = 3<br /><b>输出:</b> 3<br /><b>解释:</b> 10/3 = 3.33333.. ，向零截断后得到 3 。</p></blockquote><h4 id="示例-2">示例 2:</h4><blockquote><p><b>输入:</b> dividend = 7, divisor = -3<br /><b>输出:</b> -2<br /><b>解释:</b> 7/-3 = -2.33333.. ，向零截断后得到 -2 。</p></blockquote><p>提示：</p><ul><li><p><span class="math inline">\(-2^{31} &lt;= dividend, divisor &lt;=2^{31} - 1\)</span></p></li><li><p><span class="math inline">\(divisor != 0\)</span></p></li></ul><hr /><p>以下是题解：</p><h3 id="解题思路">解题思路：</h3><p>我们记被除数为 <span class="math inline">\(X\)</span>，除数为 <spanclass="math inline">\(Y\)</span>，并且 <spanclass="math inline">\(X\)</span> 和 <spanclass="math inline">\(Y\)</span> 都是负数。我们需要找出 <spanclass="math inline">\(X/Y\)</span> 的结果 <spanclass="math inline">\(Z\)</span>。<span class="math inline">\(Z\)</span>一定是正数或 <span class="math inline">\(0\)</span>。</p><p>根据除法以及余数的定义，我们可以将其改成乘法的等价形式，即：</p><p><span class="math display">\[ Z×Y≥X&gt;(Z+1)×Y \]</span></p><p>因此，我们可以使用二分查找的方法得到 <spanclass="math inline">\(Z\)</span>，即找出 <b>最大</b> 的 <spanclass="math inline">\(Z\)</span> 使得 <spanclass="math inline">\(Z×Y≥X\)</span> 成立。</p><p>由于我们不能使用乘法运算符，因此我们需要使用「快速乘」算法得到 <spanclass="math inline">\(Z×Y\)</span>的值。「快速乘」算法与「快速幂」类似，前者通过加法实现乘法，后者通过乘法实现幂运算。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> dividend, <span class="type">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 考虑被除数为最小值的情况</span></span><br><span class="line">        <span class="keyword">if</span> (dividend == INT_MIN) &#123;</span><br><span class="line">            <span class="keyword">if</span> (divisor == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> INT_MIN;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (divisor == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> INT_MAX;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 考虑除数为最小值的情况</span></span><br><span class="line">        <span class="keyword">if</span> (divisor == INT_MIN) &#123;</span><br><span class="line">            <span class="keyword">return</span> dividend == INT_MIN ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 考虑被除数为 0 的情况</span></span><br><span class="line">        <span class="keyword">if</span> (dividend == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 一般情况，使用二分查找</span></span><br><span class="line">        <span class="comment">// 将所有的正数取相反数，这样就只需要考虑一种情况</span></span><br><span class="line">        <span class="type">bool</span> rev = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (dividend &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dividend = -dividend;</span><br><span class="line">            rev = !rev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (divisor &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            divisor = -divisor;</span><br><span class="line">            rev = !rev;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 快速乘</span></span><br><span class="line">        <span class="keyword">auto</span> quickAdd = [](<span class="type">int</span> y, <span class="type">int</span> z, <span class="type">int</span> x) &#123;</span><br><span class="line">            <span class="comment">// x 和 y 是负数，z 是正数</span></span><br><span class="line">            <span class="comment">// 需要判断 z * y &gt;= x 是否成立</span></span><br><span class="line">            <span class="type">int</span> result = <span class="number">0</span>, add = y;</span><br><span class="line">            <span class="keyword">while</span> (z) &#123;</span><br><span class="line">                <span class="keyword">if</span> (z &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 需要保证 result + add &gt;= x</span></span><br><span class="line">                    <span class="keyword">if</span> (result &lt; x - add) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    result += add;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (z != <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 需要保证 add + add &gt;= x</span></span><br><span class="line">                    <span class="keyword">if</span> (add &lt; x - add) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    add += add;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 不能使用除法</span></span><br><span class="line">                z &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> left = <span class="number">1</span>, right = INT_MAX, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="comment">// 注意溢出，并且不能使用除法</span></span><br><span class="line">            <span class="type">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="type">bool</span> check = <span class="built_in">quickAdd</span>(divisor, mid, dividend);</span><br><span class="line">            <span class="keyword">if</span> (check) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                <span class="comment">// 注意溢出</span></span><br><span class="line">                <span class="keyword">if</span> (mid == INT_MAX) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rev ? -ans : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPBtbx1"><imgsrc="https://s1.ax1x.com/2023/09/02/pPBtbx1.png"alt="pPBtbx1.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/9/2 12:33:09</p>]]></content>
    
    
    <summary type="html">两数相除</summary>
    
    
    
    <category term="程序" scheme="https://www.lwt-server.cn/categories/%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="LeetCode题解" scheme="https://www.lwt-server.cn/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
    <category term="快速幂" scheme="https://www.lwt-server.cn/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解——2511.最多可以摧毁的敌人城堡数目</title>
    <link href="https://www.lwt-server.cn/2023/09/02/LeetCode_2511/"/>
    <id>https://www.lwt-server.cn/2023/09/02/LeetCode_2511/</id>
    <published>2023-09-02T00:41:40.000Z</published>
    <updated>2023-09-02T05:05:35.937Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="最多可以摧毁的敌人城堡数目">最多可以摧毁的敌人城堡数目</h2><h3 id="题目预览">题目预览：</h3><p>给你一个长度为 <span class="math inline">\(n\)</span> ，下标从 <spanclass="math inline">\(0\)</span> 开始的整数数组 <spanclass="math inline">\(forts\)</span> ，表示一些城堡。<spanclass="math inline">\(forts[i]\)</span> 可以是 <spanclass="math inline">\(-1\)</span> ，<spanclass="math inline">\(0\)</span> 或者 <spanclass="math inline">\(1\)</span> ，其中：</p><ul><li><p><span class="math inline">\(-1\)</span> 表示第 <spanclass="math inline">\(i\)</span> 个位置 <b>没有</b> 城堡。</p></li><li><p><span class="math inline">\(0\)</span> 表示第 <spanclass="math inline">\(i\)</span> 个位置有一个 <b>敌人</b>的城堡。</p></li><li><p><span class="math inline">\(1\)</span> 表示第 <spanclass="math inline">\(i\)</span> 个位置有一个你控制的城堡。</p></li></ul><p>现在，你需要决定，将你的军队从某个你控制的城堡位置 <spanclass="math inline">\(i\)</span> 移动到一个空的位置 <spanclass="math inline">\(j\)</span> ，满足：</p><ul><li><p><span class="math inline">\(0 &lt;= i, j &lt;= n -1\)</span></p></li><li><p>军队经过的位置 <b>只有</b> 敌人的城堡。正式的，对于所有 <spanclass="math inline">\(min(i,j) &lt; k &lt; max(i,j)\)</span> 的 <spanclass="math inline">\(k\)</span> ，都满足 <spanclass="math inline">\(forts[k] == 0\)</span> 。</p></li></ul><p>当军队移动时，所有途中经过的敌人城堡都会被 <b>摧毁</b> 。</p><p>请你返回 <b>最多</b> 可以摧毁的敌人城堡数目。如果 <b>无法</b>移动你的军队，或者没有你控制的城堡，请返回 <spanclass="math inline">\(0\)</span> 。</p><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>forts = [1,0,0,-1,0,0,0,0,1]<br /><b>输出：</b>4<br /><b>解释：</b><br />-将军队从位置 0 移动到位置 3 ，摧毁 2 个敌人城堡，位置分别在 1 和 2。<br />-将军队从位置 8 移动到位置 3 ，摧毁 4 个敌人城堡。<br />4 是最多可以摧毁的敌人城堡数目，所以我们返回 4 。</p></blockquote><h4 id="示例-2">示例 2：</h4><p><b>输入：</b>forts = [0,0,1,-1] <b>输出：</b>0<b>解释：</b>由于无法摧毁敌人的城堡，所以返回 0 。</p><p>提示：</p><ul><li><p><span class="math inline">\(1 &lt;= forts.length &lt;=1000\)</span></p></li><li><p><span class="math inline">\(-1 &lt;= forts[i] &lt;=1\)</span></p></li></ul><hr /><p>以下是题解：</p><h3 id="解题思路">解题思路：</h3><p>本题可以从头到尾遍历每一个位置，若该位置不为0，则根据已有数据计算ans</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">captureForts</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; forts)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> Len = forts.<span class="built_in">size</span>(),ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(forts[i]!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> sum = forts[i],Start = ++i;</span><br><span class="line">                <span class="keyword">while</span>(sum != <span class="number">0</span> &amp;&amp; i&lt;Len)</span><br><span class="line">                &#123;</span><br><span class="line">                    sum += forts[i];</span><br><span class="line">                    <span class="keyword">if</span>(sum==<span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        ans = i-Start&gt;ans ? i-Start:ans;</span><br><span class="line">                        i--;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(sum==<span class="number">2</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Start = i+<span class="number">1</span>;</span><br><span class="line">                        sum = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(sum==<span class="number">-2</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Start = i+<span class="number">1</span>;</span><br><span class="line">                        sum = <span class="number">-1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPBNFMt"><imgsrc="https://s1.ax1x.com/2023/09/02/pPBNFMt.png"alt="pPBNFMt.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/9/2 08:41:40</p>]]></content>
    
    
    <summary type="html">最多可以摧毁的敌人城堡数目</summary>
    
    
    
    <category term="程序" scheme="https://www.lwt-server.cn/categories/%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="LeetCode题解" scheme="https://www.lwt-server.cn/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
    <category term="LeetCode每日一题" scheme="https://www.lwt-server.cn/tags/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解——28.找出字符串中第一个匹配项的下标</title>
    <link href="https://www.lwt-server.cn/2023/09/01/LeetCode_28/"/>
    <id>https://www.lwt-server.cn/2023/09/01/LeetCode_28/</id>
    <published>2023-09-01T12:33:11.000Z</published>
    <updated>2023-09-01T14:35:27.508Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2id="找出字符串中第一个匹配项的下标">找出字符串中第一个匹配项的下标</h2><h3 id="题目预览">题目预览：</h3><p>给你两个字符串 <span class="math inline">\(haystack\)</span> 和 <spanclass="math inline">\(needle\)</span> ，请你在 <spanclass="math inline">\(haystack\)</span> 字符串中找出 <spanclass="math inline">\(needle\)</span> 字符串的第一个匹配项的下标（下标从<span class="math inline">\(0\)</span> 开始）。如果 <spanclass="math inline">\(needle\)</span> 不是 <spanclass="math inline">\(haystack\)</span> 的一部分，则返回 <spanclass="math inline">\(-1\)</span> 。</p><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>haystack = "sadbutsad", needle = "sad"<br /><b>输出：</b>0<br /><b>解释：</b>"sad" 在下标 0 和 6 处匹配。<br />第一个匹配项的下标是 0 ，所以返回 0 。</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>haystack = "leetcode", needle = "leeto"<br /><b>输出：</b>-1<br /><b>解释：</b>"leeto" 没有在 "leetcode" 中出现，所以返回 -1 。</p></blockquote><p>提示：</p><ul><li><p><span class="math inline">\(1 &lt;= haystack.length,needle.length &lt;= 10^4\)</span></p></li><li><p><span class="math inline">\(haystack\)</span> 和 <spanclass="math inline">\(needle\)</span> 仅由小写英文字符组成</p></li></ul><hr /><p>以下是题解：</p><h3 id="解题思路kmp算法">解题思路——KMP算法：</h3><p>本题是很明显的字符串匹配问题，趁这个机会复习一下KMP算法</p><p>KMP算法的核心包括两个部分：</p><ul><li><p>next数组的维护</p></li><li><p>字符串匹配</p></li></ul><h4 id="next数组的维护">next数组的维护</h4><ol type="1"><li><p>当 <span class="math inline">\(str[maxLength]\)</span> 和 <spanclass="math inline">\(str[i]\)</span> 相等时：则前后缀匹配的长度 <spanclass="math inline">\(maxLength+1\)</span>，<spanclass="math inline">\(next\)</span> 压入 {<spanclass="math inline">\(maxLength\)</span>} ，<spanclass="math inline">\(i\)</span>++</p></li><li><p>当 <span class="math inline">\(str[maxLength]\)</span> 和 <spanclass="math inline">\(str[i]\)</span> 不等时：</p><ol type="1"><li><p>如果 <span class="math inline">\(maxLength\)</span> 不为 <spanclass="math inline">\(0\)</span> ：<span class="math inline">\(maxLength= next[maxLength-1]\)</span></p></li><li><p>如果 <span class="math inline">\(maxLength\)</span> 等于 <spanclass="math inline">\(0\)</span> ：<spanclass="math inline">\(next\)</span> 压入 {<spanclass="math inline">\(0\)</span>} ，<spanclass="math inline">\(i\)</span>++</p></li></ol></li></ol><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Build</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, maxLength = <span class="number">0</span>;</span><br><span class="line">    str_next.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (i &lt; str.<span class="built_in">length</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[maxLength] == str[i])</span><br><span class="line">        &#123;</span><br><span class="line">            maxLength++;</span><br><span class="line">            str_next.<span class="built_in">push_back</span>(maxLength);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxLength == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                str_next.<span class="built_in">push_back</span>(maxLength);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                maxLength = str_next[maxLength - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匹配">匹配</h4><p>对于两个字符串AB，其中要判断B是否为A的字串，则我们需要指针指针二者首个字符，然后同时向前移动。如果有不匹配的地方，则将B字符串的指针通过next数组向前移动至上一个完全匹配的位置。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Build</span>(needle);</span><br><span class="line">    <span class="type">int</span> Len = haystack.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; Len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (haystack[i] == needle[j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; <span class="number">0</span>)</span><br><span class="line">            j = str_next[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span> (j == needle.<span class="built_in">length</span>())</span><br><span class="line">            <span class="keyword">return</span> i - j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPBAWB6"><imgsrc="https://s1.ax1x.com/2023/09/01/pPBAWB6.png"alt="pPBAWB6.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/9/1 20:33:11</p>]]></content>
    
    
    <summary type="html">找出字符串中第一个匹配项的下标</summary>
    
    
    
    <category term="程序" scheme="https://www.lwt-server.cn/categories/%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="LeetCode题解" scheme="https://www.lwt-server.cn/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
    <category term="KMP算法" scheme="https://www.lwt-server.cn/tags/KMP%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解——27.移除元素</title>
    <link href="https://www.lwt-server.cn/2023/09/01/LeetCode_27/"/>
    <id>https://www.lwt-server.cn/2023/09/01/LeetCode_27/</id>
    <published>2023-09-01T09:55:37.000Z</published>
    <updated>2023-09-01T10:04:04.049Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="移除元素">移除元素</h2><h3 id="题目预览">题目预览：</h3><p>给你一个数组 <span class="math inline">\(nums\)</span> 和一个值 <spanclass="math inline">\(val\)</span>，你需要 <b>原地</b> 移除所有数值等于<span class="math inline">\(val\)</span>的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 <spanclass="math inline">\(O(1)\)</span> 额外空间并 原地 修改输入数组。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p>说明:</p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</span><br><span class="line">int len = removeElement(nums, val);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>nums = [3,2,2,3], val = 3<br /><b>输出：</b>2, nums = [2,2]<br /><b>解释：</b>函数应该返回新的长度 2, 并且 nums 中的前两个元素均为2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。</p></blockquote><h3 id="示例-2">示例 2：</h3><blockquote><p><b>输入：</b>nums = [0,1,2,2,3,0,4,2], val = 2<br /><b>输出：</b>5, nums = [0,1,4,0,3]<br /><b>解释：</b>函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3,0,4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</p></blockquote><p>提示：</p><ul><li><p><span class="math inline">\(0 &lt;= nums.length &lt;=100\)</span></p></li><li><p><span class="math inline">\(0 &lt;= nums[i] &lt;=50\)</span></p></li><li><p><span class="math inline">\(0 &lt;= val &lt;=100\)</span></p></li></ul><hr /><p>以下是题解：</p><h3 id="解题思路">解题思路:</h3><p>本题与前一题极其相似，思路几乎一模一样，详细请参考前文<ahref="/2023/09/01/LeetCode_26/">LeetCode_26——删除有序数组中的重复项</a></p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> Len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Len;i++)</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != val)</span><br><span class="line">                nums[ans++] = nums[i];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pP0LRmR"><imgsrc="https://s1.ax1x.com/2023/09/01/pP0LRmR.png"alt="pP0LRmR.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/9/1 17:55:37</p>]]></content>
    
    
    <summary type="html">移除元素</summary>
    
    
    
    <category term="程序" scheme="https://www.lwt-server.cn/categories/%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="LeetCode题解" scheme="https://www.lwt-server.cn/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解——26.删除有序数组中的重复项</title>
    <link href="https://www.lwt-server.cn/2023/09/01/LeetCode_26/"/>
    <id>https://www.lwt-server.cn/2023/09/01/LeetCode_26/</id>
    <published>2023-09-01T08:58:25.000Z</published>
    <updated>2023-09-01T09:09:40.290Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="删除有序数组中的重复项">删除有序数组中的重复项</h2><h3 id="题目预览">题目预览：</h3><p>给你一个 升序排列 的数组 <span class="math inline">\(nums\)</span>，请你 <b>原地</b> 删除重复出现的元素，使每个元素 <b>只出现一次</b>，返回删除后数组的新长度。元素的 <b>相对顺序</b> 应该保持 <b>一致</b>。然后返回 <span class="math inline">\(nums\)</span>中唯一元素的个数。</p><p>考虑 <span class="math inline">\(nums\)</span> 的唯一元素的数量为<span class="math inline">\(k\)</span>，你需要做以下事情确保你的题解可以被通过：</p><p>更改数组 <span class="math inline">\(nums\)</span> ，使 <spanclass="math inline">\(nums\)</span> 的前 <spanclass="math inline">\(k\)</span> 个元素包含唯一元素，并按照它们最初在<span class="math inline">\(nums\)</span> 中出现的顺序排列。<spanclass="math inline">\(nums\)</span> 的其余元素与 <spanclass="math inline">\(nums\)</span> 的大小不重要。 返回 <spanclass="math inline">\(k\)</span> 。</p><p><b>判题标准:</b></p><p>系统会用下面的代码来测试你的题解:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int[] nums = [...]; // 输入数组</span><br><span class="line">int[] expectedNums = [...]; // 长度正确的期望答案</span><br><span class="line"></span><br><span class="line">int k = removeDuplicates(nums); // 调用</span><br><span class="line"></span><br><span class="line">assert k == expectedNums.length;</span><br><span class="line">for (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">    assert nums[i] == expectedNums[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果所有断言都通过，那么您的题解将被 <b>通过</b>。</p><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>nums = [1,1,2]<br /><b>输出：</b>2, nums = [1,2,_]<br /><b>解释：</b>函数应该返回新的长度 2 ，并且原数组 nums的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>nums = [0,0,1,1,1,2,2,3,3,4]<br /><b>输出：</b>5, nums = [0,1,2,3,4]<br /><b>解释：</b>函数应该返回新的长度 5 ， 并且原数组 nums的前五个元素被修改为 0, 1, 2, 3, 4。不需要考虑数组中超出新长度后面的元素。</p></blockquote><p>提示：</p><ul><li><span class="math inline">\(1 &lt;= nums.length &lt;= 3 *10^4\)</span></li><li><span class="math inline">\(-10^4 &lt;= nums[i] &lt;=10^4\)</span></li><li><span class="math inline">\(nums\)</span> 已按 <b>升序</b> 排列</li></ul><hr /><p>以下是题解：</p><h3 id="解题思路">解题思路:</h3><p>使用两个指针，对于一个含有重复字符的容器，我们可以很容易得出结论：若<span class="math inline">\(nums&#39;\)</span> 为去重后的容器，那么对于<span class="math inline">\(nums&#39;\)</span>中的一切有效元素(指下标小于有效长度的元素)的下标 <spanclass="math inline">\(tag&#39;\)</span> 与原容器中有效元素的下标 <spanclass="math inline">\(tag\)</span>，我们可以得出 <spanclass="math inline">\(tag&gt;=tag&#39;\)</span></p><p>于是我们可以遍历原容器的每一个元素，当且仅当 <spanclass="math inline">\(nums[i-1]!=nums[i]\)</span> 时，我们才将其赋值给<span class="math inline">\(nums[ans]\)</span> ，并让 <spanclass="math inline">\(ans+1\)</span></p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> Len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Len;i++)</span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">0</span>||nums[i] != nums[i - <span class="number">1</span>])</span><br><span class="line">                nums[ans++] = nums[i];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pP0HCeP"><imgsrc="https://s1.ax1x.com/2023/09/01/pP0HCeP.png"alt="pP0HCeP.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/9/1 16:58:25</p>]]></content>
    
    
    <summary type="html">删除有序数组中的重复项</summary>
    
    
    
    <category term="程序" scheme="https://www.lwt-server.cn/categories/%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="LeetCode题解" scheme="https://www.lwt-server.cn/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解——25.K 个一组翻转链表</title>
    <link href="https://www.lwt-server.cn/2023/09/01/LeetCode_25/"/>
    <id>https://www.lwt-server.cn/2023/09/01/LeetCode_25/</id>
    <published>2023-09-01T06:35:42.000Z</published>
    <updated>2023-09-01T06:55:24.814Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="k-个一组翻转链表">K 个一组翻转链表</h2><h3 id="题目预览">题目预览：</h3><p>给你链表的头节点 <span class="math inline">\(head\)</span> ，每 <spanclass="math inline">\(k\)</span>个节点一组进行翻转，请你返回修改后的链表。</p><p><span class="math inline">\(k\)</span>是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <spanclass="math inline">\(k\)</span>的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><h4 id="示例-1">示例 1：</h4><p><a href="https://imgse.com/i/pP0WGz6"><imgsrc="https://s1.ax1x.com/2023/09/01/pP0WGz6.jpg"alt="pP0WGz6.jpg" /></a></p><p><b>输入：</b>head = [1,2,3,4,5], k = 2 <b>输出：</b>[2,1,4,3,5]</p><h4 id="示例-2">示例 2：</h4><p><a href="https://imgse.com/i/pP0WtsO"><imgsrc="https://s1.ax1x.com/2023/09/01/pP0WtsO.jpg"alt="pP0WtsO.jpg" /></a></p><p><b>输入：</b>head = [1,2,3,4,5], k = 3 <b>输出：</b>[3,2,1,4,5]</p><p>提示：</p><ul><li><p>链表中的节点数目为 <spanclass="math inline">\(n\)</span></p></li><li><p><span class="math inline">\(1 &lt;= k &lt;= n &lt;=5000\)</span></p></li><li><p><span class="math inline">\(0 &lt;= Node.val &lt;=1000\)</span></p></li></ul><p><b>进阶：</b>你可以设计一个只用 <spanclass="math inline">\(O(1)\)</span> 额外内存空间的算法解决此问题吗？</p><hr /><p>以下是题解：</p><h3 id="解题思路">解题思路:</h3><p>看到翻转，首先考虑到递归。而写递归的要点便是<b>理清递归条件：</b></p><p>自调用：</p><ol type="1"><li>当 <span class="math inline">\(num&gt;1\)</span> 时，令 <spanclass="math inline">\(num-1\)</span>，<spanclass="math inline">\(node=node-&gt;next\)</span> 并自调用</li></ol><p>回溯： 1. 当 <span class="math inline">\(num=1\)</span> 时，令 <spanclass="math inline">\(front\)</span>节点指向当前节点，尾节点指向下一节点。</p><ol start="2" type="1"><li><p>当 <span class="math inline">\(num=k\)</span>时，令下一节点指向当前节点，当前节点指向尾节点。</p></li><li><p>其他情况时，令下一节点指向当前节点</p></li></ol><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> N = <span class="number">0</span>;</span><br><span class="line">    ListNode* frontNode = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* lastNode = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traceBack</span><span class="params">(<span class="type">int</span> num, ListNode* node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &gt; <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">traceBack</span>(num - <span class="number">1</span>, node-&gt;next);</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            frontNode-&gt;next = node;</span><br><span class="line">            lastNode = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num == N)</span><br><span class="line">        &#123;</span><br><span class="line">            node-&gt;next-&gt;next = node;</span><br><span class="line">            node-&gt;next = lastNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            node-&gt;next-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        N = k;</span><br><span class="line">        frontNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        ListNode* ans = frontNode;</span><br><span class="line">        <span class="keyword">for</span> (; head != <span class="literal">nullptr</span>;)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* tmp = head;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (tmp == <span class="literal">nullptr</span>)</span><br><span class="line">                    <span class="keyword">return</span> ans-&gt;next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    tmp = tmp-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">traceBack</span>(k, head);</span><br><span class="line">            frontNode = head;</span><br><span class="line">            head = frontNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pP0W3J1"><imgsrc="https://s1.ax1x.com/2023/09/01/pP0W3J1.png"alt="pP0W3J1.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/9/1 14:35:42</p>]]></content>
    
    
    <summary type="html">K 个一组翻转链表</summary>
    
    
    
    <category term="程序" scheme="https://www.lwt-server.cn/categories/%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="LeetCode题解" scheme="https://www.lwt-server.cn/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解——24.两两交换链表中的节点</title>
    <link href="https://www.lwt-server.cn/2023/09/01/LeetCode_24/"/>
    <id>https://www.lwt-server.cn/2023/09/01/LeetCode_24/</id>
    <published>2023-09-01T02:27:37.000Z</published>
    <updated>2023-09-01T02:35:35.509Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="两两交换链表中的节点">两两交换链表中的节点</h2><h3 id="题目预览">题目预览：</h3><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><p><a href="https://imgse.com/i/pP0wfIO"><imgsrc="https://s1.ax1x.com/2023/09/01/pP0wfIO.jpg"alt="pP0wfIO.jpg" /></a></p><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>head = [1,2,3,4]<br /><b>输出：</b>[2,1,4,3]</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>head = []<br /><b>输出：</b>[]</p></blockquote><h4 id="示例-3">示例 3：</h4><blockquote><p><b>输入：</b>head = [1]<br /><b>输出：</b>[1]</p></blockquote><p>提示：</p><ul><li><p>链表中节点的数目在范围 <span class="math inline">\([0,100]\)</span> 内</p></li><li><p><span class="math inline">\(0 &lt;= Node.val &lt;=100\)</span></p></li></ul><hr /><p>以下是题解：</p><h3 id="解题思路">解题思路:</h3><p>我们可以使用迭代的方法，定义三个指针 <spanclass="math inline">\(leftNode\)</span> , <spanclass="math inline">\(middleNode\)</span> , <spanclass="math inline">\(rightNode\)</span> 参考下图的流程进行交互。</p><p><a href="https://imgse.com/i/pP0wtrq"><imgsrc="https://s1.ax1x.com/2023/09/01/pP0wtrq.jpg"alt="pP0wtrq.jpg" /></a></p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* headNode =  <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        ListNode* leftNode = headNode;</span><br><span class="line">        ListNode* middleNode = leftNode-&gt;next; </span><br><span class="line">        ListNode* rightNode = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(middleNode!=<span class="literal">nullptr</span>)</span><br><span class="line">            rightNode = middleNode-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> headNode-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(rightNode)</span><br><span class="line">        &#123;</span><br><span class="line">            middleNode-&gt;next = rightNode-&gt;next;</span><br><span class="line">            leftNode-&gt;next = rightNode;</span><br><span class="line">            rightNode-&gt;next = middleNode;</span><br><span class="line">            <span class="keyword">if</span>(middleNode-&gt;next!=<span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                leftNode = middleNode;</span><br><span class="line">                middleNode = leftNode-&gt;next;</span><br><span class="line">                <span class="keyword">if</span>(middleNode!=<span class="literal">nullptr</span>)</span><br><span class="line">                    rightNode = middleNode-&gt;next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> headNode-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> headNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> headNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pP0wcs1"><imgsrc="https://s1.ax1x.com/2023/09/01/pP0wcs1.png"alt="pP0wcs1.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/9/1 10:27:37</p>]]></content>
    
    
    <summary type="html">两两交换链表中的节点</summary>
    
    
    
    <category term="程序" scheme="https://www.lwt-server.cn/categories/%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="LeetCode题解" scheme="https://www.lwt-server.cn/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解——2240.买钢笔和铅笔的方案数</title>
    <link href="https://www.lwt-server.cn/2023/09/01/LeetCode_2240/"/>
    <id>https://www.lwt-server.cn/2023/09/01/LeetCode_2240/</id>
    <published>2023-09-01T00:33:27.000Z</published>
    <updated>2023-09-01T00:41:20.871Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="买钢笔和铅笔的方案数">买钢笔和铅笔的方案数</h2><h3 id="题目预览">题目预览：</h3><p>给你一个整数 <span class="math inline">\(total\)</span>，表示你拥有的总钱数。同时给你两个整数 <spanclass="math inline">\(cost1\)</span> 和 <spanclass="math inline">\(cost2\)</span>，分别表示一支钢笔和一支铅笔的价格。你可以花费你部分或者全部的钱，去买任意数目的两种笔。</p><p>请你返回购买钢笔和铅笔的 <b>不同方案数目</b> 。</p><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>total = 20, cost1 = 10, cost2 = 5<br /><b>输出：</b>9<br /><b>解释：</b>一支钢笔的价格为 10 ，一支铅笔的价格为 5 。<br />- 如果你买 0 支钢笔，那么你可以买 0 ，1 ，2 ，3 或者 4 支铅笔。<br />- 如果你买 1 支钢笔，那么你可以买 0 ，1 或者 2 支铅笔。<br />- 如果你买 2 支钢笔，那么你没法买任何铅笔。<br />所以买钢笔和铅笔的总方案数为 5 + 3 + 1 = 9 种。</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>total = 5, cost1 = 10, cost2 = 10<br /><b>输出：</b>1<br /><b>解释：</b>钢笔和铅笔的价格都为 10，都比拥有的钱数多，所以你没法购买任何文具。所以只有 1 种方案：买 0支钢笔和 0 支铅笔。</p></blockquote><p>提示：</p><ul><li><span class="math inline">\(1 &lt;= total, cost1, cost2 &lt;=10^6\)</span></li></ul><hr /><p>以下是题解：</p><h3 id="解题思路">解题思路:</h3><p>刚看到这题，我还以为是背包问题，仔细一想才发现就是个简单的数学问题。我们可以通过一层循环体模拟买钢笔的数量，剩余钱除以铅笔钱数来计算得到<span class="math inline">\(ans\)</span></p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">waysToBuyPensPencils</span><span class="params">(<span class="type">int</span> total, <span class="type">int</span> cost1, <span class="type">int</span> cost2)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; total&gt;=<span class="number">0</span> ;total -= cost1)</span><br><span class="line">            ans += total / cost2 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pP0NntH"><imgsrc="https://s1.ax1x.com/2023/09/01/pP0NntH.png"alt="pP0NntH.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/9/1 08:33:27</p>]]></content>
    
    
    <summary type="html">买钢笔和铅笔的方案数</summary>
    
    
    
    <category term="程序" scheme="https://www.lwt-server.cn/categories/%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="LeetCode题解" scheme="https://www.lwt-server.cn/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
    <category term="LeetCode每日一题" scheme="https://www.lwt-server.cn/tags/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解——23.合并 K 个升序链表</title>
    <link href="https://www.lwt-server.cn/2023/08/31/LeetCode_23/"/>
    <id>https://www.lwt-server.cn/2023/08/31/LeetCode_23/</id>
    <published>2023-08-31T12:40:59.000Z</published>
    <updated>2023-08-31T12:54:16.792Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="合并-k-个升序链表">合并 K 个升序链表</h2><h3 id="题目预览">题目预览：</h3><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>lists = [[1,4,5],[1,3,4],[2,6]]<br /><b>输出：</b>[1,1,2,3,4,4,5,6]<br /><b>解释：</b>链表数组如下：<br />[<br />1-&gt;4-&gt;5,<br />1-&gt;3-&gt;4,<br />2-&gt;6<br />]<br />将它们合并到一个有序链表中得到。<br />1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>lists = []<br /><b>输出：</b>[]</p></blockquote><h4 id="示例-3">示例 3：</h4><blockquote><p><b>输入：</b>lists = [[]]<br /><b>输出：</b>[]</p></blockquote><p>提示：</p><ul><li><p><span class="math inline">\(k == lists.length\)</span></p></li><li><p><span class="math inline">\(0 &lt;= k &lt;=10^4\)</span></p></li><li><p><span class="math inline">\(0 &lt;= lists[i].length &lt;=500\)</span></p></li><li><p><span class="math inline">\(-10^4 &lt;= lists[i][j] &lt;=10^4\)</span></p></li><li><p><span class="math inline">\(lists[i]\)</span> 按 <b>升序</b>排列</p></li><li><p><span class="math inline">\(lists[i].length\)</span> 的总和不超过<span class="math inline">\(10^4\)</span></p></li></ul><hr /><p>以下是题解：</p><h3 id="解题思路">解题思路:</h3><p>前置条件：理解<ahref="/2023/08/31/LeetCode_21/">LeetCode_21——合并两个链表</a>。在理解并完成上述函数后，我们的问题转变为了如何将 <spanclass="math inline">\(k\)</span> 个链表分解成若干组两个链表，即可采用<b>分治法</b></p><p>将k个链表两个分为一组，合并后再次重复上一步，直至剩余一个链表。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode *list1,ListNode *list2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode head;</span><br><span class="line">        ListNode* Node = &amp;head;</span><br><span class="line">        <span class="keyword">while</span>(list1&amp;&amp;list2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(list1-&gt;val&lt;list2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                Node-&gt;next = list1;</span><br><span class="line">                list1 = list1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Node-&gt;next = list2;</span><br><span class="line">                list2 = list2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            Node = Node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        Node-&gt;next = list1 == <span class="literal">nullptr</span> ? list2 : list1;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(vector&lt;ListNode*&gt; &amp;lists,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r)</span><br><span class="line">            <span class="keyword">return</span> lists[l];</span><br><span class="line">        <span class="keyword">if</span>(l&gt;r)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mergeTwoLists</span>(<span class="built_in">merge</span>(lists, l, mid),<span class="built_in">merge</span>(lists, mid + <span class="number">1</span>, r));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge</span>(lists, <span class="number">0</span>, lists.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pP0pm0H"><imgsrc="https://s1.ax1x.com/2023/08/31/pP0pm0H.png"alt="pP0pm0H.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/31 20:40:59</p>]]></content>
    
    
    <summary type="html">合并 K 个升序链表</summary>
    
    
    
    <category term="程序" scheme="https://www.lwt-server.cn/categories/%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="LeetCode题解" scheme="https://www.lwt-server.cn/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解——22.括号生成</title>
    <link href="https://www.lwt-server.cn/2023/08/31/LeetCode_22/"/>
    <id>https://www.lwt-server.cn/2023/08/31/LeetCode_22/</id>
    <published>2023-08-31T10:31:21.000Z</published>
    <updated>2023-08-31T10:39:02.444Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="括号生成">括号生成</h2><h3 id="题目预览">题目预览：</h3><p>数字 n代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的括号组合。</p><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>n = 3<b>输出：</b>["((()))","(()())","(())()","()(())","()()()"]</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>n = 1 <b>输出：</b>["()"]</p></blockquote><p>提示：</p><ul><li><span class="math inline">\(1 &lt;= n &lt;= 8\)</span></li></ul><hr /><p>以下是题解：</p><h3 id="解题思路">解题思路:</h3><p>本题可以通过记录左、右括号的个数来通过递归实现合法序列的求解。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Dfs</span><span class="params">(string str,<span class="type">int</span> left,<span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="number">0</span>&amp;&amp;right==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left==right) <span class="comment">//剩余左括号与右括号相等，只能使用左括号</span></span><br><span class="line">            <span class="built_in">Dfs</span>(str+<span class="string">&#x27;(&#x27;</span>,left<span class="number">-1</span>,right);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(left&gt;<span class="number">0</span>)  <span class="comment">//剩余左括号小于右括号，可以使用右括号或左括号</span></span><br><span class="line">                <span class="built_in">Dfs</span>(str+<span class="string">&#x27;(&#x27;</span>,left<span class="number">-1</span>,right);</span><br><span class="line">            <span class="built_in">Dfs</span>(str+<span class="string">&#x27;)&#x27;</span>,left,right<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">Dfs</span>(<span class="string">&quot;&quot;</span>,n,n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPwXzge"><imgsrc="https://s1.ax1x.com/2023/08/31/pPwXzge.png"alt="pPwXzge.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/31 18:31:21</p>]]></content>
    
    
    <summary type="html">括号生成</summary>
    
    
    
    <category term="程序" scheme="https://www.lwt-server.cn/categories/%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="LeetCode题解" scheme="https://www.lwt-server.cn/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解——21.合并两个有序链表</title>
    <link href="https://www.lwt-server.cn/2023/08/31/LeetCode_21/"/>
    <id>https://www.lwt-server.cn/2023/08/31/LeetCode_21/</id>
    <published>2023-08-31T09:20:34.000Z</published>
    <updated>2023-08-31T09:35:04.569Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="合并两个有序链表">合并两个有序链表</h2><h3 id="题目预览">题目预览：</h3><p>将两个升序链表合并为一个新的 <b>升序</b>链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><p><a href="https://imgse.com/i/pPwqrc9"><imgsrc="https://s1.ax1x.com/2023/08/31/pPwqrc9.jpg"alt="pPwqrc9.jpg" /></a></p><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>l1 = [1,2,4], l2 = [1,3,4]<br /><b>输出：</b>[1,1,2,3,4,4]</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>l1 = [], l2 = []<br /><b>输出：</b>[]</p></blockquote><h4 id="示例-3">示例 3：</h4><blockquote><p><b>输入：</b>l1 = [], l2 = [0]<br /><b>输出：</b>[0]</p></blockquote><p>提示：</p><ul><li><p>两个链表的节点数目范围是 <span class="math inline">\([0,50]\)</span></p></li><li><p><span class="math inline">\(-100 &lt;= Node.val &lt;=100\)</span></p></li><li><p><span class="math inline">\(l1\)</span> 和 <spanclass="math inline">\(l2\)</span> 均按 <b>非递减顺序</b> 排列</p></li></ul><hr /><p>以下是题解：</p><h3 id="解题思路">解题思路:</h3><p>这题是很经典的题型，算法流程可参考归并排序，对于任意两个 <b>升序</b>的容器，我们只需依次从两个容器取出较小的数，直至其中一个或二者均为空。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>,<span class="literal">nullptr</span>);</span><br><span class="line">        ListNode* Node = head;</span><br><span class="line">        <span class="keyword">while</span>(list1&amp;&amp;list2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(list1-&gt;val&lt;list2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                Node-&gt;next = list1;</span><br><span class="line">                list1 = list1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Node-&gt;next = list2;</span><br><span class="line">                list2 = list2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            Node = Node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        Node-&gt;next = list1 == <span class="literal">nullptr</span> ? list2 : list1;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPwqBp4"><imgsrc="https://s1.ax1x.com/2023/08/31/pPwqBp4.png"alt="pPwqBp4.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/31 17:20:34</p>]]></content>
    
    
    <summary type="html">合并两个有序链表</summary>
    
    
    
    <category term="程序" scheme="https://www.lwt-server.cn/categories/%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="LeetCode题解" scheme="https://www.lwt-server.cn/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解——20.有效的括号</title>
    <link href="https://www.lwt-server.cn/2023/08/31/LeetCode_20/"/>
    <id>https://www.lwt-server.cn/2023/08/31/LeetCode_20/</id>
    <published>2023-08-31T04:28:43.000Z</published>
    <updated>2023-08-31T06:16:26.361Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="有效的括号">有效的括号</h2><h3 id="题目预览">题目预览：</h3><p>给定一个只包括<code>'('</code>，<code>')'</code>，<code>'&#123;'</code>，<code>'&#125;'</code>，<code>'['</code>，<code>']'</code>的字符串 <span class="math inline">\(s\)</span>，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol type="1"><li><p>左括号必须用相同类型的右括号闭合。</p></li><li><p>左括号必须以正确的顺序闭合。</p></li><li><p>每个右括号都有一个对应的相同类型的左括号。</p></li></ol><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>s = "()"<br /><b>输出：</b>true</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>s = "()<span></span>"<br /><b>输出：</b>true</p></blockquote><h4 id="示例-3">示例 3：</h4><blockquote><p><b>输入：</b>s = "(]"<br /><b>输出：</b>false</p></blockquote><p>提示：</p><ul><li><p><span class="math inline">\(1 &lt;= s.length &lt;=10^4\)</span></p></li><li><p><span class="math inline">\(s\)</span> 仅由括号<code>'()[]&#123;&#125;'</code> 组成</p></li></ul><hr /><p>以下是题解：</p><h3 id="解题思路">解题思路:</h3><p>拿到题，很多人应该和我一样想：如果计算出左括号的数量，和右括号的数量，如果每种括号左右数量相同，会不会就是有效的括号了呢？</p><p>事实上不是的，假如输入是<code>[&#123;]&#125;</code>，每种括号的左右数量分别相等，但不是有效的括号。这是因为结果还与括号的位置有关。</p><p>而我们能发现，对于有效的括号，它的部分子表达式仍然是有效的括号。</p><p>于是乎，我们考虑使用 <b>栈</b> 来处理这个问题：</p><p>当遇到匹配的最小括号对时，我们将这对括号从栈中删除（即出栈），如果最后栈为空，那么它是有效的括号，反之不是。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; Symbol;</span><br><span class="line">        <span class="type">int</span> Len=s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">if</span>(Len==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        Symbol.<span class="built_in">push</span>(s[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;Len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(Symbol.<span class="built_in">empty</span>())</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(Symbol.<span class="built_in">top</span>()==<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                    Symbol.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(Symbol.<span class="built_in">empty</span>())</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(Symbol.<span class="built_in">top</span>()==<span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                    Symbol.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(Symbol.<span class="built_in">empty</span>())</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(Symbol.<span class="built_in">top</span>()==<span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                    Symbol.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                Symbol.<span class="built_in">push</span>(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Symbol.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPw64qs"><imgsrc="https://s1.ax1x.com/2023/08/31/pPw64qs.png"alt="pPw64qs.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/31 12:28:43</p>]]></content>
    
    
    <summary type="html">有效的括号</summary>
    
    
    
    <category term="程序" scheme="https://www.lwt-server.cn/categories/%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="LeetCode题解" scheme="https://www.lwt-server.cn/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解——19.删除链表的倒数第 N 个结点</title>
    <link href="https://www.lwt-server.cn/2023/08/31/LeetCode_19/"/>
    <id>https://www.lwt-server.cn/2023/08/31/LeetCode_19/</id>
    <published>2023-08-31T02:49:57.000Z</published>
    <updated>2023-08-31T12:45:56.597Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="删除链表的倒数第-n-个结点">删除链表的倒数第 N 个结点</h2><h3 id="题目预览">题目预览：</h3><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><p><a href="https://imgse.com/i/pPww7cR"><imgsrc="https://s1.ax1x.com/2023/08/31/pPww7cR.jpg"alt="pPww7cR.jpg" /></a></p><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>head = [1,2,3,4,5], n = 2<br /><b>输出：</b>[1,2,3,5]</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>head = [1], n = 1<br /><b>输出：</b>[]</p></blockquote><h4 id="示例-3">示例 3：</h4><blockquote><p><b>输入：</b>head = [1,2], n = 1<br /><b>输出：</b>[1]</p></blockquote><p>提示：</p><ul><li><p>链表中结点的数目为 <spanclass="math inline">\(sz\)</span></p></li><li><p><span class="math inline">\(1 &lt;= sz &lt;= 30\)</span></p></li><li><p><span class="math inline">\(0 &lt;= Node.val &lt;=100\)</span></p></li><li><p><span class="math inline">\(1 &lt;= n &lt;= sz\)</span></p></li></ul><p><b>进阶：</b>你能尝试使用一趟扫描实现吗？</p><hr /><p>以下是题解：</p><h3 id="解题思路">解题思路:</h3><p>本题与我在(<ahref="/2023/08/25/LeetCode_2/">LeetCode_2——两数相加</a>)中的部分题解高度重合，这里就不再多做赘述，附上修改后的代码，其中进阶部分可以通过双指针——即间隔n个单位的两个指针，当后面的那个到达末端，前面那个既是我们要删去的数。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* newHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        ListNode* posNode = head;</span><br><span class="line">        ListNode* posNodeFront = newHead;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">0</span>,Len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(posNode!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            posNode=posNode-&gt;next;</span><br><span class="line">            Len++;</span><br><span class="line">        &#125;</span><br><span class="line">        posNode = head;</span><br><span class="line">        <span class="type">int</span> posData = Len-n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(num &lt; posData - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            posNodeFront = posNode;</span><br><span class="line">            posNode = posNode-&gt;next;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">            posNodeFront-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            posNodeFront-&gt;next = posNode-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> posNode;</span><br><span class="line">        posNode = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPwwT39"><imgsrc="https://s1.ax1x.com/2023/08/31/pPwwT39.png"alt="pPwwT39.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/31 10:49:57</p>]]></content>
    
    
    <summary type="html">删除链表的倒数第 N 个结点</summary>
    
    
    
    <category term="程序" scheme="https://www.lwt-server.cn/categories/%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="LeetCode题解" scheme="https://www.lwt-server.cn/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解——1761.一个图中连通三元组的最小度数</title>
    <link href="https://www.lwt-server.cn/2023/08/31/LeetCode_1761/"/>
    <id>https://www.lwt-server.cn/2023/08/31/LeetCode_1761/</id>
    <published>2023-08-31T02:09:24.000Z</published>
    <updated>2023-08-31T02:20:07.231Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="一个图中连通三元组的最小度数">一个图中连通三元组的最小度数</h2><h3 id="题目预览">题目预览：</h3><p>给你一个无向图，整数 <span class="math inline">\(n\)</span>表示图中节点的数目，<span class="math inline">\(edges\)</span>数组表示图中的边，其中 <span class="math inline">\(edges[i] = [ui,vi]\)</span> ，表示 <span class="math inline">\(ui\)</span> 和 <spanclass="math inline">\(vi\)</span> 之间有一条无向边。</p><p>一个 <b>连通三元组</b> 指的是 <b>三个</b>节点组成的集合且这三个点之间 <b>两两</b> 有边。</p><p><b>连通三元组的度数</b>是所有满足此条件的边的数目：一个顶点在这个三元组内，而另一个顶点不在这个三元组内。</p><p>请你返回所有连通三元组中度数的 <b>最小值</b>，如果图中没有连通三元组，那么返回 <spanclass="math inline">\(-1\)</span> 。</p><h4 id="示例-1">示例 1：</h4><p><a href="https://imgse.com/i/pPwaoaF"><imgsrc="https://s1.ax1x.com/2023/08/31/pPwaoaF.png"alt="pPwaoaF.png" /></a></p><blockquote><p><b>输入：</b>n = 6, edges =[[1,2],[1,3],[3,2],[4,1],[5,2],[3,6]]<br /><b>输出：</b>3<br /><b>解释：</b>只有一个三元组 [1,2,3] 。构成度数的边在上图中已被加粗。</p></blockquote><h4 id="示例-2">示例 2：</h4><p><a href="https://imgse.com/i/pPwaT54"><imgsrc="https://s1.ax1x.com/2023/08/31/pPwaT54.png"alt="pPwaT54.png" /></a></p><blockquote><p><b>输入：</b>n = 7, edges =[[1,3],[4,1],[4,3],[2,5],[5,6],[6,7],[7,5],[2,6]]<br /><b>输出：</b>0<br /><b>解释：</b>有 3 个三元组：<br />1) [1,4,3]，度数为 0 。<br />2) [2,5,6]，度数为 2 。<br />3) [5,6,7]，度数为 2 。</p></blockquote><p>提示：</p><ul><li><p><span class="math inline">\(2 &lt;= n &lt;= 400\)</span></p></li><li><p><span class="math inline">\(edges[i].length ==2\)</span></p></li><li><p><span class="math inline">\(1 &lt;= edges.length &lt;= n * (n-1)/ 2\)</span></p></li><li><p><span class="math inline">\(1 &lt;= ui, vi &lt;=n\)</span></p></li><li><p><span class="math inline">\(ui != vi\)</span></p></li><li><p>图中没有重复的边。</p></li></ul><hr /><p>以下是题解：</p><h3 id="解题思路">解题思路:</h3><p>身为蒟蒻的我在面对这题的时候只能想到用三重循环对每一个可能的三元组进行判断，通过提前维护一个储存每一个点的度数的容器来计算最小度数</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minTrioDegree</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">map</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">degree</span>(n);</span><br><span class="line">        <span class="type">int</span> sumEdge=edges.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;sumEdge;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x=edges[i][<span class="number">0</span>]<span class="number">-1</span>,y=edges[i][<span class="number">1</span>]<span class="number">-1</span>;</span><br><span class="line">            map[x][y]=<span class="number">1</span>;</span><br><span class="line">            map[y][x]=<span class="number">1</span>;</span><br><span class="line">            degree[x]++;</span><br><span class="line">            degree[y]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0x7fffffff</span>;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-2</span>;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n<span class="number">-1</span>;j++)</span><br><span class="line">                <span class="keyword">if</span>(map[i][j]==<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k=j+<span class="number">1</span>;k&lt;n;k++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(map[i][k]==<span class="number">1</span>&amp;&amp;map[j][k]==<span class="number">1</span>)</span><br><span class="line">                            ans=<span class="built_in">min</span>(ans,degree[i]+degree[j]+degree[k]<span class="number">-6</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans==<span class="number">0x7fffffff</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPwaIVU"><imgsrc="https://s1.ax1x.com/2023/08/31/pPwaIVU.png"alt="pPwaIVU.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/31 10:09:24</p>]]></content>
    
    
    <summary type="html">一个图中连通三元组的最小度数</summary>
    
    
    
    <category term="程序" scheme="https://www.lwt-server.cn/categories/%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="LeetCode题解" scheme="https://www.lwt-server.cn/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
    <category term="LeetCode每日一题" scheme="https://www.lwt-server.cn/tags/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解——18.四数之和</title>
    <link href="https://www.lwt-server.cn/2023/08/30/LeetCode_18/"/>
    <id>https://www.lwt-server.cn/2023/08/30/LeetCode_18/</id>
    <published>2023-08-30T14:45:26.000Z</published>
    <updated>2023-08-31T12:46:21.126Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="四数之和">四数之和</h2><h3 id="题目预览">题目预览：</h3><p>给你一个由 <span class="math inline">\(n\)</span> 个整数组成的数组<span class="math inline">\(nums\)</span> ，和一个目标值 <spanclass="math inline">\(target\)</span>。请你找出并返回满足下述全部条件且不重复的四元组 <spanclass="math inline">\([nums[a], nums[b], nums[c], nums[d]]\)</span>（若两个四元组元素一一对应，则认为两个四元组重复）：</p><ul><li><p><span class="math inline">\(0 &lt;= a, b, c, d &lt;n\)</span></p></li><li><p><span class="math inline">\(a\)</span> 、<spanclass="math inline">\(b\)</span> 、<spanclass="math inline">\(c\)</span> 和 <spanclass="math inline">\(d\)</span> 互不相同</p></li><li><p><span class="math inline">\(nums[a] + nums[b] + nums[c] + nums[d]== target\)</span></p></li></ul><p>你可以按 <b>任意顺序</b> 返回答案 。</p><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>nums = [1,0,-1,0,-2,2], target = 0<br /><b>输出：</b>[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>nums = [2,2,2,2,2], target = 8<br /><b>输出：</b>[[2,2,2,2]]</p></blockquote><p>提示：</p><ul><li><p><span class="math inline">\(1 &lt;= nums.length &lt;=200\)</span></p></li><li><p><span class="math inline">\(-10^9 &lt;= nums[i] &lt;=10^9\)</span></p></li><li><p><span class="math inline">\(-10^9 &lt;= target &lt;=10^9\)</span></p></li></ul><hr /><p>以下是题解：</p><h3 id="解题思路">解题思路:</h3><p><b>排序 + 双指针</b></p><p>基本思路与又是与(<ahref="/2023/08/29/LeetCode_15/">LeetCode_15——三数之和</a>)十分相似，因此在这里附上代码，具体思路详见(<ahref="/2023/08/29/LeetCode_15/">LeetCode_15——三数之和</a>)。</p><p>代码如下：</p><blockquote><p>这里做了一部分优化，可省去</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> a = <span class="number">0</span>; a &lt; n - <span class="number">3</span>; a++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> x = nums[a];</span><br><span class="line">            <span class="keyword">if</span>(a &amp;&amp; x == nums[a - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(x + nums[a + <span class="number">1</span>] + nums[a + <span class="number">2</span>] + nums[a + <span class="number">3</span>] &gt; target) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(x + nums[n - <span class="number">1</span>] + nums[n - <span class="number">2</span>] + nums[n - <span class="number">3</span>] &lt; target) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> b = a + <span class="number">1</span>; b &lt; n - <span class="number">2</span>; b++)&#123;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> y = nums[b];</span><br><span class="line">                <span class="keyword">if</span>(b &gt; a + <span class="number">1</span> &amp;&amp; y == nums[b - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(x + y + nums[b + <span class="number">1</span>] + nums[b + <span class="number">2</span>] &gt; target) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span>(x + y + nums[n - <span class="number">1</span>] + nums[n - <span class="number">2</span>] &lt; target) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> c = b + <span class="number">1</span>, d = n - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(c &lt; d) &#123;</span><br><span class="line">                    <span class="type">long</span> <span class="type">long</span> s = x + y + nums[c] + nums[d];</span><br><span class="line">                    <span class="keyword">if</span>(s &gt; target) d--;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(s &lt; target) c++;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        ans.<span class="built_in">push_back</span>(&#123;(<span class="type">int</span>)x, (<span class="type">int</span>)y, nums[c], nums[d]&#125;);</span><br><span class="line">                        <span class="keyword">for</span>(++c; c &lt; d &amp;&amp; nums[c] == nums[c - <span class="number">1</span>]; ++c);</span><br><span class="line">                        <span class="keyword">for</span>(--d; c &lt; d &amp;&amp; nums[c] == nums[d + <span class="number">1</span>]; --d);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPwMk7t"><imgsrc="https://s1.ax1x.com/2023/08/30/pPwMk7t.png"alt="pPwMk7t.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/30 22:45:26</p>]]></content>
    
    
    <summary type="html">四数之和</summary>
    
    
    
    <category term="程序" scheme="https://www.lwt-server.cn/categories/%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="LeetCode题解" scheme="https://www.lwt-server.cn/tags/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
</feed>
