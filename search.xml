<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LeetCode题解——1921.消灭怪物的最大数量</title>
      <link href="/2023/09/03/LeetCode_1921/"/>
      <url>/2023/09/03/LeetCode_1921/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="消灭怪物的最大数量">消灭怪物的最大数量</h2><h3 id="题目预览">题目预览：</h3><p>你正在玩一款电子游戏，在游戏中你需要保护城市免受怪物侵袭。给你一个<b>下标从 <span class="math inline">\(0\)</span> 开始</b> 且长度为 <spanclass="math inline">\(n\)</span> 的整数数组 <spanclass="math inline">\(dist\)</span> ，其中 <spanclass="math inline">\(dist[i]\)</span> 是第 <spanclass="math inline">\(i\)</span> 个怪物与城市的<b>初始距离</b>（单位：米）。</p><p>怪物以 <b>恒定</b> 的速度走向城市。给你一个长度为 <spanclass="math inline">\(n\)</span> 的整数数组 <spanclass="math inline">\(speed\)</span> 表示每个怪物的速度，其中 <spanclass="math inline">\(speed[i]\)</span> 是第 <spanclass="math inline">\(i\)</span> 个怪物的速度（单位：米/分）。</p><p>怪物从 第 <span class="math inline">\(0\)</span> 分钟时开始移动。你有一把武器，并可以 <b>选择</b>在每一分钟的开始时使用，包括第 <b>0</b>分钟。但是你无法在一分钟的中间使用武器。这种武器威力惊人，一次可以消灭任一还活着的怪物。</p><p>一旦任一怪物到达城市，你就输掉了这场游戏。如果某个怪物 <b>恰</b>在某一分钟开始时到达城市，这会被视为 <b>输掉</b>游戏，在你可以使用武器之前，游戏就会结束。</p><p>返回在你输掉游戏前可以消灭的怪物的 <b>最大</b>数量。如果你可以在所有怪物到达城市前将它们全部消灭，返回 <spanclass="math inline">\(n\)</span> 。</p><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>dist = [1,3,4], speed = [1,1,1]<br /><b>输出：</b>3<br /><b>解释：</b><br />第 0 分钟开始时，怪物的距离是 [1,3,4]，你消灭了第一个怪物。<br />第 1 分钟开始时，怪物的距离是 [X,2,3]，你没有消灭任何怪物。<br />第 2 分钟开始时，怪物的距离是 [X,1,2]，你消灭了第二个怪物。<br />第 3 分钟开始时，怪物的距离是 [X,X,1]，你消灭了第三个怪物。<br />所有 3 个怪物都可以被消灭。</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>dist = [1,1,2,3], speed = [1,1,1,1]<br /><b>输出：</b>1<br /><b>解释：</b><br />第 0 分钟开始时，怪物的距离是 [1,1,2,3]，你消灭了第一个怪物。<br />第 1 分钟开始时，怪物的距离是 [X,0,1,2]，你输掉了游戏。<br />你只能消灭 1 个怪物。</p></blockquote><h4 id="示例-3">示例 3：</h4><blockquote><p><b>输入：</b>dist = [3,2,4], speed = [5,3,2]<br /><b>输出：</b>1<br /><b>解释：</b><br />第 0 分钟开始时，怪物的距离是 [3,2,4]，你消灭了第一个怪物。<br />第 1 分钟开始时，怪物的距离是 [X,0,2]，你输掉了游戏。<br />你只能消灭 1 个怪物。</p></blockquote><p>提示：</p><ul><li><span class="math inline">\(n == dist.length ==speed.length\)</span></li><li><span class="math inline">\(1 &lt;= n &lt;= 10^5\)</span></li><li><span class="math inline">\(1 &lt;= dist[i], speed[i] &lt;=10^5\)</span></li></ul><hr /><p>以下是题解：</p><h3 id="解题思路">解题思路：</h3><p>使用贪心算法，我们分别计算出每一个怪兽到达城市所需的时间，排序后从小到大消灭。将我方的攻击时间序列和排序后的怪物到达时间依次进行比较，当第一次出现到达时间小于等于攻击时间，即表示怪物到达城市，我方会输掉游戏。在比较时，因为我方的攻击时间为整数，因此可以将怪物到达时间向上取整，可以达到避免浮点数误差的效果。如果遍历完序列都没有出现这种情况，则表示我方可以消灭全部怪物。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">eliminateMaximum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; dist, vector&lt;<span class="type">int</span>&gt;&amp; speed)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = dist.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arrivalTimes</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            arrivalTimes[i] = (dist[i] - <span class="number">1</span>) / speed[i] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(arrivalTimes.<span class="built_in">begin</span>(), arrivalTimes.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arrivalTimes[i] &lt;= i) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPDQxDe"><imgsrc="https://s1.ax1x.com/2023/09/03/pPDQxDe.png"alt="pPDQxDe.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/9/3 13:27:22</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode题解 </tag>
            
            <tag> LeetCode每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode题解——31.下一个排列</title>
      <link href="/2023/09/02/LeetCode_31/"/>
      <url>/2023/09/02/LeetCode_31/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="下一个排列">下一个排列</h2><h3 id="题目预览">题目预览：</h3><p>整数数组的一个 <b>排列</b> 就是将其所有成员以序列或线性顺序排列。</p><p>例如，<span class="math inline">\(arr = [1,2,3]\)</span>，以下这些都可以视作 <span class="math inline">\(arr\)</span>的排列：<span class="math inline">\([1,2,3]\)</span>、<spanclass="math inline">\([1,3,2]\)</span>、<spanclass="math inline">\([3,1,2]\)</span>、<spanclass="math inline">\([2,3,1]\)</span> 。</p><p>整数数组的 <b>下一个排列</b>是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的<b>下一个排列</b>就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p><p>例如，<span class="math inline">\(arr = [1,2,3]\)</span>的下一个排列是 <span class="math inline">\([1,3,2]\)</span> 。</p><p>类似地，<span class="math inline">\(arr = [2,3,1]\)</span>的下一个排列是 <span class="math inline">\([3,1,2]\)</span> 。</p><p>而 <span class="math inline">\(arr = [3,2,1]\)</span> 的下一个排列是<span class="math inline">\([1,2,3]\)</span> ，因为 <spanclass="math inline">\([3,2,1]\)</span> 不存在一个字典序更大的排列。</p><p>给你一个整数数组 <span class="math inline">\(nums\)</span> ，找出<span class="math inline">\(nums\)</span> 的下一个排列。</p><p>必须 <b>原地</b> 修改，只允许使用额外常数空间。</p><h4 id="示例-1">示例 1：</h4><p><b>输入：</b>nums = [1,2,3]<br /><b>输出：</b>[1,3,2]</p><h4 id="示例-2">示例 2：</h4><p><b>输入：</b>nums = [3,2,1]<br /><b>输出：</b>[1,2,3]</p><h4 id="示例-3">示例 3：</h4><p><b>输入：</b>nums = [1,1,5]<br /><b>输出：</b>[1,5,1]</p><p>提示：</p><ul><li><p><span class="math inline">\(1 &lt;= nums.length &lt;=100\)</span></p></li><li><p><span class="math inline">\(0 &lt;= nums[i] &lt;=100\)</span></p></li></ul><hr /><p>以下是题解：</p><h3 id="解题思路">解题思路：</h3><p>对于长度为 <span class="math inline">\(n\)</span> 的排列 <spanclass="math inline">\(a\)</span>：</p><p>首先从后向前查找第一个顺序对 <spanclass="math inline">\((i,i+1)\)</span>，满足 <spanclass="math inline">\(a[i]&lt;a[i+1]\)</span> 。这样「较小数」即为 <spanclass="math inline">\(a[i]\)</span>。此时 <spanclass="math inline">\([i+1,n)\)</span> 必然是下降序列。</p><p>如果找到了顺序对，那么在区间 <spanclass="math inline">\([i+1,n)\)</span> 中从后向前查找第一个元素 <spanclass="math inline">\(j\)</span> 满足 <spanclass="math inline">\(a[i]&lt;a[j]\)</span> 。这样「较大数」即为 <spanclass="math inline">\(a[j]\)</span> 。</p><p>交换 <span class="math inline">\(a[i]\)</span> 与 <spanclass="math inline">\(a[j]\)</span> ，此时可以证明区间 <spanclass="math inline">\([i+1,n)\)</span>必为降序。我们可以直接使用双指针反转区间 <spanclass="math inline">\([i+1,n)\)</span>使其变为升序，而无需对该区间进行排序。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i+<span class="number">1</span>])</span><br><span class="line">            i--;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &lt;= nums[i])</span><br><span class="line">                j--;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i],nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>() + i + <span class="number">1</span>, nums.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPB4pB8"><imgsrc="https://s1.ax1x.com/2023/09/02/pPB4pB8.png"alt="pPB4pB8.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/9/2 19:02:10</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode题解——29.两数相除</title>
      <link href="/2023/09/02/LeetCode_29/"/>
      <url>/2023/09/02/LeetCode_29/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="两数相除">两数相除</h2><h3 id="题目预览">题目预览：</h3><p>给你两个整数，被除数 <span class="math inline">\(dividend\)</span>和除数 <span class="math inline">\(divisor\)</span>。将两数相除，要求<b>不使用</b> 乘法、除法和取余运算。</p><p>整数除法应该向零截断，也就是截去（truncate）其小数部分。例如，<spanclass="math inline">\(8.345\)</span> 将被截断为 <spanclass="math inline">\(8\)</span> ，<spanclass="math inline">\(-2.7335\)</span> 将被截断至 <spanclass="math inline">\(-2\)</span> 。</p><p>返回被除数 <span class="math inline">\(dividend\)</span> 除以除数<span class="math inline">\(divisor\)</span> 得到的 <b>商</b> 。</p><p>注意：假设我们的环境只能存储 <b><spanclass="math inline">\(32\)</span> 位</b> 有符号整数，其数值范围是 <spanclass="math inline">\([−2^{31}, 2^{31} − 1]\)</span> 。本题中，如果商<b>严格大于</b> <span class="math inline">\(2^{31} − 1\)</span> ，则返回<span class="math inline">\(2^{31} − 1\)</span> ；如果商 <b>严格小于</b><span class="math inline">\(-2^{31}\)</span> ，则返回 <spanclass="math inline">\(-2^{31}\)</span> 。</p><h4 id="示例-1">示例 1:</h4><blockquote><p><b>输入:</b> dividend = 10, divisor = 3<br /><b>输出:</b> 3<br /><b>解释:</b> 10/3 = 3.33333.. ，向零截断后得到 3 。</p></blockquote><h4 id="示例-2">示例 2:</h4><blockquote><p><b>输入:</b> dividend = 7, divisor = -3<br /><b>输出:</b> -2<br /><b>解释:</b> 7/-3 = -2.33333.. ，向零截断后得到 -2 。</p></blockquote><p>提示：</p><ul><li><p><span class="math inline">\(-2^{31} &lt;= dividend, divisor &lt;=2^{31} - 1\)</span></p></li><li><p><span class="math inline">\(divisor != 0\)</span></p></li></ul><hr /><p>以下是题解：</p><h3 id="解题思路">解题思路：</h3><p>我们记被除数为 <span class="math inline">\(X\)</span>，除数为 <spanclass="math inline">\(Y\)</span>，并且 <spanclass="math inline">\(X\)</span> 和 <spanclass="math inline">\(Y\)</span> 都是负数。我们需要找出 <spanclass="math inline">\(X/Y\)</span> 的结果 <spanclass="math inline">\(Z\)</span>。<span class="math inline">\(Z\)</span>一定是正数或 <span class="math inline">\(0\)</span>。</p><p>根据除法以及余数的定义，我们可以将其改成乘法的等价形式，即：</p><p><span class="math display">\[ Z×Y≥X&gt;(Z+1)×Y \]</span></p><p>因此，我们可以使用二分查找的方法得到 <spanclass="math inline">\(Z\)</span>，即找出 <b>最大</b> 的 <spanclass="math inline">\(Z\)</span> 使得 <spanclass="math inline">\(Z×Y≥X\)</span> 成立。</p><p>由于我们不能使用乘法运算符，因此我们需要使用「快速乘」算法得到 <spanclass="math inline">\(Z×Y\)</span>的值。「快速乘」算法与「快速幂」类似，前者通过加法实现乘法，后者通过乘法实现幂运算。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> dividend, <span class="type">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 考虑被除数为最小值的情况</span></span><br><span class="line">        <span class="keyword">if</span> (dividend == INT_MIN) &#123;</span><br><span class="line">            <span class="keyword">if</span> (divisor == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> INT_MIN;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (divisor == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> INT_MAX;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 考虑除数为最小值的情况</span></span><br><span class="line">        <span class="keyword">if</span> (divisor == INT_MIN) &#123;</span><br><span class="line">            <span class="keyword">return</span> dividend == INT_MIN ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 考虑被除数为 0 的情况</span></span><br><span class="line">        <span class="keyword">if</span> (dividend == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 一般情况，使用二分查找</span></span><br><span class="line">        <span class="comment">// 将所有的正数取相反数，这样就只需要考虑一种情况</span></span><br><span class="line">        <span class="type">bool</span> rev = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (dividend &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dividend = -dividend;</span><br><span class="line">            rev = !rev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (divisor &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            divisor = -divisor;</span><br><span class="line">            rev = !rev;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 快速乘</span></span><br><span class="line">        <span class="keyword">auto</span> quickAdd = [](<span class="type">int</span> y, <span class="type">int</span> z, <span class="type">int</span> x) &#123;</span><br><span class="line">            <span class="comment">// x 和 y 是负数，z 是正数</span></span><br><span class="line">            <span class="comment">// 需要判断 z * y &gt;= x 是否成立</span></span><br><span class="line">            <span class="type">int</span> result = <span class="number">0</span>, add = y;</span><br><span class="line">            <span class="keyword">while</span> (z) &#123;</span><br><span class="line">                <span class="keyword">if</span> (z &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 需要保证 result + add &gt;= x</span></span><br><span class="line">                    <span class="keyword">if</span> (result &lt; x - add) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    result += add;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (z != <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 需要保证 add + add &gt;= x</span></span><br><span class="line">                    <span class="keyword">if</span> (add &lt; x - add) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    add += add;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 不能使用除法</span></span><br><span class="line">                z &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> left = <span class="number">1</span>, right = INT_MAX, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="comment">// 注意溢出，并且不能使用除法</span></span><br><span class="line">            <span class="type">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="type">bool</span> check = <span class="built_in">quickAdd</span>(divisor, mid, dividend);</span><br><span class="line">            <span class="keyword">if</span> (check) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                <span class="comment">// 注意溢出</span></span><br><span class="line">                <span class="keyword">if</span> (mid == INT_MAX) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rev ? -ans : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPBtbx1"><imgsrc="https://s1.ax1x.com/2023/09/02/pPBtbx1.png"alt="pPBtbx1.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/9/2 12:33:09</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode题解 </tag>
            
            <tag> 快速幂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode题解——2511.最多可以摧毁的敌人城堡数目</title>
      <link href="/2023/09/02/LeetCode_2511/"/>
      <url>/2023/09/02/LeetCode_2511/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="最多可以摧毁的敌人城堡数目">最多可以摧毁的敌人城堡数目</h2><h3 id="题目预览">题目预览：</h3><p>给你一个长度为 <span class="math inline">\(n\)</span> ，下标从 <spanclass="math inline">\(0\)</span> 开始的整数数组 <spanclass="math inline">\(forts\)</span> ，表示一些城堡。<spanclass="math inline">\(forts[i]\)</span> 可以是 <spanclass="math inline">\(-1\)</span> ，<spanclass="math inline">\(0\)</span> 或者 <spanclass="math inline">\(1\)</span> ，其中：</p><ul><li><p><span class="math inline">\(-1\)</span> 表示第 <spanclass="math inline">\(i\)</span> 个位置 <b>没有</b> 城堡。</p></li><li><p><span class="math inline">\(0\)</span> 表示第 <spanclass="math inline">\(i\)</span> 个位置有一个 <b>敌人</b>的城堡。</p></li><li><p><span class="math inline">\(1\)</span> 表示第 <spanclass="math inline">\(i\)</span> 个位置有一个你控制的城堡。</p></li></ul><p>现在，你需要决定，将你的军队从某个你控制的城堡位置 <spanclass="math inline">\(i\)</span> 移动到一个空的位置 <spanclass="math inline">\(j\)</span> ，满足：</p><ul><li><p><span class="math inline">\(0 &lt;= i, j &lt;= n -1\)</span></p></li><li><p>军队经过的位置 <b>只有</b> 敌人的城堡。正式的，对于所有 <spanclass="math inline">\(min(i,j) &lt; k &lt; max(i,j)\)</span> 的 <spanclass="math inline">\(k\)</span> ，都满足 <spanclass="math inline">\(forts[k] == 0\)</span> 。</p></li></ul><p>当军队移动时，所有途中经过的敌人城堡都会被 <b>摧毁</b> 。</p><p>请你返回 <b>最多</b> 可以摧毁的敌人城堡数目。如果 <b>无法</b>移动你的军队，或者没有你控制的城堡，请返回 <spanclass="math inline">\(0\)</span> 。</p><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>forts = [1,0,0,-1,0,0,0,0,1]<br /><b>输出：</b>4<br /><b>解释：</b><br />-将军队从位置 0 移动到位置 3 ，摧毁 2 个敌人城堡，位置分别在 1 和 2。<br />-将军队从位置 8 移动到位置 3 ，摧毁 4 个敌人城堡。<br />4 是最多可以摧毁的敌人城堡数目，所以我们返回 4 。</p></blockquote><h4 id="示例-2">示例 2：</h4><p><b>输入：</b>forts = [0,0,1,-1] <b>输出：</b>0<b>解释：</b>由于无法摧毁敌人的城堡，所以返回 0 。</p><p>提示：</p><ul><li><p><span class="math inline">\(1 &lt;= forts.length &lt;=1000\)</span></p></li><li><p><span class="math inline">\(-1 &lt;= forts[i] &lt;=1\)</span></p></li></ul><hr /><p>以下是题解：</p><h3 id="解题思路">解题思路：</h3><p>本题可以从头到尾遍历每一个位置，若该位置不为0，则根据已有数据计算ans</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">captureForts</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; forts)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> Len = forts.<span class="built_in">size</span>(),ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(forts[i]!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> sum = forts[i],Start = ++i;</span><br><span class="line">                <span class="keyword">while</span>(sum != <span class="number">0</span> &amp;&amp; i&lt;Len)</span><br><span class="line">                &#123;</span><br><span class="line">                    sum += forts[i];</span><br><span class="line">                    <span class="keyword">if</span>(sum==<span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        ans = i-Start&gt;ans ? i-Start:ans;</span><br><span class="line">                        i--;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(sum==<span class="number">2</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Start = i+<span class="number">1</span>;</span><br><span class="line">                        sum = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(sum==<span class="number">-2</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Start = i+<span class="number">1</span>;</span><br><span class="line">                        sum = <span class="number">-1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPBNFMt"><imgsrc="https://s1.ax1x.com/2023/09/02/pPBNFMt.png"alt="pPBNFMt.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/9/2 08:41:40</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode题解 </tag>
            
            <tag> LeetCode每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode题解——28.找出字符串中第一个匹配项的下标</title>
      <link href="/2023/09/01/LeetCode_28/"/>
      <url>/2023/09/01/LeetCode_28/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2id="找出字符串中第一个匹配项的下标">找出字符串中第一个匹配项的下标</h2><h3 id="题目预览">题目预览：</h3><p>给你两个字符串 <span class="math inline">\(haystack\)</span> 和 <spanclass="math inline">\(needle\)</span> ，请你在 <spanclass="math inline">\(haystack\)</span> 字符串中找出 <spanclass="math inline">\(needle\)</span> 字符串的第一个匹配项的下标（下标从<span class="math inline">\(0\)</span> 开始）。如果 <spanclass="math inline">\(needle\)</span> 不是 <spanclass="math inline">\(haystack\)</span> 的一部分，则返回 <spanclass="math inline">\(-1\)</span> 。</p><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>haystack = "sadbutsad", needle = "sad"<br /><b>输出：</b>0<br /><b>解释：</b>"sad" 在下标 0 和 6 处匹配。<br />第一个匹配项的下标是 0 ，所以返回 0 。</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>haystack = "leetcode", needle = "leeto"<br /><b>输出：</b>-1<br /><b>解释：</b>"leeto" 没有在 "leetcode" 中出现，所以返回 -1 。</p></blockquote><p>提示：</p><ul><li><p><span class="math inline">\(1 &lt;= haystack.length,needle.length &lt;= 10^4\)</span></p></li><li><p><span class="math inline">\(haystack\)</span> 和 <spanclass="math inline">\(needle\)</span> 仅由小写英文字符组成</p></li></ul><hr /><p>以下是题解：</p><h3 id="解题思路kmp算法">解题思路——KMP算法：</h3><p>本题是很明显的字符串匹配问题，趁这个机会复习一下KMP算法</p><p>KMP算法的核心包括两个部分：</p><ul><li><p>next数组的维护</p></li><li><p>字符串匹配</p></li></ul><h4 id="next数组的维护">next数组的维护</h4><ol type="1"><li><p>当 <span class="math inline">\(str[maxLength]\)</span> 和 <spanclass="math inline">\(str[i]\)</span> 相等时：则前后缀匹配的长度 <spanclass="math inline">\(maxLength+1\)</span>，<spanclass="math inline">\(next\)</span> 压入 {<spanclass="math inline">\(maxLength\)</span>} ，<spanclass="math inline">\(i\)</span>++</p></li><li><p>当 <span class="math inline">\(str[maxLength]\)</span> 和 <spanclass="math inline">\(str[i]\)</span> 不等时：</p><ol type="1"><li><p>如果 <span class="math inline">\(maxLength\)</span> 不为 <spanclass="math inline">\(0\)</span> ：<span class="math inline">\(maxLength= next[maxLength-1]\)</span></p></li><li><p>如果 <span class="math inline">\(maxLength\)</span> 等于 <spanclass="math inline">\(0\)</span> ：<spanclass="math inline">\(next\)</span> 压入 {<spanclass="math inline">\(0\)</span>} ，<spanclass="math inline">\(i\)</span>++</p></li></ol></li></ol><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Build</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, maxLength = <span class="number">0</span>;</span><br><span class="line">    str_next.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (i &lt; str.<span class="built_in">length</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[maxLength] == str[i])</span><br><span class="line">        &#123;</span><br><span class="line">            maxLength++;</span><br><span class="line">            str_next.<span class="built_in">push_back</span>(maxLength);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxLength == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                str_next.<span class="built_in">push_back</span>(maxLength);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                maxLength = str_next[maxLength - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匹配">匹配</h4><p>对于两个字符串AB，其中要判断B是否为A的字串，则我们需要指针指针二者首个字符，然后同时向前移动。如果有不匹配的地方，则将B字符串的指针通过next数组向前移动至上一个完全匹配的位置。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Build</span>(needle);</span><br><span class="line">    <span class="type">int</span> Len = haystack.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; Len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (haystack[i] == needle[j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; <span class="number">0</span>)</span><br><span class="line">            j = str_next[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span> (j == needle.<span class="built_in">length</span>())</span><br><span class="line">            <span class="keyword">return</span> i - j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPBAWB6"><imgsrc="https://s1.ax1x.com/2023/09/01/pPBAWB6.png"alt="pPBAWB6.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/9/1 20:33:11</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode题解 </tag>
            
            <tag> KMP算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode题解——27.移除元素</title>
      <link href="/2023/09/01/LeetCode_27/"/>
      <url>/2023/09/01/LeetCode_27/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="移除元素">移除元素</h2><h3 id="题目预览">题目预览：</h3><p>给你一个数组 <span class="math inline">\(nums\)</span> 和一个值 <spanclass="math inline">\(val\)</span>，你需要 <b>原地</b> 移除所有数值等于<span class="math inline">\(val\)</span>的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 <spanclass="math inline">\(O(1)\)</span> 额外空间并 原地 修改输入数组。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p>说明:</p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</span><br><span class="line">int len = removeElement(nums, val);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>nums = [3,2,2,3], val = 3<br /><b>输出：</b>2, nums = [2,2]<br /><b>解释：</b>函数应该返回新的长度 2, 并且 nums 中的前两个元素均为2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。</p></blockquote><h3 id="示例-2">示例 2：</h3><blockquote><p><b>输入：</b>nums = [0,1,2,2,3,0,4,2], val = 2<br /><b>输出：</b>5, nums = [0,1,4,0,3]<br /><b>解释：</b>函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3,0,4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</p></blockquote><p>提示：</p><ul><li><p><span class="math inline">\(0 &lt;= nums.length &lt;=100\)</span></p></li><li><p><span class="math inline">\(0 &lt;= nums[i] &lt;=50\)</span></p></li><li><p><span class="math inline">\(0 &lt;= val &lt;=100\)</span></p></li></ul><hr /><p>以下是题解：</p><h3 id="解题思路">解题思路:</h3><p>本题与前一题极其相似，思路几乎一模一样，详细请参考前文<ahref="/2023/09/01/LeetCode_26/">LeetCode_26——删除有序数组中的重复项</a></p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> Len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Len;i++)</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != val)</span><br><span class="line">                nums[ans++] = nums[i];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pP0LRmR"><imgsrc="https://s1.ax1x.com/2023/09/01/pP0LRmR.png"alt="pP0LRmR.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/9/1 17:55:37</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode题解——26.删除有序数组中的重复项</title>
      <link href="/2023/09/01/LeetCode_26/"/>
      <url>/2023/09/01/LeetCode_26/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="删除有序数组中的重复项">删除有序数组中的重复项</h2><h3 id="题目预览">题目预览：</h3><p>给你一个 升序排列 的数组 <span class="math inline">\(nums\)</span>，请你 <b>原地</b> 删除重复出现的元素，使每个元素 <b>只出现一次</b>，返回删除后数组的新长度。元素的 <b>相对顺序</b> 应该保持 <b>一致</b>。然后返回 <span class="math inline">\(nums\)</span>中唯一元素的个数。</p><p>考虑 <span class="math inline">\(nums\)</span> 的唯一元素的数量为<span class="math inline">\(k\)</span>，你需要做以下事情确保你的题解可以被通过：</p><p>更改数组 <span class="math inline">\(nums\)</span> ，使 <spanclass="math inline">\(nums\)</span> 的前 <spanclass="math inline">\(k\)</span> 个元素包含唯一元素，并按照它们最初在<span class="math inline">\(nums\)</span> 中出现的顺序排列。<spanclass="math inline">\(nums\)</span> 的其余元素与 <spanclass="math inline">\(nums\)</span> 的大小不重要。 返回 <spanclass="math inline">\(k\)</span> 。</p><p><b>判题标准:</b></p><p>系统会用下面的代码来测试你的题解:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int[] nums = [...]; // 输入数组</span><br><span class="line">int[] expectedNums = [...]; // 长度正确的期望答案</span><br><span class="line"></span><br><span class="line">int k = removeDuplicates(nums); // 调用</span><br><span class="line"></span><br><span class="line">assert k == expectedNums.length;</span><br><span class="line">for (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">    assert nums[i] == expectedNums[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果所有断言都通过，那么您的题解将被 <b>通过</b>。</p><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>nums = [1,1,2]<br /><b>输出：</b>2, nums = [1,2,_]<br /><b>解释：</b>函数应该返回新的长度 2 ，并且原数组 nums的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>nums = [0,0,1,1,1,2,2,3,3,4]<br /><b>输出：</b>5, nums = [0,1,2,3,4]<br /><b>解释：</b>函数应该返回新的长度 5 ， 并且原数组 nums的前五个元素被修改为 0, 1, 2, 3, 4。不需要考虑数组中超出新长度后面的元素。</p></blockquote><p>提示：</p><ul><li><span class="math inline">\(1 &lt;= nums.length &lt;= 3 *10^4\)</span></li><li><span class="math inline">\(-10^4 &lt;= nums[i] &lt;=10^4\)</span></li><li><span class="math inline">\(nums\)</span> 已按 <b>升序</b> 排列</li></ul><hr /><p>以下是题解：</p><h3 id="解题思路">解题思路:</h3><p>使用两个指针，对于一个含有重复字符的容器，我们可以很容易得出结论：若<span class="math inline">\(nums&#39;\)</span> 为去重后的容器，那么对于<span class="math inline">\(nums&#39;\)</span>中的一切有效元素(指下标小于有效长度的元素)的下标 <spanclass="math inline">\(tag&#39;\)</span> 与原容器中有效元素的下标 <spanclass="math inline">\(tag\)</span>，我们可以得出 <spanclass="math inline">\(tag&gt;=tag&#39;\)</span></p><p>于是我们可以遍历原容器的每一个元素，当且仅当 <spanclass="math inline">\(nums[i-1]!=nums[i]\)</span> 时，我们才将其赋值给<span class="math inline">\(nums[ans]\)</span> ，并让 <spanclass="math inline">\(ans+1\)</span></p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> Len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Len;i++)</span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">0</span>||nums[i] != nums[i - <span class="number">1</span>])</span><br><span class="line">                nums[ans++] = nums[i];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pP0HCeP"><imgsrc="https://s1.ax1x.com/2023/09/01/pP0HCeP.png"alt="pP0HCeP.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/9/1 16:58:25</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode题解——25.K 个一组翻转链表</title>
      <link href="/2023/09/01/LeetCode_25/"/>
      <url>/2023/09/01/LeetCode_25/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="k-个一组翻转链表">K 个一组翻转链表</h2><h3 id="题目预览">题目预览：</h3><p>给你链表的头节点 <span class="math inline">\(head\)</span> ，每 <spanclass="math inline">\(k\)</span>个节点一组进行翻转，请你返回修改后的链表。</p><p><span class="math inline">\(k\)</span>是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <spanclass="math inline">\(k\)</span>的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><h4 id="示例-1">示例 1：</h4><p><a href="https://imgse.com/i/pP0WGz6"><imgsrc="https://s1.ax1x.com/2023/09/01/pP0WGz6.jpg"alt="pP0WGz6.jpg" /></a></p><p><b>输入：</b>head = [1,2,3,4,5], k = 2 <b>输出：</b>[2,1,4,3,5]</p><h4 id="示例-2">示例 2：</h4><p><a href="https://imgse.com/i/pP0WtsO"><imgsrc="https://s1.ax1x.com/2023/09/01/pP0WtsO.jpg"alt="pP0WtsO.jpg" /></a></p><p><b>输入：</b>head = [1,2,3,4,5], k = 3 <b>输出：</b>[3,2,1,4,5]</p><p>提示：</p><ul><li><p>链表中的节点数目为 <spanclass="math inline">\(n\)</span></p></li><li><p><span class="math inline">\(1 &lt;= k &lt;= n &lt;=5000\)</span></p></li><li><p><span class="math inline">\(0 &lt;= Node.val &lt;=1000\)</span></p></li></ul><p><b>进阶：</b>你可以设计一个只用 <spanclass="math inline">\(O(1)\)</span> 额外内存空间的算法解决此问题吗？</p><hr /><p>以下是题解：</p><h3 id="解题思路">解题思路:</h3><p>看到翻转，首先考虑到递归。而写递归的要点便是<b>理清递归条件：</b></p><p>自调用：</p><ol type="1"><li>当 <span class="math inline">\(num&gt;1\)</span> 时，令 <spanclass="math inline">\(num-1\)</span>，<spanclass="math inline">\(node=node-&gt;next\)</span> 并自调用</li></ol><p>回溯： 1. 当 <span class="math inline">\(num=1\)</span> 时，令 <spanclass="math inline">\(front\)</span>节点指向当前节点，尾节点指向下一节点。</p><ol start="2" type="1"><li><p>当 <span class="math inline">\(num=k\)</span>时，令下一节点指向当前节点，当前节点指向尾节点。</p></li><li><p>其他情况时，令下一节点指向当前节点</p></li></ol><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> N = <span class="number">0</span>;</span><br><span class="line">    ListNode* frontNode = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* lastNode = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traceBack</span><span class="params">(<span class="type">int</span> num, ListNode* node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &gt; <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">traceBack</span>(num - <span class="number">1</span>, node-&gt;next);</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            frontNode-&gt;next = node;</span><br><span class="line">            lastNode = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num == N)</span><br><span class="line">        &#123;</span><br><span class="line">            node-&gt;next-&gt;next = node;</span><br><span class="line">            node-&gt;next = lastNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            node-&gt;next-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        N = k;</span><br><span class="line">        frontNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        ListNode* ans = frontNode;</span><br><span class="line">        <span class="keyword">for</span> (; head != <span class="literal">nullptr</span>;)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* tmp = head;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (tmp == <span class="literal">nullptr</span>)</span><br><span class="line">                    <span class="keyword">return</span> ans-&gt;next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    tmp = tmp-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">traceBack</span>(k, head);</span><br><span class="line">            frontNode = head;</span><br><span class="line">            head = frontNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pP0W3J1"><imgsrc="https://s1.ax1x.com/2023/09/01/pP0W3J1.png"alt="pP0W3J1.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/9/1 14:35:42</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode题解——24.两两交换链表中的节点</title>
      <link href="/2023/09/01/LeetCode_24/"/>
      <url>/2023/09/01/LeetCode_24/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="两两交换链表中的节点">两两交换链表中的节点</h2><h3 id="题目预览">题目预览：</h3><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><p><a href="https://imgse.com/i/pP0wfIO"><imgsrc="https://s1.ax1x.com/2023/09/01/pP0wfIO.jpg"alt="pP0wfIO.jpg" /></a></p><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>head = [1,2,3,4]<br /><b>输出：</b>[2,1,4,3]</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>head = []<br /><b>输出：</b>[]</p></blockquote><h4 id="示例-3">示例 3：</h4><blockquote><p><b>输入：</b>head = [1]<br /><b>输出：</b>[1]</p></blockquote><p>提示：</p><ul><li><p>链表中节点的数目在范围 <span class="math inline">\([0,100]\)</span> 内</p></li><li><p><span class="math inline">\(0 &lt;= Node.val &lt;=100\)</span></p></li></ul><hr /><p>以下是题解：</p><h3 id="解题思路">解题思路:</h3><p>我们可以使用迭代的方法，定义三个指针 <spanclass="math inline">\(leftNode\)</span> , <spanclass="math inline">\(middleNode\)</span> , <spanclass="math inline">\(rightNode\)</span> 参考下图的流程进行交互。</p><p><a href="https://imgse.com/i/pP0wtrq"><imgsrc="https://s1.ax1x.com/2023/09/01/pP0wtrq.jpg"alt="pP0wtrq.jpg" /></a></p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* headNode =  <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        ListNode* leftNode = headNode;</span><br><span class="line">        ListNode* middleNode = leftNode-&gt;next; </span><br><span class="line">        ListNode* rightNode = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(middleNode!=<span class="literal">nullptr</span>)</span><br><span class="line">            rightNode = middleNode-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> headNode-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(rightNode)</span><br><span class="line">        &#123;</span><br><span class="line">            middleNode-&gt;next = rightNode-&gt;next;</span><br><span class="line">            leftNode-&gt;next = rightNode;</span><br><span class="line">            rightNode-&gt;next = middleNode;</span><br><span class="line">            <span class="keyword">if</span>(middleNode-&gt;next!=<span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                leftNode = middleNode;</span><br><span class="line">                middleNode = leftNode-&gt;next;</span><br><span class="line">                <span class="keyword">if</span>(middleNode!=<span class="literal">nullptr</span>)</span><br><span class="line">                    rightNode = middleNode-&gt;next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> headNode-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> headNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> headNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pP0wcs1"><imgsrc="https://s1.ax1x.com/2023/09/01/pP0wcs1.png"alt="pP0wcs1.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/9/1 10:27:37</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode题解——2240.买钢笔和铅笔的方案数</title>
      <link href="/2023/09/01/LeetCode_2240/"/>
      <url>/2023/09/01/LeetCode_2240/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="买钢笔和铅笔的方案数">买钢笔和铅笔的方案数</h2><h3 id="题目预览">题目预览：</h3><p>给你一个整数 <span class="math inline">\(total\)</span>，表示你拥有的总钱数。同时给你两个整数 <spanclass="math inline">\(cost1\)</span> 和 <spanclass="math inline">\(cost2\)</span>，分别表示一支钢笔和一支铅笔的价格。你可以花费你部分或者全部的钱，去买任意数目的两种笔。</p><p>请你返回购买钢笔和铅笔的 <b>不同方案数目</b> 。</p><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>total = 20, cost1 = 10, cost2 = 5<br /><b>输出：</b>9<br /><b>解释：</b>一支钢笔的价格为 10 ，一支铅笔的价格为 5 。<br />- 如果你买 0 支钢笔，那么你可以买 0 ，1 ，2 ，3 或者 4 支铅笔。<br />- 如果你买 1 支钢笔，那么你可以买 0 ，1 或者 2 支铅笔。<br />- 如果你买 2 支钢笔，那么你没法买任何铅笔。<br />所以买钢笔和铅笔的总方案数为 5 + 3 + 1 = 9 种。</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>total = 5, cost1 = 10, cost2 = 10<br /><b>输出：</b>1<br /><b>解释：</b>钢笔和铅笔的价格都为 10，都比拥有的钱数多，所以你没法购买任何文具。所以只有 1 种方案：买 0支钢笔和 0 支铅笔。</p></blockquote><p>提示：</p><ul><li><span class="math inline">\(1 &lt;= total, cost1, cost2 &lt;=10^6\)</span></li></ul><hr /><p>以下是题解：</p><h3 id="解题思路">解题思路:</h3><p>刚看到这题，我还以为是背包问题，仔细一想才发现就是个简单的数学问题。我们可以通过一层循环体模拟买钢笔的数量，剩余钱除以铅笔钱数来计算得到<span class="math inline">\(ans\)</span></p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">waysToBuyPensPencils</span><span class="params">(<span class="type">int</span> total, <span class="type">int</span> cost1, <span class="type">int</span> cost2)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; total&gt;=<span class="number">0</span> ;total -= cost1)</span><br><span class="line">            ans += total / cost2 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pP0NntH"><imgsrc="https://s1.ax1x.com/2023/09/01/pP0NntH.png"alt="pP0NntH.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/9/1 08:33:27</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode题解 </tag>
            
            <tag> LeetCode每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode题解——23.合并 K 个升序链表</title>
      <link href="/2023/08/31/LeetCode_23/"/>
      <url>/2023/08/31/LeetCode_23/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="合并-k-个升序链表">合并 K 个升序链表</h2><h3 id="题目预览">题目预览：</h3><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>lists = [[1,4,5],[1,3,4],[2,6]]<br /><b>输出：</b>[1,1,2,3,4,4,5,6]<br /><b>解释：</b>链表数组如下：<br />[<br />1-&gt;4-&gt;5,<br />1-&gt;3-&gt;4,<br />2-&gt;6<br />]<br />将它们合并到一个有序链表中得到。<br />1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>lists = []<br /><b>输出：</b>[]</p></blockquote><h4 id="示例-3">示例 3：</h4><blockquote><p><b>输入：</b>lists = [[]]<br /><b>输出：</b>[]</p></blockquote><p>提示：</p><ul><li><p><span class="math inline">\(k == lists.length\)</span></p></li><li><p><span class="math inline">\(0 &lt;= k &lt;=10^4\)</span></p></li><li><p><span class="math inline">\(0 &lt;= lists[i].length &lt;=500\)</span></p></li><li><p><span class="math inline">\(-10^4 &lt;= lists[i][j] &lt;=10^4\)</span></p></li><li><p><span class="math inline">\(lists[i]\)</span> 按 <b>升序</b>排列</p></li><li><p><span class="math inline">\(lists[i].length\)</span> 的总和不超过<span class="math inline">\(10^4\)</span></p></li></ul><hr /><p>以下是题解：</p><h3 id="解题思路">解题思路:</h3><p>前置条件：理解<ahref="/2023/08/31/LeetCode_21/">LeetCode_21——合并两个链表</a>。在理解并完成上述函数后，我们的问题转变为了如何将 <spanclass="math inline">\(k\)</span> 个链表分解成若干组两个链表，即可采用<b>分治法</b></p><p>将k个链表两个分为一组，合并后再次重复上一步，直至剩余一个链表。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode *list1,ListNode *list2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode head;</span><br><span class="line">        ListNode* Node = &amp;head;</span><br><span class="line">        <span class="keyword">while</span>(list1&amp;&amp;list2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(list1-&gt;val&lt;list2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                Node-&gt;next = list1;</span><br><span class="line">                list1 = list1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Node-&gt;next = list2;</span><br><span class="line">                list2 = list2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            Node = Node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        Node-&gt;next = list1 == <span class="literal">nullptr</span> ? list2 : list1;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(vector&lt;ListNode*&gt; &amp;lists,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r)</span><br><span class="line">            <span class="keyword">return</span> lists[l];</span><br><span class="line">        <span class="keyword">if</span>(l&gt;r)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mergeTwoLists</span>(<span class="built_in">merge</span>(lists, l, mid),<span class="built_in">merge</span>(lists, mid + <span class="number">1</span>, r));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge</span>(lists, <span class="number">0</span>, lists.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pP0pm0H"><imgsrc="https://s1.ax1x.com/2023/08/31/pP0pm0H.png"alt="pP0pm0H.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/31 20:40:59</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode题解——22.括号生成</title>
      <link href="/2023/08/31/LeetCode_22/"/>
      <url>/2023/08/31/LeetCode_22/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="括号生成">括号生成</h2><h3 id="题目预览">题目预览：</h3><p>数字 n代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的括号组合。</p><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>n = 3<b>输出：</b>["((()))","(()())","(())()","()(())","()()()"]</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>n = 1 <b>输出：</b>["()"]</p></blockquote><p>提示：</p><ul><li><span class="math inline">\(1 &lt;= n &lt;= 8\)</span></li></ul><hr /><p>以下是题解：</p><h3 id="解题思路">解题思路:</h3><p>本题可以通过记录左、右括号的个数来通过递归实现合法序列的求解。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Dfs</span><span class="params">(string str,<span class="type">int</span> left,<span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="number">0</span>&amp;&amp;right==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left==right) <span class="comment">//剩余左括号与右括号相等，只能使用左括号</span></span><br><span class="line">            <span class="built_in">Dfs</span>(str+<span class="string">&#x27;(&#x27;</span>,left<span class="number">-1</span>,right);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(left&gt;<span class="number">0</span>)  <span class="comment">//剩余左括号小于右括号，可以使用右括号或左括号</span></span><br><span class="line">                <span class="built_in">Dfs</span>(str+<span class="string">&#x27;(&#x27;</span>,left<span class="number">-1</span>,right);</span><br><span class="line">            <span class="built_in">Dfs</span>(str+<span class="string">&#x27;)&#x27;</span>,left,right<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">Dfs</span>(<span class="string">&quot;&quot;</span>,n,n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPwXzge"><imgsrc="https://s1.ax1x.com/2023/08/31/pPwXzge.png"alt="pPwXzge.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/31 18:31:21</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode题解——21.合并两个有序链表</title>
      <link href="/2023/08/31/LeetCode_21/"/>
      <url>/2023/08/31/LeetCode_21/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="合并两个有序链表">合并两个有序链表</h2><h3 id="题目预览">题目预览：</h3><p>将两个升序链表合并为一个新的 <b>升序</b>链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><p><a href="https://imgse.com/i/pPwqrc9"><imgsrc="https://s1.ax1x.com/2023/08/31/pPwqrc9.jpg"alt="pPwqrc9.jpg" /></a></p><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>l1 = [1,2,4], l2 = [1,3,4]<br /><b>输出：</b>[1,1,2,3,4,4]</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>l1 = [], l2 = []<br /><b>输出：</b>[]</p></blockquote><h4 id="示例-3">示例 3：</h4><blockquote><p><b>输入：</b>l1 = [], l2 = [0]<br /><b>输出：</b>[0]</p></blockquote><p>提示：</p><ul><li><p>两个链表的节点数目范围是 <span class="math inline">\([0,50]\)</span></p></li><li><p><span class="math inline">\(-100 &lt;= Node.val &lt;=100\)</span></p></li><li><p><span class="math inline">\(l1\)</span> 和 <spanclass="math inline">\(l2\)</span> 均按 <b>非递减顺序</b> 排列</p></li></ul><hr /><p>以下是题解：</p><h3 id="解题思路">解题思路:</h3><p>这题是很经典的题型，算法流程可参考归并排序，对于任意两个 <b>升序</b>的容器，我们只需依次从两个容器取出较小的数，直至其中一个或二者均为空。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>,<span class="literal">nullptr</span>);</span><br><span class="line">        ListNode* Node = head;</span><br><span class="line">        <span class="keyword">while</span>(list1&amp;&amp;list2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(list1-&gt;val&lt;list2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                Node-&gt;next = list1;</span><br><span class="line">                list1 = list1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Node-&gt;next = list2;</span><br><span class="line">                list2 = list2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            Node = Node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        Node-&gt;next = list1 == <span class="literal">nullptr</span> ? list2 : list1;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPwqBp4"><imgsrc="https://s1.ax1x.com/2023/08/31/pPwqBp4.png"alt="pPwqBp4.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/31 17:20:34</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode题解——20.有效的括号</title>
      <link href="/2023/08/31/LeetCode_20/"/>
      <url>/2023/08/31/LeetCode_20/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="有效的括号">有效的括号</h2><h3 id="题目预览">题目预览：</h3><p>给定一个只包括<code>'('</code>，<code>')'</code>，<code>'&#123;'</code>，<code>'&#125;'</code>，<code>'['</code>，<code>']'</code>的字符串 <span class="math inline">\(s\)</span>，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol type="1"><li><p>左括号必须用相同类型的右括号闭合。</p></li><li><p>左括号必须以正确的顺序闭合。</p></li><li><p>每个右括号都有一个对应的相同类型的左括号。</p></li></ol><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>s = "()"<br /><b>输出：</b>true</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>s = "()<span></span>"<br /><b>输出：</b>true</p></blockquote><h4 id="示例-3">示例 3：</h4><blockquote><p><b>输入：</b>s = "(]"<br /><b>输出：</b>false</p></blockquote><p>提示：</p><ul><li><p><span class="math inline">\(1 &lt;= s.length &lt;=10^4\)</span></p></li><li><p><span class="math inline">\(s\)</span> 仅由括号<code>'()[]&#123;&#125;'</code> 组成</p></li></ul><hr /><p>以下是题解：</p><h3 id="解题思路">解题思路:</h3><p>拿到题，很多人应该和我一样想：如果计算出左括号的数量，和右括号的数量，如果每种括号左右数量相同，会不会就是有效的括号了呢？</p><p>事实上不是的，假如输入是<code>[&#123;]&#125;</code>，每种括号的左右数量分别相等，但不是有效的括号。这是因为结果还与括号的位置有关。</p><p>而我们能发现，对于有效的括号，它的部分子表达式仍然是有效的括号。</p><p>于是乎，我们考虑使用 <b>栈</b> 来处理这个问题：</p><p>当遇到匹配的最小括号对时，我们将这对括号从栈中删除（即出栈），如果最后栈为空，那么它是有效的括号，反之不是。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; Symbol;</span><br><span class="line">        <span class="type">int</span> Len=s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">if</span>(Len==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        Symbol.<span class="built_in">push</span>(s[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;Len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(Symbol.<span class="built_in">empty</span>())</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(Symbol.<span class="built_in">top</span>()==<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                    Symbol.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(Symbol.<span class="built_in">empty</span>())</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(Symbol.<span class="built_in">top</span>()==<span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                    Symbol.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(Symbol.<span class="built_in">empty</span>())</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(Symbol.<span class="built_in">top</span>()==<span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                    Symbol.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                Symbol.<span class="built_in">push</span>(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Symbol.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPw64qs"><imgsrc="https://s1.ax1x.com/2023/08/31/pPw64qs.png"alt="pPw64qs.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/31 12:28:43</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode题解——19.删除链表的倒数第 N 个结点</title>
      <link href="/2023/08/31/LeetCode_19/"/>
      <url>/2023/08/31/LeetCode_19/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="删除链表的倒数第-n-个结点">删除链表的倒数第 N 个结点</h2><h3 id="题目预览">题目预览：</h3><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><p><a href="https://imgse.com/i/pPww7cR"><imgsrc="https://s1.ax1x.com/2023/08/31/pPww7cR.jpg"alt="pPww7cR.jpg" /></a></p><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>head = [1,2,3,4,5], n = 2<br /><b>输出：</b>[1,2,3,5]</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>head = [1], n = 1<br /><b>输出：</b>[]</p></blockquote><h4 id="示例-3">示例 3：</h4><blockquote><p><b>输入：</b>head = [1,2], n = 1<br /><b>输出：</b>[1]</p></blockquote><p>提示：</p><ul><li><p>链表中结点的数目为 <spanclass="math inline">\(sz\)</span></p></li><li><p><span class="math inline">\(1 &lt;= sz &lt;= 30\)</span></p></li><li><p><span class="math inline">\(0 &lt;= Node.val &lt;=100\)</span></p></li><li><p><span class="math inline">\(1 &lt;= n &lt;= sz\)</span></p></li></ul><p><b>进阶：</b>你能尝试使用一趟扫描实现吗？</p><hr /><p>以下是题解：</p><h3 id="解题思路">解题思路:</h3><p>本题与我在(<ahref="/2023/08/25/LeetCode_2/">LeetCode_2——两数相加</a>)中的部分题解高度重合，这里就不再多做赘述，附上修改后的代码，其中进阶部分可以通过双指针——即间隔n个单位的两个指针，当后面的那个到达末端，前面那个既是我们要删去的数。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* newHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        ListNode* posNode = head;</span><br><span class="line">        ListNode* posNodeFront = newHead;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">0</span>,Len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(posNode!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            posNode=posNode-&gt;next;</span><br><span class="line">            Len++;</span><br><span class="line">        &#125;</span><br><span class="line">        posNode = head;</span><br><span class="line">        <span class="type">int</span> posData = Len-n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(num &lt; posData - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            posNodeFront = posNode;</span><br><span class="line">            posNode = posNode-&gt;next;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">            posNodeFront-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            posNodeFront-&gt;next = posNode-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> posNode;</span><br><span class="line">        posNode = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPwwT39"><imgsrc="https://s1.ax1x.com/2023/08/31/pPwwT39.png"alt="pPwwT39.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/31 10:49:57</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode题解——1761.一个图中连通三元组的最小度数</title>
      <link href="/2023/08/31/LeetCode_1761/"/>
      <url>/2023/08/31/LeetCode_1761/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="一个图中连通三元组的最小度数">一个图中连通三元组的最小度数</h2><h3 id="题目预览">题目预览：</h3><p>给你一个无向图，整数 <span class="math inline">\(n\)</span>表示图中节点的数目，<span class="math inline">\(edges\)</span>数组表示图中的边，其中 <span class="math inline">\(edges[i] = [ui,vi]\)</span> ，表示 <span class="math inline">\(ui\)</span> 和 <spanclass="math inline">\(vi\)</span> 之间有一条无向边。</p><p>一个 <b>连通三元组</b> 指的是 <b>三个</b>节点组成的集合且这三个点之间 <b>两两</b> 有边。</p><p><b>连通三元组的度数</b>是所有满足此条件的边的数目：一个顶点在这个三元组内，而另一个顶点不在这个三元组内。</p><p>请你返回所有连通三元组中度数的 <b>最小值</b>，如果图中没有连通三元组，那么返回 <spanclass="math inline">\(-1\)</span> 。</p><h4 id="示例-1">示例 1：</h4><p><a href="https://imgse.com/i/pPwaoaF"><imgsrc="https://s1.ax1x.com/2023/08/31/pPwaoaF.png"alt="pPwaoaF.png" /></a></p><blockquote><p><b>输入：</b>n = 6, edges =[[1,2],[1,3],[3,2],[4,1],[5,2],[3,6]]<br /><b>输出：</b>3<br /><b>解释：</b>只有一个三元组 [1,2,3] 。构成度数的边在上图中已被加粗。</p></blockquote><h4 id="示例-2">示例 2：</h4><p><a href="https://imgse.com/i/pPwaT54"><imgsrc="https://s1.ax1x.com/2023/08/31/pPwaT54.png"alt="pPwaT54.png" /></a></p><blockquote><p><b>输入：</b>n = 7, edges =[[1,3],[4,1],[4,3],[2,5],[5,6],[6,7],[7,5],[2,6]]<br /><b>输出：</b>0<br /><b>解释：</b>有 3 个三元组：<br />1) [1,4,3]，度数为 0 。<br />2) [2,5,6]，度数为 2 。<br />3) [5,6,7]，度数为 2 。</p></blockquote><p>提示：</p><ul><li><p><span class="math inline">\(2 &lt;= n &lt;= 400\)</span></p></li><li><p><span class="math inline">\(edges[i].length ==2\)</span></p></li><li><p><span class="math inline">\(1 &lt;= edges.length &lt;= n * (n-1)/ 2\)</span></p></li><li><p><span class="math inline">\(1 &lt;= ui, vi &lt;=n\)</span></p></li><li><p><span class="math inline">\(ui != vi\)</span></p></li><li><p>图中没有重复的边。</p></li></ul><hr /><p>以下是题解：</p><h3 id="解题思路">解题思路:</h3><p>身为蒟蒻的我在面对这题的时候只能想到用三重循环对每一个可能的三元组进行判断，通过提前维护一个储存每一个点的度数的容器来计算最小度数</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minTrioDegree</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">map</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">degree</span>(n);</span><br><span class="line">        <span class="type">int</span> sumEdge=edges.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;sumEdge;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x=edges[i][<span class="number">0</span>]<span class="number">-1</span>,y=edges[i][<span class="number">1</span>]<span class="number">-1</span>;</span><br><span class="line">            map[x][y]=<span class="number">1</span>;</span><br><span class="line">            map[y][x]=<span class="number">1</span>;</span><br><span class="line">            degree[x]++;</span><br><span class="line">            degree[y]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0x7fffffff</span>;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-2</span>;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n<span class="number">-1</span>;j++)</span><br><span class="line">                <span class="keyword">if</span>(map[i][j]==<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k=j+<span class="number">1</span>;k&lt;n;k++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(map[i][k]==<span class="number">1</span>&amp;&amp;map[j][k]==<span class="number">1</span>)</span><br><span class="line">                            ans=<span class="built_in">min</span>(ans,degree[i]+degree[j]+degree[k]<span class="number">-6</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans==<span class="number">0x7fffffff</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPwaIVU"><imgsrc="https://s1.ax1x.com/2023/08/31/pPwaIVU.png"alt="pPwaIVU.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/31 10:09:24</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode题解 </tag>
            
            <tag> LeetCode每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode题解——18.四数之和</title>
      <link href="/2023/08/30/LeetCode_18/"/>
      <url>/2023/08/30/LeetCode_18/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="四数之和">四数之和</h2><h3 id="题目预览">题目预览：</h3><p>给你一个由 <span class="math inline">\(n\)</span> 个整数组成的数组<span class="math inline">\(nums\)</span> ，和一个目标值 <spanclass="math inline">\(target\)</span>。请你找出并返回满足下述全部条件且不重复的四元组 <spanclass="math inline">\([nums[a], nums[b], nums[c], nums[d]]\)</span>（若两个四元组元素一一对应，则认为两个四元组重复）：</p><ul><li><p><span class="math inline">\(0 &lt;= a, b, c, d &lt;n\)</span></p></li><li><p><span class="math inline">\(a\)</span> 、<spanclass="math inline">\(b\)</span> 、<spanclass="math inline">\(c\)</span> 和 <spanclass="math inline">\(d\)</span> 互不相同</p></li><li><p><span class="math inline">\(nums[a] + nums[b] + nums[c] + nums[d]== target\)</span></p></li></ul><p>你可以按 <b>任意顺序</b> 返回答案 。</p><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>nums = [1,0,-1,0,-2,2], target = 0<br /><b>输出：</b>[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>nums = [2,2,2,2,2], target = 8<br /><b>输出：</b>[[2,2,2,2]]</p></blockquote><p>提示：</p><ul><li><p><span class="math inline">\(1 &lt;= nums.length &lt;=200\)</span></p></li><li><p><span class="math inline">\(-10^9 &lt;= nums[i] &lt;=10^9\)</span></p></li><li><p><span class="math inline">\(-10^9 &lt;= target &lt;=10^9\)</span></p></li></ul><hr /><p>以下是题解：</p><h3 id="解题思路">解题思路:</h3><p><b>排序 + 双指针</b></p><p>基本思路与又是与(<ahref="/2023/08/29/LeetCode_15/">LeetCode_15——三数之和</a>)十分相似，因此在这里附上代码，具体思路详见(<ahref="/2023/08/29/LeetCode_15/">LeetCode_15——三数之和</a>)。</p><p>代码如下：</p><blockquote><p>这里做了一部分优化，可省去</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> a = <span class="number">0</span>; a &lt; n - <span class="number">3</span>; a++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> x = nums[a];</span><br><span class="line">            <span class="keyword">if</span>(a &amp;&amp; x == nums[a - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(x + nums[a + <span class="number">1</span>] + nums[a + <span class="number">2</span>] + nums[a + <span class="number">3</span>] &gt; target) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(x + nums[n - <span class="number">1</span>] + nums[n - <span class="number">2</span>] + nums[n - <span class="number">3</span>] &lt; target) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> b = a + <span class="number">1</span>; b &lt; n - <span class="number">2</span>; b++)&#123;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> y = nums[b];</span><br><span class="line">                <span class="keyword">if</span>(b &gt; a + <span class="number">1</span> &amp;&amp; y == nums[b - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(x + y + nums[b + <span class="number">1</span>] + nums[b + <span class="number">2</span>] &gt; target) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span>(x + y + nums[n - <span class="number">1</span>] + nums[n - <span class="number">2</span>] &lt; target) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> c = b + <span class="number">1</span>, d = n - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(c &lt; d) &#123;</span><br><span class="line">                    <span class="type">long</span> <span class="type">long</span> s = x + y + nums[c] + nums[d];</span><br><span class="line">                    <span class="keyword">if</span>(s &gt; target) d--;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(s &lt; target) c++;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        ans.<span class="built_in">push_back</span>(&#123;(<span class="type">int</span>)x, (<span class="type">int</span>)y, nums[c], nums[d]&#125;);</span><br><span class="line">                        <span class="keyword">for</span>(++c; c &lt; d &amp;&amp; nums[c] == nums[c - <span class="number">1</span>]; ++c);</span><br><span class="line">                        <span class="keyword">for</span>(--d; c &lt; d &amp;&amp; nums[c] == nums[d + <span class="number">1</span>]; --d);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPwMk7t"><imgsrc="https://s1.ax1x.com/2023/08/30/pPwMk7t.png"alt="pPwMk7t.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/30 22:45:26</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode题解——17.电话号码的字母组合</title>
      <link href="/2023/08/30/LeetCode_17/"/>
      <url>/2023/08/30/LeetCode_17/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="最接近的三数之和">最接近的三数之和</h2><h3 id="题目预览">题目预览：</h3><p>给定一个仅包含数字 <span class="math inline">\(2-9\)</span>的字符串，返回所有它能表示的字母组合。答案可以按 <b>任意顺序</b>返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 <spanclass="math inline">\(1\)</span> 不对应任何字母。</p><p><a href="https://imgse.com/i/pPwSLPP"><imgsrc="https://s1.ax1x.com/2023/08/30/pPwSLPP.png"alt="pPwSLPP.png" /></a></p><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>digits = "23"<br /><b>输出：</b>["ad","ae","af","bd","be","bf","cd","ce","cf"]</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>digits = ""<br /><b>输出：</b>[]</p></blockquote><h4 id="示例-3">示例 3：</h4><blockquote><p><b>输入：</b>digits = "2"<br /><b>输出：</b>["a","b","c"]</p></blockquote><p>提示：</p><ul><li><span class="math inline">\(0 &lt;= digits.length &lt;=4\)</span></li><li><span class="math inline">\(digits[i]\)</span> 是范围 <spanclass="math inline">\([&#39;2&#39;, &#39;9&#39;]\)</span>的一个数字。</li></ul><hr /><p>以下是题解：</p><h3 id="解题思路递归">解题思路:递归</h3><p>本题思路较清晰，对于每一位数字，均有与之相对应的 <spanclass="math inline">\(3/4\)</span>种情况，我们只需递归每一种状态即可。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> Len=<span class="number">0</span>;</span><br><span class="line">    string Digits=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Tel</span><span class="params">(<span class="type">int</span> tags,string str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tags==Len)</span><br><span class="line">            ans.<span class="built_in">push_back</span>(str);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> num=Digits[tags]-<span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(num==<span class="number">5</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">Tel</span>(tags+<span class="number">1</span>,str+<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">                <span class="built_in">Tel</span>(tags+<span class="number">1</span>,str+<span class="string">&#x27;q&#x27;</span>);</span><br><span class="line">                <span class="built_in">Tel</span>(tags+<span class="number">1</span>,str+<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">                <span class="built_in">Tel</span>(tags+<span class="number">1</span>,str+<span class="string">&#x27;s&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num==<span class="number">6</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">Tel</span>(tags+<span class="number">1</span>,str+<span class="string">&#x27;t&#x27;</span>);</span><br><span class="line">                <span class="built_in">Tel</span>(tags+<span class="number">1</span>,str+<span class="string">&#x27;u&#x27;</span>);</span><br><span class="line">                <span class="built_in">Tel</span>(tags+<span class="number">1</span>,str+<span class="string">&#x27;v&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num==<span class="number">7</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">Tel</span>(tags+<span class="number">1</span>,str+<span class="string">&#x27;w&#x27;</span>);</span><br><span class="line">                <span class="built_in">Tel</span>(tags+<span class="number">1</span>,str+<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">                <span class="built_in">Tel</span>(tags+<span class="number">1</span>,str+<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">                <span class="built_in">Tel</span>(tags+<span class="number">1</span>,str+<span class="string">&#x27;z&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">Tel</span>(tags+<span class="number">1</span>,str+<span class="built_in">char</span>(<span class="string">&#x27;a&#x27;</span>+num*<span class="number">3</span>));</span><br><span class="line">                <span class="built_in">Tel</span>(tags+<span class="number">1</span>,str+<span class="built_in">char</span>(<span class="string">&#x27;b&#x27;</span>+num*<span class="number">3</span>));</span><br><span class="line">                <span class="built_in">Tel</span>(tags+<span class="number">1</span>,str+<span class="built_in">char</span>(<span class="string">&#x27;c&#x27;</span>+num*<span class="number">3</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        Digits=digits;</span><br><span class="line">        <span class="keyword">if</span>(digits==<span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        Len=digits.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">Tel</span>(<span class="number">0</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPwSb5t"><imgsrc="https://s1.ax1x.com/2023/08/30/pPwSb5t.png"alt="pPwSb5t.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/30 17:32:15</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode题解——1654.到家的最少跳跃次数</title>
      <link href="/2023/08/30/LeetCode_1654/"/>
      <url>/2023/08/30/LeetCode_1654/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="到家的最少跳跃次数">到家的最少跳跃次数</h2><h3 id="题目预览">题目预览：</h3><p>有一只跳蚤的家在数轴上的位置 <span class="math inline">\(x\)</span>处。请你帮助它从位置 <span class="math inline">\(0\)</span>出发，到达它的家。</p><p>跳蚤跳跃的规则如下：</p><ul><li>它可以 <b>往前</b> 跳恰好 <span class="math inline">\(a\)</span>个位置（即往右跳）。<br /></li><li>它可以 <b>往后</b> 跳恰好 <span class="math inline">\(b\)</span>个位置（即往左跳）。</li><li>它不能 <b>连续</b> 往后跳 <span class="math inline">\(2\)</span>次。</li><li>它不能跳到任何 <span class="math inline">\(forbidden\)</span>数组中的位置。</li><li>跳蚤可以往前跳 <b>超过</b> 它的家的位置，但是它<b>不能跳到负整数</b> 的位置。</li></ul><p>给你一个整数数组 forbidden ，其中 forbidden[i]是跳蚤不能跳到的位置，同时给你整数 a， b 和 x，请你返回跳蚤到家的最少跳跃次数。如果没有恰好到达 x的可行方案，请你返回 -1 。</p><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>forbidden = [14,4,18,1,15], a = 3, b = 15, x = 9<br /><b>输出：</b>3<br /><b>解释：</b>往前跳 3 次（0 -&gt; 3 -&gt; 6 -&gt;9），跳蚤就到家了。</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>forbidden = [8,3,16,6,12,20], a = 15, b = 13, x =11<br /><b>输出：</b>-1</p></blockquote><h4 id="示例-3">示例 3：</h4><blockquote><p><b>输入：</b>forbidden = [1,6,2,14,5,17,4], a = 16, b = 9, x =7<br /><b>输出：</b>2<br /><b>解释：</b>往前跳一次（0 -&gt; 16），然后往回跳一次（16 -&gt;7），跳蚤就到家了。</p></blockquote><p>提示：</p><ul><li><span class="math inline">\(1 &lt;= forbidden.length &lt;=1000\)</span></li><li><span class="math inline">\(1 &lt;= a, b, forbidden[i] &lt;=2000\)</span></li><li><span class="math inline">\(0 &lt;= x &lt;= 2000\)</span></li><li><span class="math inline">\(forbidden\)</span>中所有位置互不相同。</li><li>位置 <span class="math inline">\(x\)</span> 不在 <spanclass="math inline">\(forbidden\)</span> 中。</li></ul><hr /><p>以下是题解：</p><h3 id="解题思路">解题思路:</h3><p>由于我们可以超出家的位置，最短路算法可能超时，故我们需要减小搜索范围。可以证明，一定可以在 <spanclass="math inline">\([0,max⁡(f+a+b,x+b)]\)</span>的下标范围内找到最优解，其中 <span class="math inline">\(f\)</span>是最远的禁止点的坐标。因为 <spanclass="math inline">\(f,a,b,x≤2000\)</span> ，故搜索范围不会超过 <spanclass="math inline">\(6000\)</span>。</p><p>后续证明需要考虑一些细节问题，但意会后是很简单的：如果最优路径是出界的，可以调整前后跳的顺序让其不出界。（想象一条长绳子，起点和终点固定，嫌它太长所以把它折起来放）</p><p><b>详细证明：</b></p><p>如果 <span class="math inline">\(a≥b\)</span> ， 那么当跳蚤跳到大于<span class="math inline">\(x+b\)</span>的位置时，最多只能后跳一次，但是无法到达 <spanclass="math inline">\(x\)</span>，而在之后的跳跃中，最 “保守”的跳法也是前跳一次，后跳一次，无法更加接近 <spanclass="math inline">\(x\)</span>。故此时的最大搜索下标是 <spanclass="math inline">\(x+b\)</span>。</p><p>证明 <span class="math inline">\(a&lt;b\)</span> 的情况： 可以证明当<span class="math inline">\(a&lt;b\)</span> 时搜索的右边界为 <spanclass="math inline">\(max⁡(f+a+b,x)\)</span> 。</p><p>首先把整个数轴分为 <span class="math inline">\(3\)</span> 段：</p><ul><li><p>非安全区：<span class="math inline">\([0,f]\)</span>。“非安全区”指区域内会有禁止（forbidden）点。</p></li><li><p>安全区（界内）：<spanclass="math inline">\((f,max⁡(f+a+b,x)]\)</span>。注意家的位置也包含在界内。</p></li><li><p>出界区：<span class="math inline">\((max⁡(f+a+b,x),+∞)\)</span>。</p></li></ul><p>假设某个 <b>跳跃次数最少</b> 的路径中，<spanclass="math inline">\(C\)</span> 点是 <b>第一个</b> 出界的点，<spanclass="math inline">\(H\)</span> 点是 <b>第一个</b>返回界内的点（注意我们把跳蚤的家的位置 <spanclass="math inline">\(x\)</span>也划入了界内，因此跳蚤为了回家必须返回界内），如下图所示。图中，横坐标是跳跃次数，纵坐标是跳蚤与原点的距离。</p><p><a href="https://imgse.com/i/pPdOxKA"><imgsrc="https://s1.ax1x.com/2023/08/30/pPdOxKA.png"alt="pPdOxKA.png" /></a></p><p>为了让 <span class="math inline">\(C\)</span>点不再出界，我们只需交换线段 <span class="math inline">\(BC\)</span> 和线段 <span class="math inline">\(GH\)</span>（也就是说，将第 <spanclass="math inline">\(i + 1\)</span> 次跳跃变为后跳，而将第 <spanclass="math inline">\(i+6\)</span>次跳跃变为前跳）即可，如下图所示：</p><p><a href="https://imgse.com/i/pPdXFPS"><imgsrc="https://s1.ax1x.com/2023/08/30/pPdXFPS.png"alt="pPdXFPS.png" /></a></p><p>下面从 <span class="math inline">\(3\)</span>个方面论证这次交换的可行性：</p><ol type="1"><li><p>交换之前，C,D,E,F,G 点都出界，与原点的距离 <spanclass="math inline">\(l&gt;f+a+b\)</span> ；交换之后它们与原点的距离变为<span class="math inline">\(l−(a+b)\)</span>&gt;f$。也就是说，交换后，这些点没有踩到 forbidden 点的风险；</p></li><li><p>交换没有增加跳跃的次数，跳跃次数仍为最优；</p></li><li><p>交换不会造成两次后跳。这是因为跳蚤一定是通过 <b>前跳</b> 到达的<span class="math inline">\(B\)</span> 点。反证：如果跳蚤是通过后跳跳到<span class="math inline">\(B\)</span> 点的，那么 <spanclass="math inline">\(B\)</span> 点的前一个点 <spanclass="math inline">\(A′\)</span> 一定位于出界区（因为 <spanclass="math inline">\(b&gt;a\)</span> ），与假设（<spanclass="math inline">\(C\)</span> 点是 <b>第一个</b>出界的点）矛盾。</p></li></ol><p>因此，我们可以不断寻找 <b>第一次出界</b>的点，然后按上面的模式进行交换，使其不再出界，最终让所有的点不再出界，位于<span class="math inline">\([0,max⁡(f+a+b,x)]\)</span> 的范围内。</p><p>综合 <span class="math inline">\(a≥b\)</span> 和 <spanclass="math inline">\(a&lt;b\)</span> 的情况，我们可以得出搜索的上界<span class="math inline">\(=max⁡(f+a+b,x+b)\)</span>。</p><p>有了上面的结论，我们可以随便用一种最短路解法来求解该问题。下面的<span class="math inline">\(BFS\)</span>代码供参考；也可参考其它题解的方法。注意为了避免两次后跳，我们需要在<span class="math inline">\(BFS\)</span>中保存上一次是前跳还是后跳。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumJumps</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; forbidden, <span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> F = *<span class="built_in">max_element</span>(forbidden.<span class="built_in">begin</span>(), forbidden.<span class="built_in">end</span>()), bound = <span class="built_in">max</span>(F + a + b, x + b);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ban[bound + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(ban, <span class="number">0</span>, <span class="built_in">sizeof</span>(ban));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> f : forbidden) &#123;</span><br><span class="line">            ban[f] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> dist[bound + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dist));</span><br><span class="line">        dist[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; <span class="built_in">q</span>(&#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;&#125;);</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [i, pre] = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(i == x) &#123;</span><br><span class="line">                <span class="keyword">return</span> dist[i][pre];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pre == <span class="number">0</span> &amp;&amp; i-b &gt;= <span class="number">0</span> &amp;&amp; !ban[i-b] &amp;&amp; dist[i][pre] + <span class="number">1</span> &lt; dist[i-b][<span class="number">1</span>]) &#123;</span><br><span class="line">                dist[i-b][<span class="number">1</span>] = dist[i][pre] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">emplace</span>(i-b, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i+a &lt;= bound &amp;&amp; !ban[i+a] &amp;&amp; dist[i][pre] + <span class="number">1</span> &lt; dist[i+a][<span class="number">0</span>]) &#123;</span><br><span class="line">                dist[i+a][<span class="number">0</span>] = dist[i][pre] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">emplace</span>(i+a, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPdX2Zt"><imgsrc="https://s1.ax1x.com/2023/08/30/pPdX2Zt.png"alt="pPdX2Zt.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/30 15:17:06</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode题解 </tag>
            
            <tag> LeetCode每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode题解——16.最接近的三数之和</title>
      <link href="/2023/08/29/LeetCode_16/"/>
      <url>/2023/08/29/LeetCode_16/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="最接近的三数之和">最接近的三数之和</h2><h3 id="题目预览">题目预览：</h3><p>给你一个长度为 <span class="math inline">\(n\)</span> 的整数数组<span class="math inline">\(nums\)</span> 和 一个目标值 <spanclass="math inline">\(target\)</span>。请你从 <spanclass="math inline">\(nums\)</span> 中选出三个整数，使它们的和与 <spanclass="math inline">\(target\)</span> 最接近。</p><p>返回这三个数的和。</p><p>假定每组输入只存在恰好一个解。</p><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>nums = [-1,2,1,-4], target = 1<br /><b>输出：</b>2<br /><b>解释：</b>与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>nums = [0,0,0], target = 1<br /><b>输出：</b>0</p></blockquote><p>提示：</p><ul><li><p><span class="math inline">\(3 &lt;= nums.length &lt;=1000\)</span></p></li><li><p><span class="math inline">\(-1000 &lt;= nums[i] &lt;=1000\)</span></p></li><li><p><span class="math inline">\(-10^4 &lt;= target &lt;=10^4\)</span></p></li></ul><hr /><p>以下是题解：</p><h3 id="解题思路">解题思路:</h3><p><b>排序 + 双指针</b></p><p>基本思路与前一题(<ahref="/2023/08/29/LeetCode_15/">LeetCode_15——三数之和</a>)类似</p><p>除此以外，还有以下几个优化：</p><p>设 <span class="math inline">\(s=nums[i]+nums[i+1]+nums[i+2]\)</span>。如果 <span class="math inline">\(s&gt;target\)</span>，由于数组已经排序，后面无论怎么选，选出的三个数的和不会比 <spanclass="math inline">\(s\)</span> 还小，所以不会找到比 <spanclass="math inline">\(s\)</span> 更优的答案了。所以只要 <spanclass="math inline">\(s&gt;target\)</span> ，就可以直接 <spanclass="math inline">\(break\)</span> 外层循环了。在 <spanclass="math inline">\(break\)</span> 前判断 <spanclass="math inline">\(s\)</span> 是否离 <spanclass="math inline">\(target\)</span> 更近，如果更近，那么更新答案为<span class="math inline">\(s\)</span>。</p><p>设 <span class="math inline">\(s=nums[i]+nums[n−2]+nums[n−1]\)</span>。如果 <span class="math inline">\(s&lt;targets\)</span>，由于数组已经排序，<span class="math inline">\(nums[i]\)</span>加上后面任意两个数都不超过 <spanclass="math inline">\(s\)</span>，所以下面的双指针就不需要跑了，无法找到比<span class="math inline">\(s\)</span> 更优的答案。但是后面还有更大的<span class="math inline">\(nums[i]\)</span> ，可能找到一个离 <spanclass="math inline">\(target\)</span>更近的三数之和，所以还需要继续枚举，<spanclass="math inline">\(continue\)</span> 外层循环。在 <spanclass="math inline">\(continue\)</span> 前判断 <spanclass="math inline">\(s\)</span> 是否离 <spanclass="math inline">\(target\)</span> 更近，如果更近，那么更新答案为<span class="math inline">\(s\)</span></p><p>如果 <span class="math inline">\(i&gt;0\)</span> 且 <spanclass="math inline">\(nums[i]=nums[i−1]\)</span> ，那么 <spanclass="math inline">\(nums[i]\)</span>和后面数字相加的结果，必然在之前算出过，所以无需跑下面的双指针，直接<span class="math inline">\(continue\)</span>外层循环。（可以放在循环开头判断。）</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">threeSumClosest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> Len=nums.<span class="built_in">size</span>(),ans=<span class="number">1e7</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Len<span class="number">-2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> Left=i+<span class="number">1</span>,Right=Len<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(Left&lt;Right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> sum=nums[i]+nums[Left]+nums[Right];</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(sum-target)&lt;<span class="built_in">abs</span>(ans-target))</span><br><span class="line">                    ans=sum;</span><br><span class="line">                <span class="keyword">if</span>(sum&gt;target)</span><br><span class="line">                    Right--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;target)</span><br><span class="line">                    Left++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> target;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPdteiR"><imgsrc="https://s1.ax1x.com/2023/08/29/pPdteiR.png"alt="pPdteiR.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/29 22:10:55</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode题解——823.带因子的二叉树</title>
      <link href="/2023/08/29/LeetCode_823/"/>
      <url>/2023/08/29/LeetCode_823/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="带因子的二叉树">带因子的二叉树</h2><h3 id="题目预览">题目预览：</h3><p>给出一个含有不重复整数元素的数组 <spanclass="math inline">\(arr\)</span> ，每个整数 <spanclass="math inline">\(arr[i]\)</span> 均大于 <spanclass="math inline">\(1\)</span>。</p><p>用这些整数来构建二叉树，每个整数可以使用任意次数。其中：每个非叶结点的值应等于它的两个子结点的值的乘积。</p><p>满足条件的二叉树一共有多少个？答案可能很大，返回 <b>对 <spanclass="math inline">\(10^9 + 7\)</span> 取余</b> 的结果。</p><h4 id="示例-1">示例 1:</h4><blockquote><p><b>输入:</b> arr = [2, 4]<br /><b>输出:</b> 3<br /><b>解释:</b> 可以得到这些二叉树: [2], [4], [4, 2, 2]</p></blockquote><h4 id="示例-2">示例 2:</h4><blockquote><p><b>输入:</b> arr = [2, 4, 5, 10]<br /><b>输出:</b> 7<br /><b>解释:</b> 可以得到这些二叉树: [2], [4], [5], [10], [4, 2, 2], [10, 2,5], [10, 5, 2].</p></blockquote><p>提示：</p><ul><li><p><span class="math inline">\(1 &lt;= arr.length &lt;=1000\)</span></p></li><li><p><span class="math inline">\(2 &lt;= arr[i] &lt;=10^9\)</span></p></li><li><p><span class="math inline">\(arr\)</span> 中的所有值<b>互不相同</b></p></li></ul><hr /><p>以下是题解：</p><h3 id="思路-递推">思路: 递推</h3><p>对于每个根节点，由题意可以确定其值一定大于它的任意一个子节点，因此我们可以先将容器按<b>升序</b> 排序，然后依次计算其中的数据：</p><ul><li><p>我们可以直接停止构建，此时二叉树只有一个根节点，这算 <spanclass="math inline">\(1\)</span> 个方案。</p></li><li><p>记 <span class="math inline">\(val=arr[i]\)</span> 。枚举 <spanclass="math inline">\(x=arr[j]\)</span> ，如果 <spanclass="math inline">\(val\)</span> 能被 <spanclass="math inline">\(x\)</span> 整除且 <spanclass="math inline">\(\frac{val}{x}\)</span> 在 <spanclass="math inline">\(arr\)</span> 中（设其下标为 <spanclass="math inline">\(k\)</span>），那么分解 <spanclass="math inline">\(val=x×\frac{val}{x}\)</span> ，方案数等于 <spanclass="math inline">\(f[j]×f[k]\)</span> 。</p></li><li><p>把这些方案数全部加起来，就得到了 <spanclass="math inline">\(f[i]\)</span> 。</p></li><li><p>由于 <span class="math inline">\(j&lt;i\)</span> 且 <spanclass="math inline">\(k&lt;i\)</span> ，我们要从小到大遍历计算每个状态<span class="math inline">\(f[i]\)</span> 。</p></li></ul><p>初始值：所有 <span class="math inline">\(f[i]\)</span> 都初始化成<span class="math inline">\(1\)</span> 。</p><p>答案为: <span class="math inline">\(\sum_{n-1}^{i=0}f[i]\)</span></p><p>代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numFactoredBinaryTrees</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> Mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">        <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> Len=arr.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; idx;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            idx[arr[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;<span class="built_in">f</span>(Len,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> val=arr[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> tmp=arr[j];</span><br><span class="line">                <span class="keyword">if</span>(val%tmp==<span class="number">0</span>&amp;&amp;idx.<span class="built_in">count</span>(val/tmp))</span><br><span class="line">                    f[i]+=f[j]*f[idx[val/tmp]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">accumulate</span>(f.<span class="built_in">begin</span>(),f.<span class="built_in">end</span>(),<span class="number">0LL</span>)%Mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPaHwDK"><imgsrc="https://s1.ax1x.com/2023/08/29/pPaHwDK.png"alt="pPaHwDK.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/29 13:06:24</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode题解 </tag>
            
            <tag> LeetCode每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode题解——15.三数之和</title>
      <link href="/2023/08/29/LeetCode_15/"/>
      <url>/2023/08/29/LeetCode_15/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="三数之和">三数之和</h2><h3 id="题目预览">题目预览：</h3><p>给你一个整数数组 <span class="math inline">\(nums\)</span>，判断是否存在三元组 <span class="math inline">\([nums[i], nums[j],nums[k]]\)</span> 满足 <span class="math inline">\(i !=j\)</span>、<span class="math inline">\(i != k\)</span> 且 <spanclass="math inline">\(j != k\)</span> ，同时还满足 <spanclass="math inline">\(nums[i] + nums[j] + nums[k] == 0\)</span> 。请</p><p>你返回所有和为 <span class="math inline">\(0\)</span>且不重复的三元组。</p><p><b>注意：</b>答案中不可以包含重复的三元组。</p><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>nums = [-1,0,1,2,-1,-4]<br /><b>输出：</b>[[-1,-1,2],[-1,0,1]]<br /><b>解释：</b><br />nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。<br />nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。<br />nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。<br />不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。<br />注意，输出的顺序和三元组的顺序并不重要。</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>nums = [0,1,1]<br /><b>输出：</b>[]<br /><b>解释：</b>唯一可能的三元组和不为 0 。</p></blockquote><h4 id="示例-3">示例 3：</h4><blockquote><p><b>输入：</b>nums = [0,0,0]<br /><b>输出：</b>[[0,0,0]]<br /><b>解释：</b>唯一可能的三元组和为 0 。</p></blockquote><p>提示：</p><ul><li><span class="math inline">\(3 &lt;= nums.length &lt;=3000\)</span></li><li><span class="math inline">\(-10^5 &lt;= nums[i] &lt;=10^5\)</span></li></ul><hr /><p>以下是题解：</p><h3 id="解题思路">解题思路:</h3><p><b>排序 + 双指针</b></p><p>本题的难点在于 <b>如何去除重复解</b> 。</p><h4 id="算法流程">算法流程：</h4><ol type="1"><li><p>特判，对于数组长度 <spanclass="math inline">\(n\)</span>，如果数组为 <spanclass="math inline">\(null\)</span> 或者数组长度小于 <spanclass="math inline">\(3\)</span>，返回 <spanclass="math inline">\([]\)</span>。</p></li><li><p>对数组进行排序。</p></li><li><p>遍历排序后数组：</p><ul><li><p>若 <spanclass="math inline">\(nums[i]&gt;0\)</span>：因为已经排序好，所以后面不可能有三个数加和等于<span class="math inline">\(0\)</span>，直接返回结果。</p></li><li><p>对于重复元素：跳过，避免出现重复解</p></li><li><p>令左指针 <span class="math inline">\(Left=i+1\)</span>，右指针<span class="math inline">\(Right=n−1\)</span>，当 <spanclass="math inline">\(Left&lt;Right\)</span> 时，执行循环：</p><ul><li><p>当 <spanclass="math inline">\(nums[i]+nums[Left]+nums[Right]==0\)</span>，执行循环，判断左界和右界是否和下一位置重复，去除重复解。并同时将<span class="math inline">\(Left,Right\)</span>移到下一位置，寻找新的解</p></li><li><p>若和大于 <span class="math inline">\(0\)</span>，说明 <spanclass="math inline">\(nums[Right]\)</span> 太大，<spanclass="math inline">\(Right\)</span> 左移</p></li><li><p>若和小于 <span class="math inline">\(0\)</span>，说明 <spanclass="math inline">\(nums[Left]\)</span> 太小，<spanclass="math inline">\(Left\)</span> 右移</p></li></ul></li></ul></li></ol><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="type">int</span> Len=nums.<span class="built_in">size</span>(),Left=<span class="number">0</span>,Right=<span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(Len&lt;<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i<span class="number">-1</span>]==nums[i])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                Left=i+<span class="number">1</span>,Right=Len<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span>(Left&lt;Right)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> x=nums[i],y=nums[Left],z=nums[Right];</span><br><span class="line">                    <span class="keyword">if</span>(x+y+z==<span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        ans.<span class="built_in">push_back</span>(&#123;nums[i],nums[Left],nums[Right]&#125;);</span><br><span class="line">                        <span class="keyword">while</span>(Left&lt;Right&amp;&amp;y==nums[Left+<span class="number">1</span>])</span><br><span class="line">                            Left++;</span><br><span class="line">                        <span class="keyword">while</span>(Left&lt;Right&amp;&amp;nums[Right<span class="number">-1</span>]==z)</span><br><span class="line">                            Right--;</span><br><span class="line">                        Left++;</span><br><span class="line">                        Right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(x+y+z&gt;<span class="number">0</span>)</span><br><span class="line">                        Right--;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        Left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i+<span class="number">1</span>&lt;Len&amp;&amp;nums[i]==nums[i+<span class="number">1</span>])</span><br><span class="line">                i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPaR2wR"><imgsrc="https://s1.ax1x.com/2023/08/29/pPaR2wR.png"alt="pPaR2wR.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/29 09:09:05</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode题解——14.最长公共前缀</title>
      <link href="/2023/08/28/LeetCode_14/"/>
      <url>/2023/08/28/LeetCode_14/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="最长公共前缀">最长公共前缀</h2><h3 id="题目预览">题目预览：</h3><p>编写一个函数来查找字符串数组中的 <b>最长公共前缀</b> 。</p><p>如果不存在公共前缀，返回空字符串 <code>""</code>。</p><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>strs = ["flower","flow","flight"] <b>输出：</b>"fl"</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>strs = ["dog","racecar","car"] <b>输出：</b>""<b>解释：</b>输入不存在公共前缀。</p></blockquote><p>提示：</p><ul><li><p><span class="math inline">\(1 &lt;= strs.length &lt;=200\)</span></p></li><li><p><span class="math inline">\(0 &lt;= strs[i].length &lt;=200\)</span></p></li><li><p><span class="math inline">\(strs[i]仅由小写英文字母组成\)</span></p></li></ul><hr /><p>以下是题解：</p><h3 id="解题思路">解题思路:</h3><p>本题思路较清晰，对于若干个字符串，我们可以先储存第一个的字符串的字符，然后依次比较后面字符串的相应部分。</p><p>特殊情况包括： 1. 字符串容器为空：返回<code>""</code> 2.字符串为空：返回<code>""</code></p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> Len=strs.<span class="built_in">size</span>(),tag=<span class="number">0</span>,flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(Len==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(strs[<span class="number">0</span>]==<span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        string ans=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">char</span> tmp=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        flag=strs[<span class="number">0</span>].<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">while</span>(tag&lt;flag)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp=strs[<span class="number">0</span>][tag];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;Len;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(tag&gt;=strs[i].<span class="built_in">length</span>())</span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">                <span class="keyword">if</span>(strs[i][tag]!=tmp)</span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">            ans+=tmp;</span><br><span class="line">            tag++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPaNpVJ"><imgsrc="https://s1.ax1x.com/2023/08/28/pPaNpVJ.png"alt="pPaNpVJ.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/28 20:46:08</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode题解——13.罗马数字转整数</title>
      <link href="/2023/08/28/LeetCode_13/"/>
      <url>/2023/08/28/LeetCode_13/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="罗马数字转整数">罗马数字转整数</h2><h3 id="题目预览">题目预览：</h3><p>罗马数字包含以下七种字符: <spanclass="math inline">\(I\)</span>，<spanclass="math inline">\(V\)</span>，<spanclass="math inline">\(X\)</span>，<spanclass="math inline">\(L\)</span>，<spanclass="math inline">\(C\)</span>，<span class="math inline">\(D\)</span>和 <span class="math inline">\(M\)</span>。</p><table><thead><tr class="header"><th style="text-align: center;">字符</th><th style="text-align: center;">数值</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">I</td><td style="text-align: center;">1</td></tr><tr class="even"><td style="text-align: center;">V</td><td style="text-align: center;">5</td></tr><tr class="odd"><td style="text-align: center;">X</td><td style="text-align: center;">10</td></tr><tr class="even"><td style="text-align: center;">L</td><td style="text-align: center;">50</td></tr><tr class="odd"><td style="text-align: center;">C</td><td style="text-align: center;">100</td></tr><tr class="even"><td style="text-align: center;">D</td><td style="text-align: center;">500</td></tr><tr class="odd"><td style="text-align: center;">M</td><td style="text-align: center;">1000</td></tr></tbody></table><p>例如， 罗马数字 <span class="math inline">\(2\)</span> 写做 <spanclass="math inline">\(II\)</span> ，即为两个并列的 <spanclass="math inline">\(1\)</span>。<spanclass="math inline">\(12\)</span> 写做 <spanclass="math inline">\(XII\)</span> ，即为 <span class="math inline">\(X+ II\)</span> 。 <span class="math inline">\(27\)</span> 写做 <spanclass="math inline">\(XXVII\)</span>, 即为 <spanclass="math inline">\(XX + V + II\)</span> 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如<span class="math inline">\(4\)</span> 不写做 <spanclass="math inline">\(IIII\)</span>，而是 <spanclass="math inline">\(IV\)</span>。数字 <spanclass="math inline">\(1\)</span> 在数字 <spanclass="math inline">\(5\)</span> 的左边，所表示的数等于大数 <spanclass="math inline">\(5\)</span> 减小数 <spanclass="math inline">\(1\)</span> 得到的数值 <spanclass="math inline">\(4\)</span> 。同样地，数字 <spanclass="math inline">\(9\)</span> 表示为 <spanclass="math inline">\(IX\)</span>。这个特殊的规则只适用于以下六种情况：</p><ul><li><p><span class="math inline">\(I\)</span> 可以放在 <spanclass="math inline">\(V\ (5)\)</span> 和 <span class="math inline">\(X\(10)\)</span> 的左边，来表示 <span class="math inline">\(4\)</span> 和<span class="math inline">\(9\)</span>。</p></li><li><p><span class="math inline">\(X\)</span> 可以放在 <spanclass="math inline">\(L\ (50)\)</span> 和 <span class="math inline">\(C\(100)\)</span> 的左边，来表示 <span class="math inline">\(40\)</span> 和<span class="math inline">\(90\)</span>。</p></li><li><p><span class="math inline">\(C\)</span> 可以放在 <spanclass="math inline">\(D\ (500)\)</span> 和 <spanclass="math inline">\(M\ (1000)\)</span> 的左边，来表示 <spanclass="math inline">\(400\)</span> 和 <spanclass="math inline">\(900\)</span>。</p></li></ul><p>给定一个罗马数字，将其转换成整数。</p><h4 id="示例-1">示例 1:</h4><blockquote><p><b>输入:</b> s = "III"<br /><b>输出:</b> 3</p></blockquote><h4 id="示例-2">示例 2:</h4><blockquote><p><b>输入:</b> s = "IV"<br /><b>输出:</b> 4</p></blockquote><h4 id="示例-3">示例 3:</h4><blockquote><p><b>输入:</b> s = "IX"<br /><b>输出:</b> 9</p></blockquote><h4 id="示例-4">示例 4:</h4><blockquote><p><b>输入:</b> s = "LVIII"<br /><b>输出:</b> 58<br /><b>解释:</b> L = 50, V= 5, III = 3.</p></blockquote><h4 id="示例-5">示例 5:</h4><blockquote><p><b>输入:</b> s = "MCMXCIV"<br /><b>输出:</b> 1994<br /><b>解释:</b> M = 1000, CM = 900, XC = 90, IV = 4.</p></blockquote><p>提示：</p><ul><li><p><span class="math inline">\(1 &lt;= s.length &lt;=15\)</span></p></li><li><p><span class="math inline">\(s 仅含字符 (&#39;I&#39;, &#39;V&#39;,&#39;X&#39;, &#39;L&#39;, &#39;C&#39;, &#39;D&#39;,&#39;M&#39;)\)</span></p></li><li><p>题目数据保证 <span class="math inline">\(s\)</span>是一个有效的罗马数字，且表示整数在范围 <span class="math inline">\([1,3999]\)</span> 内</p></li><li><p>题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。</p></li><li><p><span class="math inline">\(IL\)</span> 和 <spanclass="math inline">\(IM\)</span> 这样的例子并不符合题目要求，<spanclass="math inline">\(49\)</span> 应该写作 <spanclass="math inline">\(XLIX\)</span> ，<spanclass="math inline">\(999\)</span> 应该写作 <spanclass="math inline">\(CMXCIX\)</span> 。</p></li></ul><hr /><p>以下是题解：</p><h3 id="解题思路">解题思路:</h3><p>该题与前一题(<ahref="/2023/08/28/LeetCode_12/">LeetCode_12——整数转罗马数字</a>)十分相似，过程也完全是之前的逆过程，由此我们可以轻松得出相应的计算过程，即：依次遍历每一个字符，对于一些特殊字符（如<spanclass="math inline">\(I\)</span>，<spanclass="math inline">\(X\)</span>，<spanclass="math inline">\(C\)</span>），我们多搜索一位以进行匹配。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">romanToInt</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> Len=s.<span class="built_in">length</span>(),Num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i+<span class="number">1</span>]==<span class="string">&#x27;V&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Num+=<span class="number">4</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s[i+<span class="number">1</span>]==<span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Num+=<span class="number">9</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    Num+=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;V&#x27;</span>)</span><br><span class="line">                Num+=<span class="number">5</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i+<span class="number">1</span>]==<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Num+=<span class="number">40</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s[i+<span class="number">1</span>]==<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Num+=<span class="number">90</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    Num+=<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">                Num+=<span class="number">50</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i+<span class="number">1</span>]==<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Num+=<span class="number">400</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s[i+<span class="number">1</span>]==<span class="string">&#x27;M&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Num+=<span class="number">900</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    Num+=<span class="number">100</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">                Num+=<span class="number">500</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;M&#x27;</span>)</span><br><span class="line">                Num+=<span class="number">1000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPaG9pT"><imgsrc="https://s1.ax1x.com/2023/08/28/pPaG9pT.png"alt="pPaG9pT.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/28 19:46:48</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode题解——12.整数转罗马数字</title>
      <link href="/2023/08/28/LeetCode_12/"/>
      <url>/2023/08/28/LeetCode_12/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="整数转罗马数字">整数转罗马数字</h2><h3 id="题目预览">题目预览：</h3><p>罗马数字包含以下七种字符： <span class="math inline">\(I\)</span>，<span class="math inline">\(V\)</span>， <spanclass="math inline">\(X\)</span>， <spanclass="math inline">\(L\)</span>，<spanclass="math inline">\(C\)</span>，<span class="math inline">\(D\)</span>和 <span class="math inline">\(M\)</span>。</p><table><thead><tr class="header"><th style="text-align: center;">字符</th><th style="text-align: center;">数值</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">I</td><td style="text-align: center;">1</td></tr><tr class="even"><td style="text-align: center;">V</td><td style="text-align: center;">5</td></tr><tr class="odd"><td style="text-align: center;">X</td><td style="text-align: center;">10</td></tr><tr class="even"><td style="text-align: center;">L</td><td style="text-align: center;">50</td></tr><tr class="odd"><td style="text-align: center;">C</td><td style="text-align: center;">100</td></tr><tr class="even"><td style="text-align: center;">D</td><td style="text-align: center;">500</td></tr><tr class="odd"><td style="text-align: center;">M</td><td style="text-align: center;">1000</td></tr></tbody></table><p>例如， 罗马数字 <span class="math inline">\(2\)</span> 写做 <spanclass="math inline">\(II\)</span> ，即为两个并列的 <spanclass="math inline">\(1\)</span>。<spanclass="math inline">\(12\)</span> 写做 <spanclass="math inline">\(XII\)</span> ，即为 <span class="math inline">\(X+ II\)</span> 。 <span class="math inline">\(27\)</span> 写做 <spanclass="math inline">\(XXVII\)</span>, 即为 <spanclass="math inline">\(XX + V + II\)</span> 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如<span class="math inline">\(4\)</span> 不写做 <spanclass="math inline">\(IIII\)</span>，而是 <spanclass="math inline">\(IV\)</span>。数字 <spanclass="math inline">\(1\)</span> 在数字 <spanclass="math inline">\(5\)</span> 的左边，所表示的数等于大数 <spanclass="math inline">\(5\)</span> 减小数 <spanclass="math inline">\(1\)</span> 得到的数值 <spanclass="math inline">\(4\)</span> 。同样地，数字 <spanclass="math inline">\(9\)</span> 表示为 <spanclass="math inline">\(IX\)</span>。这个特殊的规则只适用于以下六种情况：</p><ul><li><p><span class="math inline">\(I\)</span> 可以放在 <spanclass="math inline">\(V\ (5)\)</span> 和 <span class="math inline">\(X\(10)\)</span> 的左边，来表示 <span class="math inline">\(4\)</span> 和<span class="math inline">\(9\)</span>。</p></li><li><p><span class="math inline">\(X\)</span> 可以放在 <spanclass="math inline">\(L\ (50)\)</span> 和 <span class="math inline">\(C\(100)\)</span> 的左边，来表示 <span class="math inline">\(40\)</span> 和<span class="math inline">\(90\)</span>。</p></li><li><p><span class="math inline">\(C\)</span> 可以放在 <spanclass="math inline">\(D\ (500)\)</span> 和 <spanclass="math inline">\(M\ (1000)\)</span> 的左边，来表示 <spanclass="math inline">\(400\)</span> 和 <spanclass="math inline">\(900\)</span>。</p></li></ul><p>给你一个整数，将其转为罗马数字。</p><h4 id="示例-1">示例 1:</h4><p><b>输入:</b> num = 3 <b>输出:</b> "III"</p><h4 id="示例-2">示例 2:</h4><p><b>输入:</b> num = 4 <b>输出:</b> "IV"</p><h4 id="示例-3">示例 3:</h4><p><b>输入:</b> num = 9 <b>输出:</b> "IX"</p><h4 id="示例-4">示例 4:</h4><p><b>输入:</b> num = 58 <b>输出:</b> "LVIII" <b>解释:</b> L = 50, V =5, III = 3.</p><h4 id="示例-5">示例 5:</h4><p><b>输入:</b> num = 1994 <b>输出:</b> "MCMXCIV" <b>解释:</b> M = 1000,CM = 900, XC = 90, IV = 4.</p><p>提示：</p><ul><li><span class="math inline">\(1 &lt;= num &lt;= 3999\)</span></li></ul><hr /><p>以下是题解：</p><h3 id="解题思路模拟">解题思路:模拟：</h3><p>按照题意，优先满足大数对应的转换可以保证答案正确，剩下的只是简单的模拟：</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">while</span>(num&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(num<span class="number">-1000</span>&gt;=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                num-=<span class="number">1000</span>;</span><br><span class="line">                ans+=<span class="string">&#x27;M&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num<span class="number">-900</span>&gt;=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                num-=<span class="number">900</span>;</span><br><span class="line">                ans+=<span class="string">&quot;CM&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num<span class="number">-500</span>&gt;=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                num-=<span class="number">500</span>;</span><br><span class="line">                ans+=<span class="string">&quot;D&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num<span class="number">-400</span>&gt;=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                num-=<span class="number">400</span>;</span><br><span class="line">                ans+=<span class="string">&quot;CD&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num<span class="number">-100</span>&gt;=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                num-=<span class="number">100</span>;</span><br><span class="line">                ans+=<span class="string">&quot;C&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num<span class="number">-90</span>&gt;=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                num-=<span class="number">90</span>;</span><br><span class="line">                ans+=<span class="string">&quot;XC&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num<span class="number">-50</span>&gt;=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                num-=<span class="number">50</span>;</span><br><span class="line">                ans+=<span class="string">&quot;L&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num<span class="number">-40</span>&gt;=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                num-=<span class="number">40</span>;</span><br><span class="line">                ans+=<span class="string">&quot;XL&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num<span class="number">-10</span>&gt;=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                num-=<span class="number">10</span>;</span><br><span class="line">                ans+=<span class="string">&quot;X&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num<span class="number">-9</span>&gt;=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                num-=<span class="number">9</span>;</span><br><span class="line">                ans+=<span class="string">&quot;IX&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num<span class="number">-5</span>&gt;=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                num-=<span class="number">5</span>;</span><br><span class="line">                ans+=<span class="string">&quot;V&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num<span class="number">-4</span>&gt;=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                num-=<span class="number">4</span>;</span><br><span class="line">                ans+=<span class="string">&quot;IV&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                num-=<span class="number">1</span>;</span><br><span class="line">                ans+=<span class="string">&quot;I&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果：</h4><p><a href="https://imgse.com/i/pPaKb6A"><imgsrc="https://s1.ax1x.com/2023/08/28/pPaKb6A.png"alt="pPaKb6A.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/28 17:13:06</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode题解——11.盛最多水的容器</title>
      <link href="/2023/08/28/LeetCode_11/"/>
      <url>/2023/08/28/LeetCode_11/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="盛最多水的容器">盛最多水的容器</h2><h3 id="题目预览">题目预览：</h3><p>给定一个长度为 <span class="math inline">\(n\)</span> 的整数数组<span class="math inline">\(height\)</span> 。有 <spanclass="math inline">\(n\)</span> 条垂线，第 <spanclass="math inline">\(i\)</span> 条线的两个端点是 <spanclass="math inline">\((i, 0)\)</span> 和 <span class="math inline">\((i,height[i])\)</span> 。</p><p>找出其中的两条线，使得它们与 <span class="math inline">\(x\)</span>轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p>说明：你不能倾斜容器。</p><h4 id="示例-1">示例 1：</h4><p><a href="https://imgse.com/i/pPaK5FO"><imgsrc="https://s1.ax1x.com/2023/08/28/pPaK5FO.jpg"alt="pPaK5FO.jpg" /></a></p><blockquote><p><b>输入：</b>[1,8,6,2,5,4,8,3,7]<br /><b>输出：</b>49<br /><b>解释：</b>图中垂直线代表输入数组[1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为49。</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>height = [1,1]<br /><b>输出：</b>1</p></blockquote><p>提示：</p><ul><li><p><span class="math inline">\(n == height.length\)</span></p></li><li><p><span class="math inline">\(2 &lt;= n &lt;= 105\)</span></p></li><li><p><span class="math inline">\(0 &lt;= height[i] &lt;=10^4\)</span></p></li></ul><hr /><p>以下是题解：</p><h3 id="解题思路双指针法">解题思路:双指针法：</h3><ol type="1"><li>定义两个分别指向容器两端的指针；<br /></li><li>依次向内收缩对应高度最短的一边；<br /></li><li>更新最大值；<br /></li><li>重复上述 <span class="math inline">\(2 , 3\)</span>步骤直到两个指针相遇。</li></ol><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>,Left=<span class="number">0</span>,Right=height.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(Left&lt;Right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> Len=Right-Left;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,<span class="built_in">min</span>(height[Left],height[Right])*Len);</span><br><span class="line">            <span class="keyword">if</span>(height[Left]&gt;height[Right])</span><br><span class="line">                Right--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                Left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPaKofe"><imgsrc="https://s1.ax1x.com/2023/08/28/pPaKofe.png"alt="pPaKofe.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/28 17:12:55</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode题解——10.正则表达式匹配</title>
      <link href="/2023/08/28/LeetCode_10/"/>
      <url>/2023/08/28/LeetCode_10/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="字符串转换整数-atoi">字符串转换整数 (atoi)</h2><h3 id="题目预览">题目预览：</h3><p>给你一个字符串 <span class="math inline">\(s\)</span> 和一个字符规律<span class="math inline">\(p\)</span>，请你来实现一个支持<code>'.'</code> 和 <code>'*'</code> 的正则表达式匹配。</p><ul><li><p><code>'.'</code> 匹配任意单个字符</p></li><li><p><code>'*'</code> 匹配零个或多个前面的那一个元素</p></li></ul><p>所谓匹配，是要涵盖 <b>整个</b> 字符串 <spanclass="math inline">\(s\)</span> 的，而不是部分字符串。</p><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>s = <code>"aa"</code>, p = <code>"a"</code><br /><b>输出：</b>false<br /><b>解释：</b><code>"a"</code> 无法匹配 <code>"aa"</code>整个字符串。</p></blockquote><h4 id="示例-2">示例 2:</h4><blockquote><p><b>输入：</b>s = <code>"aa"</code>, p = <code>"a*"</code><br /><b>输出：</b>true<br /><b>解释：</b>因为 <code>'*'</code>代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是<code>'a'</code>。因此，字符串 <code>"aa"</code> 可被视为<code>'a'</code> 重复了一次。</p></blockquote><h4 id="示例-3">示例 3：</h4><blockquote><p><b>输入：</b>s = <code>"ab"</code>, p = <code>".*"</code><br /><b>输出：</b>true<br /><b>解释：</b><code>".*"</code>表示可匹配零个或多个（<code>'*'</code>）任意字符（<code>'.'</code>）。</p></blockquote><p>提示：</p><ul><li><p><span class="math inline">\(1 &lt;= s.length &lt;=20\)</span></p></li><li><p><span class="math inline">\(1 &lt;= p.length &lt;=20\)</span></p></li><li><p><span class="math inline">\(s\)</span> 只包含从 <spanclass="math inline">\(a-z\)</span> 的小写字母。</p></li><li><p><span class="math inline">\(p\)</span> 只包含从 <spanclass="math inline">\(a-z\)</span> 的小写字母，以及字符 <code>.</code>和 <code>*</code>。 保证每次出现字符 <code>*</code>时，前面都匹配到有效的字符</p></li></ul><hr /><p>以下是题解：</p><h3 id="解题思路动态规划">解题思路:动态规划</h3><h4 id="状态转移方程如下">状态转移方程如下：</h4><p><span class="math display">\[    dp[i][j]=    \begin{cases}        dp[i−1][j−1], &amp; s[i]=p[j]\\        dp[i][j−2], &amp; p[j]=‘∗‘\ \&amp;\ s[i]=p[j−1] \\        dp[i][j−2] \ or \ dp[i−1][j], &amp; p[j]=‘∗‘\ \&amp;\s[i]=p[j−1]\\    \end{cases}\]</span></p><h4 id="初始化">初始化</h4><p>记 <span class="math inline">\(s\)</span> 的长度为 <spanclass="math inline">\(m\)</span>，<span class="math inline">\(p\)</span>的长度为 <span class="math inline">\(n\)</span>。为便于状态更新，减少对边界的判断，初始二维 <spanclass="math inline">\(dp\)</span> 数组维度为 <spanclass="math inline">\((m+1)×(n+1)\)</span>，其中第一行和第一列的状态分别表示字符串 <spanclass="math inline">\(s\)</span> 和 <spanclass="math inline">\(p\)</span> 为空时的情况。</p><p>显然，<span class="math inline">\(dp[0][0]=True\)</span> 。对于其他<span class="math inline">\(dp[0][j]\)</span> ，当 <spanclass="math inline">\(p[j]≠\)</span><code>'*'</code> 时，<spanclass="math inline">\(s[0,...,j]\)</span> 无法与空字符匹配，因此有 <spanclass="math inline">\(dp[0][j]=False\)</span> ；而当 <spanclass="math inline">\(p[j]=\)</span><code>'*'</code>时，则有 <spanclass="math inline">\(dp[0][j]\)</span>=<spanclass="math inline">\(dp[0][j-2]\)</span> 。</p><blockquote><p>⚠️ 需要特别注意的是，由于 <span class="math inline">\(dp\)</span>数组维度为 <span class="math inline">\((m+1)×(n+1)\)</span>，在具体代码实现时，<span class="math inline">\(s[i−1]\)</span> 和 <spanclass="math inline">\(p[j−1]\)</span> 才是分别表示 <spanclass="math inline">\(s\)</span> 和 <spanclass="math inline">\(p\)</span> 中的第 <spanclass="math inline">\(i\)</span> 和第 <spanclass="math inline">\(j\)</span> 个字符。</p></blockquote><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> sLen=s.<span class="built_in">length</span>(),pLen=p.<span class="built_in">length</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(sLen+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(pLen+<span class="number">1</span>,<span class="literal">false</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=pLen;j++)</span><br><span class="line">            <span class="keyword">if</span>(p[j<span class="number">-1</span>]==<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                dp[<span class="number">0</span>][j]=dp[<span class="number">0</span>][j<span class="number">-2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=sLen;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=pLen;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>]==p[j<span class="number">-1</span>]||p[j<span class="number">-1</span>]==<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(p[j<span class="number">-1</span>]==<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(s[i<span class="number">-1</span>]!=p[j<span class="number">-2</span>]&amp;&amp;p[j<span class="number">-2</span>]!=<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                        dp[i][j]=dp[i][j<span class="number">-2</span>];</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        dp[i][j]=dp[i][j<span class="number">-2</span>]|dp[i<span class="number">-1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[sLen][pLen];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPa9W6g"><imgsrc="https://s1.ax1x.com/2023/08/28/pPa9W6g.png"alt="pPa9W6g.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/28 15:19:08</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode题解——9.回文数</title>
      <link href="/2023/08/28/LeetCode_9/"/>
      <url>/2023/08/28/LeetCode_9/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="回文数">回文数</h2><h3 id="题目预览">题目预览：</h3><p>给你一个整数 <span class="math inline">\(x\)</span> ，如果 <spanclass="math inline">\(x\)</span> 是一个回文整数，返回 <spanclass="math inline">\(true\)</span> ；否则，返回 <spanclass="math inline">\(false\)</span> 。</p><p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><ul><li>例如，<span class="math inline">\(121\)</span> 是回文，而 <spanclass="math inline">\(123\)</span> 不是。</li></ul><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>x = 121<br /><b>输出：</b>true</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>x = -121<br /><b>输出：</b>false<br /><b>解释：</b>从左向右读, 为 -121 。 从右向左读, 为 121-。因此它不是一个回文数。</p></blockquote><h4 id="示例-3">示例 3：</h4><blockquote><p><b>输入：</b>x = 10<br /><b>输出：</b>false<br /><b>解释：</b>从右向左读, 为 01 。因此它不是一个回文数。</p></blockquote><p>提示：</p><ul><li><span class="math inline">\(-2^{31} &lt;= x &lt;= 2^{31} -1\)</span></li></ul><p><b>进阶：</b>你能不将整数转为字符串来解决这个问题吗？</p><hr /><p>以下是题解：</p><h3 id="解题思路">解题思路:</h3><p>通过经典对10取模法求得其对应逆序数字的值，与原值比较。</p><blockquote><p>这里使用长整型应对溢出问题</p></blockquote><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> Num=<span class="number">0</span>,tmp=x;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(tmp/<span class="number">10</span>!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Num=Num*<span class="number">10</span>+(tmp%<span class="number">10</span>);</span><br><span class="line">            tmp/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Num=Num*<span class="number">10</span>+tmp;</span><br><span class="line">        <span class="keyword">if</span>(Num==x)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPakxFs"><imgsrc="https://s1.ax1x.com/2023/08/28/pPakxFs.png"alt="pPakxFs.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/28 14:45:03</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode题解——57.插入区间</title>
      <link href="/2023/08/28/LeetCode_57/"/>
      <url>/2023/08/28/LeetCode_57/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="插入区间">插入区间</h2><h3 id="题目预览">题目预览：</h3><p>给你一个 <b>无重叠的</b> ，按照区间起始端点排序的区间列表。</p><p>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>intervals = [[1,3],[6,9]], newInterval = [2,5]<br /><b>输出：</b>[[1,5],[6,9]]</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]],newInterval = [4,8]<br /><b>输出：</b>[[1,2],[3,10],[12,16]]<br /><b>解释：</b>这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。</p></blockquote><h4 id="示例-3">示例 3：</h4><blockquote><p><b>输入：</b>intervals = [], newInterval = [5,7]<br /><b>输出：</b>[[5,7]]</p></blockquote><h4 id="示例-4">示例 4：</h4><blockquote><p><b>输入：</b>intervals = [[1,5]], newInterval = [2,3]<br /><b>输出：</b>[[1,5]]</p></blockquote><h4 id="示例-5">示例 5：</h4><blockquote><p><b>输入：</b>intervals = [[1,5]], newInterval = [2,7]<br /><b>输出：</b>[[1,7]]</p></blockquote><p>提示：</p><ul><li><p><span class="math inline">\(0 &lt;= intervals.length &lt;=10^4\)</span></p></li><li><p><span class="math inline">\(intervals[i].length ==2\)</span></p></li><li><p><span class="math inline">\(0 &lt;= intervals[i][0] &lt;=intervals[i][1] &lt;= 10^5\)</span></p></li><li><p><span class="math inline">\(intervals\)</span> 根据 <spanclass="math inline">\(intervals[i][0]\)</span> 按 <b>升序</b>排列</p></li><li><p><span class="math inline">\(newInterval.length ==2\)</span></p></li><li><p><span class="math inline">\(0 &lt;= newInterval[0] &lt;=newInterval[1] &lt;= 10^5\)</span></p></li></ul><hr /><p>以下是题解：</p><h3 id="思路">思路:</h3><p>该题与上一题(<ahref="/2023/08/27/LeetCode_56/">LeetCode_56</a>)类似，不同的是该题的intervals容器默认是有序的，而我们只需将newInterval插入对应的位置，新问题就转化成了我们已经解决的问题。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="type">int</span> Len = <span class="number">0</span>, Head = <span class="number">-1</span>, Tail = <span class="number">-1</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">insert</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals, vector&lt;<span class="type">int</span>&gt;&amp; newInterval) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123; newInterval &#125;;</span><br><span class="line">        Len = intervals.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;::iterator pos = intervals.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span> ((*pos)[<span class="number">0</span>] &lt; newInterval[<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            pos++;</span><br><span class="line">            <span class="keyword">if</span> (pos == intervals.<span class="built_in">end</span>())</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        intervals.<span class="built_in">insert</span>(pos,newInterval);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((intervals[i])[<span class="number">0</span>] &gt; Tail)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (Tail != <span class="number">-1</span>)</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(&#123; Head,Tail &#125;);</span><br><span class="line">                Head = intervals[i][<span class="number">0</span>];</span><br><span class="line">                Tail = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Tail = <span class="built_in">max</span>(Tail, intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(&#123; Head,Tail &#125;);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPU7E3q"><imgsrc="https://s1.ax1x.com/2023/08/28/pPU7E3q.png"alt="pPU7E3q.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/28 09:23:09</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode题解 </tag>
            
            <tag> LeetCode每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode题解——8.字符串转换整数 (atoi)</title>
      <link href="/2023/08/27/LeetCode_8/"/>
      <url>/2023/08/27/LeetCode_8/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="字符串转换整数-atoi">字符串转换整数 (atoi)</h2><h3 id="题目预览">题目预览：</h3><p>请你来实现一个 <span class="math inline">\(myAtoi(string s)\)</span>函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 <spanclass="math inline">\(atoi\)</span> 函数）。</p><p>函数 <span class="math inline">\(myAtoi(string s)\)</span>的算法如下：</p><ol type="1"><li><p>读入字符串并丢弃无用的 <b>前导空格</b></p></li><li><p>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。</p></li><li><p>读入下一个字符，直到到达下一个 <b>非数字字符</b> 或到达输入的<b>结尾</b> 。字符串的其余部分将被 <b>忽略</b> 。</p></li><li><p>将前面步骤读入的这些数字转换为整数（即，"123" -&gt; 123， "0032"-&gt; 32）。如果 <b>没有读入数字</b> ，则整数为 0。必要时更改符号（从步骤 2 开始）。</p></li><li><p>如果整数数超过 32 位有符号整数范围 <spanclass="math inline">\([−2^{31}, 2^{31} − 1]\)</span>，需要截断这个整数，使其保持在这个范围内。具体来说，小于 <spanclass="math inline">\(−2^{31}\)</span> 的整数应该被固定为 <spanclass="math inline">\(−2^{31}\)</span> ，大于 <spanclass="math inline">\(2^{31} − 1\)</span> 的整数应该被固定为 <spanclass="math inline">\(2^{31} − 1\)</span> 。</p></li><li><p>返回整数作为最终结果。</p></li></ol><p>注意：</p><p>本题中的空白字符只包括空格字符<code>' '</code>。除前导空格或数字后的其余字符串外，<b>请勿忽略</b>任何其他字符。</p><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>s = "42"<br /><b>输出：</b>42</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>s = " -42"<br /><b>输出：</b>-42</p></blockquote><h4 id="示例-3">示例 3：</h4><blockquote><p><b>输入：</b>s = "4193 with words"<br /><b>输出：</b>4193</p></blockquote><p>提示：</p><ul><li><span class="math inline">\(0 &lt;= s.length &lt;= 200\)</span></li><li><span class="math inline">\(s\)</span>由英文字母（大写和小写）、数字（<spanclass="math inline">\(0-9\)</span>）、' '、'+'、'-' 和 '.' 组成</li></ul><hr /><p>以下是题解：</p><h3 id="解题思路">解题思路:</h3><p>对字符串<span class="math inline">\(s\)</span>执行以下步骤：</p><ol type="1"><li><p>去除空格</p></li><li><p>判断正负</p></li><li><p>去除前导零（注意只有零的情况）</p></li><li><p>对每一位字符计算对应数字并累加求和</p></li></ol><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">myAtoi</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> Start=<span class="number">0</span>;</span><br><span class="line">        <span class="type">bool</span> isNegative=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(s[Start]==<span class="string">&#x27; &#x27;</span>)    <span class="comment">//去除空格</span></span><br><span class="line">            Start++;</span><br><span class="line">        <span class="keyword">if</span>(s[Start]==<span class="string">&#x27;-&#x27;</span>)   <span class="comment">//判断正负</span></span><br><span class="line">        &#123;</span><br><span class="line">            isNegative=<span class="literal">true</span>;</span><br><span class="line">            Start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[Start]==<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">            Start++;</span><br><span class="line">        <span class="keyword">while</span>(s[Start]==<span class="string">&#x27;0&#x27;</span>)    <span class="comment">//去除前导零</span></span><br><span class="line">            Start++;</span><br><span class="line">        <span class="keyword">if</span>(s[Start]&lt;<span class="string">&#x27;0&#x27;</span>||s[Start]&gt;<span class="string">&#x27;9&#x27;</span>)  <span class="comment">//判断只有零的情况</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> Len=<span class="number">0</span>;</span><br><span class="line">        string str=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(s[Start+Len]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;s[Start+Len]&lt;=<span class="string">&#x27;9&#x27;</span>) <span class="comment">//提取纯数字</span></span><br><span class="line">        &#123;</span><br><span class="line">            str+=s[Start+Len];</span><br><span class="line">            Len++;</span><br><span class="line">            <span class="keyword">if</span>(Len&gt;<span class="number">10</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> Num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=Len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)   <span class="comment">//求和</span></span><br><span class="line">            Num=Num*<span class="number">10</span>+(str[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(isNegative)  <span class="comment">//判断溢出</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Num&gt;<span class="number">2147483648</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-2147483648</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> -Num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Num&gt;<span class="number">2147483647</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2147483647</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> Num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPU2onA"><imgsrc="https://s1.ax1x.com/2023/08/27/pPU2onA.png"alt="pPU2onA.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/27 22:48:52</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode题解——7.整数反转</title>
      <link href="/2023/08/27/LeetCode_7/"/>
      <url>/2023/08/27/LeetCode_7/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="整数反转">整数反转</h2><h3 id="题目预览">题目预览：</h3><p>给你一个 32 位的有符号整数 <span class="math inline">\(x\)</span>，返回将 <span class="math inline">\(x\)</span>中的数字部分反转后的结果。</p><p>如果反转后整数超过 32 位的有符号整数的范围 <spanclass="math inline">\([−2^{31}, 2^{31} − 1]\)</span> ，就返回 0。</p><p>假设环境不允许存储 64 位整数（有符号或无符号）。</p><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>x = 123<br /><b>输出：</b>321</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>x = -123<br /><b>输出：</b>-321</p></blockquote><h4 id="示例-3">示例 3：</h4><blockquote><p><b>输入：</b>x = 120<br /><b>输出：</b>21</p></blockquote><h4 id="示例-4">示例 4：</h4><blockquote><p><b>输入：</b>x = 0<br /><b>输出：</b>0</p></blockquote><p>提示：</p><ul><li><span class="math inline">\({-2}^{31} &lt;= x &lt;={2}^{31}-1\)</span></li></ul><hr /><p>以下是题解：</p><h3 id="解题思路">解题思路:</h3><p>逆序可以通过对数字重复对10取余，除以10的步骤。本题难点在于不使用64位整数判断数据是否溢出。</p><p>这里直接引用LeetCode官方的解释：</p><p><a href="https://imgse.com/i/pPUwgx0"><imgsrc="https://s1.ax1x.com/2023/08/27/pPUwgx0.png"alt="pPUwgx0.png" /></a></p><p>代码如下： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rev &lt; INT_MIN / <span class="number">10</span> || rev &gt; INT_MAX / <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> digit = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            rev = rev * <span class="number">10</span> + digit;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPUwc2q"><imgsrc="https://s1.ax1x.com/2023/08/27/pPUwc2q.png"alt="pPUwc2q.png" /></a></p><h3id="这里补充一个我感觉很巧妙的一个方法">这里补充一个我感觉很“巧妙”的一个方法</h3><p>巧妙的利用了异常捕获</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        string s=<span class="built_in">to_string</span>(x);<span class="comment">//变成字符串</span></span><br><span class="line">        std::<span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());<span class="comment">//翻转字符串</span></span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ans=<span class="built_in">stoi</span>(s);<span class="comment">//变回数字</span></span><br><span class="line">            <span class="keyword">if</span> (x&lt;<span class="number">0</span>) ans=-ans;<span class="comment">//x是负数，加上负号</span></span><br><span class="line">        &#125;<span class="built_in">catch</span>(exception ex)&#123;&#125;<span class="comment">//溢出，啥也不做，返回零</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div style="text-align:right;"><p>本篇博客撰写于2023/8/27 19:31:56</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode题解——6.N字形变换</title>
      <link href="/2023/08/27/LeetCode_6/"/>
      <url>/2023/08/27/LeetCode_6/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="n字形变换">N字形变换</h2><h3 id="题目预览">题目预览：</h3><p>将一个给定字符串 <span class="math inline">\(s\)</span>根据给定的行数 <span class="math inline">\(numRows\)</span>，以从上往下、从左到右进行 <span class="math inline">\(Z\)</span>字形排列。</p><p>比如输入字符串为 "PAYPALISHIRING" 行数为 3 时，排列如下：</p><table><thead><tr class="header"><th style="text-align: center;">P</th><th style="text-align: center;"></th><th style="text-align: center;">A</th><th style="text-align: center;"></th><th style="text-align: center;">H</th><th style="text-align: center;"></th><th style="text-align: center;">N</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">A</td><td style="text-align: center;">P</td><td style="text-align: center;">L</td><td style="text-align: center;">S</td><td style="text-align: center;">I</td><td style="text-align: center;">I</td><td style="text-align: center;">G</td></tr><tr class="even"><td style="text-align: center;">Y</td><td style="text-align: center;"></td><td style="text-align: center;">I</td><td style="text-align: center;"></td><td style="text-align: center;">R</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr></tbody></table><p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如："PAHNAPLSIIGYIR"。</p><p>请你实现这个将字符串进行指定行数变换的函数：</p><p>string convert(string s, int numRows);</p><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>s = "PAYPALISHIRING", numRows = 3<br /><b>输出：</b>"PAHNAPLSIIGYIR"</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>s = "PAYPALISHIRING", numRows = 4<br /><b>输出：</b>"PINALSIGYAHRPI"<br /><b>解释：</b></p></blockquote><table><thead><tr class="header"><th style="text-align: center;">P</th><th style="text-align: center;"></th><th style="text-align: center;"></th><th style="text-align: center;">I</th><th style="text-align: center;"></th><th style="text-align: center;"></th><th style="text-align: center;">N</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">A</td><td style="text-align: center;"></td><td style="text-align: center;">L</td><td style="text-align: center;">S</td><td style="text-align: center;"></td><td style="text-align: center;">I</td><td style="text-align: center;">G</td></tr><tr class="even"><td style="text-align: center;">Y</td><td style="text-align: center;">A</td><td style="text-align: center;"></td><td style="text-align: center;">H</td><td style="text-align: center;">R</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">P</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">I</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr></tbody></table><h4 id="示例-3">示例 3：</h4><blockquote><p><b>输入：</b>s = "A", numRows = 1 <b>输出：</b>"A"</p></blockquote><p>提示：</p><ul><li><p><span class="math inline">\(1 &lt;= s.length &lt;=1000\)</span></p></li><li><p><span class="math inline">\(s\)</span>由英文字母（小写和大写）、',' 和 '.' 组成</p></li><li><p><span class="math inline">\(1 &lt;= numRows &lt;=1000\)</span></p></li></ul><hr /><p>以下是题解：</p><h3 id="解题思路">解题思路:</h3><p>字符串 <span class="math inline">\(s\)</span> 是以 <spanclass="math inline">\(N\)</span>字形为顺序存储的字符串，目标是按行打印。</p><p>设 <span class="math inline">\(numRows\)</span> 行字符串分别为 <spanclass="math inline">\(s_1 , s_2 , … , s_n\)</span>则容易发现：按顺序遍历字符串 <span class="math inline">\(s\)</span>时,每个字符 <span class="math inline">\(c\)</span> 在 <spanclass="math inline">\(N\)</span> 字形中对应的 <b>行索引</b> 先从 <spanclass="math inline">\(s_1\)</span> 增大至 <spanclass="math inline">\(s_n\)</span> ,再从 <spanclass="math inline">\(s_n\)</span> 减小至 <spanclass="math inline">\(s_1 ……\)</span> 如此反复。</p><p>因此解决方案为：模拟这个行索引的变化，在遍历 <spanclass="math inline">\(s\)</span> 中把每个字符填到正确的行 <spanclass="math inline">\(res[i]\)</span> 。</p><h3 id="算法流程">算法流程：</h3><p>按顺序遍历字符串 <span class="math inline">\(s\)</span> ：</p><ul><li><p><span class="math inline">\(res[i] += c：\)</span> 把每个字符<span class="math inline">\(c\)</span> 填入对应行 <spanclass="math inline">\(s_i\)</span> ；</p></li><li><p><span class="math inline">\(i += flag：\)</span> 更新当前字符<span class="math inline">\(c\)</span> 对应的行索引；</p></li><li><p><span class="math inline">\(flag = - flag：\)</span> 在达到 <spanclass="math inline">\(N\)</span> 字形转折点时，执行反向。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">convert</span><span class="params">(string s, <span class="type">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numRows &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">rows</span><span class="params">(numRows)</span></span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, flag = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s) &#123;</span><br><span class="line">            rows[i].<span class="built_in">push_back</span>(c);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || i == numRows <span class="number">-1</span>)</span><br><span class="line">                flag = - flag;</span><br><span class="line">            i += flag;</span><br><span class="line">        &#125;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> string &amp;row : rows)</span><br><span class="line">            res += row;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPUJtmj"><imgsrc="https://s1.ax1x.com/2023/08/27/pPUJtmj.png"alt="pPUJtmj.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/27 16:36:23</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode题解——56.合并区间</title>
      <link href="/2023/08/27/LeetCode_56/"/>
      <url>/2023/08/27/LeetCode_56/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="合并区间">合并区间</h2><h3 id="题目预览">题目预览：</h3><p>以数组 <span class="math inline">\(intervals\)</span>表示若干个区间的集合，其中单个区间为 <spanclass="math inline">\(intervals[i] = [starti, endi]\)</span>。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>intervals = [[1,3],[2,6],[8,10],[15,18]]<br /><b>输出：</b>[[1,6],[8,10],[15,18]]<br /><b>解释：</b>区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]。</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>intervals = [[1,4],[4,5]]<br /><b>输出：</b>[[1,5]]<br /><b>解释：</b>区间 [1,4] 和 [4,5] 可被视为重叠区间。</p></blockquote><p>提示：</p><ul><li><span class="math inline">\(1 &lt;= intervals.length &lt;=10^4\)</span></li><li><span class="math inline">\(intervals[i].length == 2\)</span></li><li><span class="math inline">\(0 &lt;= start_i &lt;= end_i &lt;=10^4\)</span></li></ul><hr /><p>以下是题解：</p><h3 id="思路">思路:</h3><p>先按照起点升序排列，然后比较新的起点与原有的终点之间的关系：</p><ul><li><p>若新起点包含于原有终点，则原有终点=max(原有终点，新终点)</p></li><li><p>若新起点不包含于原有终点，则将当前范围压入ans容器，并令起点更新</p></li></ul><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="type">int</span> Len = <span class="number">0</span>, Head = <span class="number">-1</span>, Tail = <span class="number">-1</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        Len = intervals.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), [&amp;](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b)-&gt;<span class="type">bool</span> &#123; <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>]; &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((intervals[i])[<span class="number">0</span>] &gt; Tail)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (Tail != <span class="number">-1</span>)</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(&#123; Head,Tail &#125;);</span><br><span class="line">                Head = (intervals[i])[<span class="number">0</span>];</span><br><span class="line">                Tail = (intervals[i])[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Tail = <span class="built_in">max</span>(Tail, (intervals[i])[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(&#123; Head,Tail &#125;);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPUEOkd"><imgsrc="https://s1.ax1x.com/2023/08/27/pPUEOkd.png"alt="pPUEOkd.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/27 10:43:10</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode题解 </tag>
            
            <tag> LeetCode每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode题解——228.汇总区间</title>
      <link href="/2023/08/26/LeetCode_228/"/>
      <url>/2023/08/26/LeetCode_228/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="汇总区间">汇总区间</h2><h3 id="题目预览">题目预览：</h3><p>给定一个 <b>无重复元素</b> 的 <b>有序</b> 整数数组 <spanclass="math inline">\(nums\)</span> 。</p><p>返回 <b>恰好覆盖数组中所有数字</b> 的 <b>最小有序</b> 区间范围列表。也就是说，<span class="math inline">\(nums\)</span>的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于<span class="math inline">\(nums\)</span> 的数字 <spanclass="math inline">\(x\)</span> 。</p><p>列表中的每个区间范围 <span class="math inline">\([a,b]\)</span>应该按如下格式输出：</p><ul><li>"a-&gt;b" ，如果 <span class="math inline">\(a != b\)</span></li><li>"a" ，如果 <span class="math inline">\(a == b\)</span></li></ul><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>nums = [0,1,2,4,5,7]<br /><b>输出：</b>["0-&gt;2","4-&gt;5","7"]<br /><b>解释：</b>区间范围是：<br />[0,2] --&gt; "0-&gt;2"<br />[4,5] --&gt; "4-&gt;5"<br />[7,7] --&gt; "7"</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>nums = [0,2,3,4,6,8,9]<br /><b>输出：</b>["0","2-&gt;4","6","8-&gt;9"]<br /><b>解释：</b>区间范围是：<br />[0,0] --&gt; "0"<br />[2,4] --&gt; "2-&gt;4"<br />[6,6] --&gt; "6"<br />[8,9] --&gt; "8-&gt;9"</p></blockquote><p>提示：</p><ul><li><span class="math inline">\(0 &lt;= nums.length &lt;=20\)</span><br /></li><li><span class="math inline">\(-2^{31} &lt;= nums[i] &lt;= 2^{31} -1\)</span><br /></li><li><span class="math inline">\(nums\)</span> 中的所有值都互不相同<br /></li><li><span class="math inline">\(nums\)</span> 按升序排列</li></ul><hr /><p>以下是题解：</p><h3 id="思路">思路:</h3><p>从头开始遍历，当遇到连续数字时使<spanclass="math inline">\(Len\)</span>增加，当遇到不同数字时根据<spanclass="math inline">\(Len\)</span>的值处理：<br />* <span class="math inline">\(Len==1：\)</span><br />不增加"-&gt;"，直接令<span class="math inline">\(Str\)</span>为该数字 *<span class="math inline">\(Len&gt;1：\)</span> 增加"-&gt;",令<spanclass="math inline">\(Str\)</span>为"X-&gt;Y"型</p><h4id="编写一个函数将整型转换成字符串">编写一个函数，将整型转换成字符串:</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">intToString</span><span class="params">(<span class="type">int</span> Num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Num == <span class="number">-2147483648</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;-2147483648&quot;</span>;</span><br><span class="line">    <span class="type">bool</span> Key = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (Num &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Num = -Num;</span><br><span class="line">        Key = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    string temp = <span class="string">&quot;&quot;</span>, ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (Key)</span><br><span class="line">        ans += <span class="string">&quot;-&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (Num / <span class="number">10</span> != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        temp += <span class="built_in">char</span>(Num % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        Num /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    temp += <span class="built_in">char</span>(Num + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="type">int</span> length = temp.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        ans += temp[length - i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完整代码">完整代码:</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt;ans;</span><br><span class="line">    <span class="function">string <span class="title">intToString</span><span class="params">(<span class="type">int</span> Num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Num == <span class="number">-2147483648</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;-2147483648&quot;</span>;</span><br><span class="line">        <span class="type">bool</span> Key = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (Num &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Num = -Num;</span><br><span class="line">            Key = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        string temp = <span class="string">&quot;&quot;</span>, ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (Key)</span><br><span class="line">            ans += <span class="string">&quot;-&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (Num / <span class="number">10</span> != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp += <span class="built_in">char</span>(Num % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            Num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp += <span class="built_in">char</span>(Num + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="type">int</span> length = temp.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">            ans += temp[length - i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">summaryRanges</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="type">int</span> Len = nums.<span class="built_in">size</span>(), Front = nums[<span class="number">0</span>], L = <span class="number">1</span>;</span><br><span class="line">        string Str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        Str += <span class="built_in">intToString</span>(Front);</span><br><span class="line">        <span class="keyword">if</span> (Len == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(Str);</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; Len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> tmp = nums[i];</span><br><span class="line">            <span class="keyword">if</span> (tmp != Front + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (L==<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                    Str += <span class="built_in">intToString</span>(Front);</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(Str);</span><br><span class="line">                    Str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                    Str += <span class="built_in">intToString</span>(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Str.<span class="built_in">append</span>(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">                    Str += <span class="built_in">intToString</span>(Front);</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(Str);</span><br><span class="line">                    Str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                    Str += <span class="built_in">intToString</span>(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">                L = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                L++;</span><br><span class="line">            &#125;</span><br><span class="line">            Front = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> temp = nums[Len - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (L != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Str.<span class="built_in">append</span>(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            Str += <span class="built_in">intToString</span>(Front);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(Str);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPNjlut"><imgsrc="https://s1.ax1x.com/2023/08/26/pPNjlut.png"alt="pPNjlut.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/26 22:13:48</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode题解 </tag>
            
            <tag> LeetCode每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode题解——5.最长回文子串</title>
      <link href="/2023/08/26/LeetCode_5/"/>
      <url>/2023/08/26/LeetCode_5/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="最长回文子串">最长回文子串</h2><h3 id="题目预览">题目预览：</h3><p>给你一个字符串 <span class="math inline">\(s\)</span>，找到 <spanclass="math inline">\(s\)</span> 中最长的回文子串。</p><p>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>s = "babad"<br /><b>输出：</b>"bab"<br /><b>解释：</b>"aba" 同样是符合题意的答案。</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>s = "cbbd"<br /><b>输出：</b>"bb"</p></blockquote><p>提示：</p><ul><li><p><span class="math inline">\(1 &lt;= s.length &lt;=1000\)</span></p></li><li><p><span class="math inline">\(s\)</span>仅由数字和英文字母组成</p></li></ul><hr /><p>以下是题解：</p><h3 id="思路中心扩散">思路:中心扩散</h3><p>本题最容易想到的一种方法应该就是 <code>中心扩散法</code>。中心扩散法怎么去找回文串？从每一个位置出发，向两边扩散即可。遇到不是回文的时候结束。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//使用双指针法</span></span><br><span class="line">    <span class="type">int</span> maxLen=<span class="number">0</span>,begin=<span class="number">0</span>;<span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">extend</span><span class="params">(string &amp;s,<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;j&lt;n&amp;&amp;s[i]==s[j])&#123;<span class="comment">//只要符合条件便继续</span></span><br><span class="line">            <span class="keyword">if</span>(j-i+<span class="number">1</span>&gt;maxLen)&#123;<span class="comment">//至少要大于当前最大的那个子串才记录</span></span><br><span class="line">                maxLen=j-i+<span class="number">1</span>;</span><br><span class="line">                begin=i;         </span><br><span class="line">            &#125;</span><br><span class="line">            --i;<span class="comment">//注意在最后指针才移动</span></span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="built_in">extend</span>(s,i,i,s.<span class="built_in">size</span>());<span class="comment">//以一个元素向两端扩散</span></span><br><span class="line">            <span class="built_in">extend</span>(s,i,i+<span class="number">1</span>,s.<span class="built_in">size</span>());<span class="comment">//以两个元素为中心向两端扩散（因为每次只会向两端扩散一层，所以要分为两种情况）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(begin,maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPN28KA"><imgsrc="https://s1.ax1x.com/2023/08/26/pPN28KA.png"alt="pPN28KA.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/26 17:31:18</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode题解——4.寻找两个正序数组的中位数</title>
      <link href="/2023/08/26/LeetCode_4/"/>
      <url>/2023/08/26/LeetCode_4/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="无重复字符的最长子串">无重复字符的最长子串</h2><h3 id="题目预览">题目预览：</h3><p>给定两个大小分别为 <span class="math inline">\(m\)</span> 和 <spanclass="math inline">\(n\)</span> 的正序（从小到大）数组 <spanclass="math inline">\(nums1\)</span> 和 <spanclass="math inline">\(nums2\)</span>。请你找出并返回这两个正序数组的中位数 。</p><p>算法的时间复杂度应该为 <span class="math inline">\(O(log(m+n))\)</span> 。</p><h4 id="示例-1">示例 1：</h4><blockquote><p><b>输入：</b>nums1 = [1,3], nums2 = [2]<br /><b>输出：</b>2.00000<br /><b>解释：</b>合并数组 = [1,2,3] ，中位数 2</p></blockquote><h4 id="示例-2">示例 2：</h4><blockquote><p><b>输入：</b>nums1 = [1,2], nums2 = [3,4]<br /><b>输出：</b>2.50000<br /><b>解释：</b>合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5</p></blockquote><p>提示：</p><ul><li><p><span class="math inline">\(nums1.length == m\)</span></p></li><li><p><span class="math inline">\(nums2.length == n\)</span></p></li><li><p><span class="math inline">\(0 &lt;= m &lt;=1000\)</span></p></li><li><p><span class="math inline">\(0 &lt;= n &lt;=1000\)</span></p></li><li><p><span class="math inline">\(1 &lt;= m + n &lt;=2000\)</span></p></li><li><p><span class="math inline">\(-10^6 &lt;= nums1[i], nums2[i] &lt;=10^6\)</span></p></li></ul><hr /><p>以下是题解：</p><h3 id="思路二分查找">思路:二分查找</h3><p>根据中位数的定义，当 <span class="math inline">\(m+n\)</span>是奇数时，中位数是两个有序数组中的第 <spanclass="math inline">\((m+n)/2\)</span> 个元素，当 <spanclass="math inline">\(m+n\)</span> 是偶数时，中位数是两个有序数组中的第<span class="math inline">\((m+n)/2\)</span> 个元素和第 <spanclass="math inline">\((m+n)/2+1\)</span>个元素的平均值。因此，这道题可以转化成寻找两个有序数组中的第 <spanclass="math inline">\(k\)</span> 小的数，其中 <spanclass="math inline">\(k\)</span> 为 <spanclass="math inline">\((m+n)/2\)</span> 或 <spanclass="math inline">\((m+n)/2+1\)</span>。</p><p>假设两个有序数组分别是 <span class="math inline">\(A\)</span> 和<span class="math inline">\(B\)</span>。要找到第 <spanclass="math inline">\(k\)</span> 个元素，我们可以比较 <spanclass="math inline">\(A[k/2−1]\)</span> 和 <spanclass="math inline">\(B[k/2−1]\)</span>，其中 / 表示整数除法。由于 <spanclass="math inline">\(A[k/2−1]\)</span> 和 <spanclass="math inline">\(B[k/2−1]\)</span> 的前面分别有 <spanclass="math inline">\(A[0 .. k/2−2]\)</span> 和 <spanclass="math inline">\(B[0 .. k/2−2]\)</span>，即 <spanclass="math inline">\(k/2−1\)</span> 个元素，对于 <spanclass="math inline">\(A[k/2−1]\)</span> 和 <spanclass="math inline">\(B[k/2−1]\)</span> 中的较小值，最多只会有 <spanclass="math inline">\((k/2−1)+(k/2−1)≤k−2\)</span>个元素比它小，那么它就不能是第 <span class="math inline">\(k\)</span>小的数了。</p><p>因此我们可以归纳出三种情况：</p><ul><li><p>如果 <spanclass="math inline">\(A[k/2−1]&lt;B[k/2−1]\)</span>，则比 <spanclass="math inline">\(A[k/2−1]\)</span> 小的数最多只有 <spanclass="math inline">\(A\)</span> 的前 <spanclass="math inline">\(k/2−1\)</span> 个数和 <spanclass="math inline">\(B\)</span> 的前 <spanclass="math inline">\(k/2−1\)</span> 个数，即比 <spanclass="math inline">\(A[k/2−1]\)</span> 小的数最多只有 <spanclass="math inline">\(k−2\)</span> 个，因此 <spanclass="math inline">\(A[k/2−1]\)</span> 不可能是第 <spanclass="math inline">\(k\)</span> 个数，<spanclass="math inline">\(A[0]\)</span> 到 <spanclass="math inline">\(A[k/2−1]\)</span> 也都不可能是第 <spanclass="math inline">\(k\)</span> 个数，可以全部排除。</p></li><li><p>如果 <spanclass="math inline">\(A[k/2−1]&gt;B[k/2−1]\)</span>，则可以排除 <spanclass="math inline">\(B[0]\)</span> 到 <spanclass="math inline">\(B[k/2−1]\)</span>。</p></li><li><p>如果 <spanclass="math inline">\(A[k/2−1]=B[k/2−1]\)</span>，则可以归入第一种情况处理。</p></li></ul><p><a href="https://imgse.com/i/pPNN4it"><imgsrc="https://s1.ax1x.com/2023/08/26/pPNN4it.png"alt="pPNN4it.png" /></a></p><p>可以看到，比较 <span class="math inline">\(A[k/2−1]\)</span> 和 <spanclass="math inline">\(B[k/2−1]\)</span> 之后，可以排除 <spanclass="math inline">\(k/2\)</span> 个不可能是第 <spanclass="math inline">\(k\)</span>小的数，查找范围缩小了一半。同时，我们将在排除后的新数组上继续进行二分查找，并且根据我们排除数的个数，减少<span class="math inline">\(k\)</span>的值，这是因为我们排除的数都不大于第 <spanclass="math inline">\(k\)</span> 小的数。</p><p>有以下三种情况需要特殊处理：</p><ul><li><p>如果 <span class="math inline">\(A[k/2−1]\)</span> 或者 <spanclass="math inline">\(B[k/2−1]\)</span>越界，那么我们可以选取对应数组中的最后一个元素。在这种情况下，我们必须根据排除数的个数减少<span class="math inline">\(k\)</span> 的值，而不能直接将 <spanclass="math inline">\(k\)</span> 减去 <spanclass="math inline">\(k/2\)</span>。</p></li><li><p>如果一个数组为空，说明该数组中的所有元素都被排除，我们可以直接返回另一个数组中第<span class="math inline">\(k\)</span> 小的元素。</p></li><li><p>如果 <spanclass="math inline">\(k=1\)</span>，我们只要返回两个数组首元素的最小值即可。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getKthElement</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> index1 = <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index1 == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums2[index2 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index2 == n) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums1[index1 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">min</span>(nums1[index1], nums2[index2]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> newIndex1 = <span class="built_in">min</span>(index1 + k / <span class="number">2</span> - <span class="number">1</span>, m - <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> newIndex2 = <span class="built_in">min</span>(index2 + k / <span class="number">2</span> - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> pivot1 = nums1[newIndex1];</span><br><span class="line">            <span class="type">int</span> pivot2 = nums2[newIndex2];</span><br><span class="line">            <span class="keyword">if</span> (pivot1 &lt;= pivot2) &#123;</span><br><span class="line">                k -= newIndex1 - index1 + <span class="number">1</span>;</span><br><span class="line">                index1 = newIndex1 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                k -= newIndex2 - index2 + <span class="number">1</span>;</span><br><span class="line">                index2 = newIndex2 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> totalLength = nums1.<span class="built_in">size</span>() + nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (totalLength % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getKthElement</span>(nums1, nums2, (totalLength + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">return</span> (<span class="built_in">getKthElement</span>(nums1, nums2, totalLength / <span class="number">2</span>) + <span class="built_in">getKthElement</span>(nums1, nums2, totalLength / <span class="number">2</span> + <span class="number">1</span>)) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPNNfII"><imgsrc="https://s1.ax1x.com/2023/08/26/pPNNfII.png"alt="pPNNfII.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/26 12:35:43</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode题解——3.无重复字符的最长子串</title>
      <link href="/2023/08/26/LeetCode_3/"/>
      <url>/2023/08/26/LeetCode_3/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="无重复字符的最长子串">无重复字符的最长子串</h2><h3 id="题目预览">题目预览：</h3><p>给定一个字符串 <span class="math inline">\(s\)</span>，请你找出其中不含有重复字符的 最长子串 的长度。</p><h4 id="示例1">示例1:</h4><blockquote><p><b>输入:</b> s = "abcabcbb"<br /><b>输出:</b> 3<br /><b>解释:</b> 因为无重复字符的最长子串是 "abc"，所以其长度为 3。</p></blockquote><h4 id="示例2">示例2</h4><blockquote><p><b>输入:</b> s = "bbbbb"<br /><b>输出:</b> 1<br /><b>解释:</b> 因为无重复字符的最长子串是 "b"，所以其长度为 1。</p></blockquote><h4 id="示例3">示例3</h4><blockquote><p><b>输入:</b> s = "pwwkew"<br /><b>输出:</b> 3<br /><b>解释:</b> 因为无重复字符的最长子串是 "wke"，所以其长度为 3。请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。</p></blockquote><p>提示：</p><ul><li><p><span class="math inline">\(0 &lt;= s.length &lt;= 5 ×10^4\)</span></p></li><li><p>s 由英文字母、数字、符号和空格组成</p></li></ul><hr /><p>以下是题解：</p><h3 id="思路">思路:</h3><p>定义两个变量<code>Start</code>=<code>End</code>=0，从头开始，定义一个哈希表储存每个字符的出现的个数，让<code>End</code>不断增加，记录字符直到出现重复字符，然后<code>Start</code>增加，同时记录排除的字符直到重新变成无重复字符的字串，然后重复<code>End</code>增加。当<code>End</code>到达字符串的尾部时停止，输出最长的无重复字串<br />代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> Start = <span class="number">0</span>, End = <span class="number">0</span>, Letter[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        Letter[s[<span class="number">0</span>]]++;</span><br><span class="line">        <span class="keyword">while</span> (End &lt; s.<span class="built_in">length</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Start == End)</span><br><span class="line">            &#123;</span><br><span class="line">                End++;</span><br><span class="line">                Letter[s[End]]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (End &lt; s.<span class="built_in">length</span>() &amp;&amp; Start &lt; End)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (Letter[s[End]] &lt;= <span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="type">int</span> tmp=End-Start+<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span>(ans &lt; tmp)</span><br><span class="line">                            ans = tmp;</span><br><span class="line">                        End++;</span><br><span class="line">                        Letter[s[End]]++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        Letter[s[Start]]--;</span><br><span class="line">                        Start++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPN1ntU"><imgsrc="https://s1.ax1x.com/2023/08/26/pPN1ntU.png"alt="pPN1ntU.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/26 10:42:24</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode题解——2.两数相加</title>
      <link href="/2023/08/25/LeetCode_2/"/>
      <url>/2023/08/25/LeetCode_2/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="两数相加">两数相加</h2><h3 id="题目预览">题目预览：</h3><p>给你两个<b>非空</b>的链表，表示两个非负的整数。它们每位数字都是按照<b>逆序</b>的方式存储的，并且每个节点只能存储<b>一位</b>数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 <span class="math inline">\(0\)</span>之外，这两个数都不会以 <span class="math inline">\(0\)</span> 开头。</p><h4 id="示例1">示例1</h4><blockquote><p><b>输入</b>：l1 = [2,4,3], l2 = [5,6,4]<br /><b>输出</b>：[7,0,8]<br /><b>解释</b>：342 + 465 = 807</p></blockquote><h4 id="示例2">示例2</h4><blockquote><p><b>输入</b>：l1 = [0], l2 = [0]<br /><b>输出</b>：[0]</p></blockquote><h4 id="示例3">示例3</h4><blockquote><p><b>输入</b>：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]<br /><b>输出</b>：[8,9,9,9,0,0,0,1]</p></blockquote><p>提示：</p><ul><li><p>每个链表中的节点数在范围<span class="math inline">\([1,100]\)</span>内</p></li><li><p><span class="math inline">\(0 &lt;= Node.val &lt;=9\)</span></p></li><li><p>题目数据保证列表表示的数字不含前导零</p></li></ul><hr /><p>以下是题解：</p><h2 id="思路">思路:</h2><p>创建一个链表<code>ans</code>储存结果，对<code>l1</code>,<code>l2</code>依次逆序相加，同时用<code>cache</code>记录进位。<br />思路比较清晰，主要难点在于如何生成链表</p><h3 id="生成一个链表">生成一个链表：</h3><hr /><h4 id="创建链表的总体思路">创建链表的总体思路：</h4><ul><li>创建一个结构体或多个结构体，结构体里面包含数据域和指针域。</li><li>创建一个表头，可以是空表头，也可以是存放数据的表头。</li><li>创建一个节点，用来后续对链表进行增删改查等操作。</li><li>将各个功能模块化，封装成一个个函数。</li></ul><hr /><h4 id="创建结构体">创建结构体</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="comment">//可替换为任意类型+data</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span>* next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结构体中的data用来存放数据，next为另一结构体的地址，用于访问其中储存的数据内容。</p><hr /><h4 id="创建表头">创建表头</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">creatList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* headNode = <span class="keyword">new</span> Node;</span><br><span class="line">    <span class="comment">//变量使用前必须被初始化</span></span><br><span class="line">    headNode-&gt;data = <span class="number">1</span>; <span class="comment">//不包含该语句即创建空表头</span></span><br><span class="line">    headNode-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回表头地址</span></span><br><span class="line">    <span class="keyword">return</span> headNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h4 id="创建节点">创建节点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">creatNode</span><span class="params">(<span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* newNode = <span class="keyword">new</span> Node;</span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h4 id="链表的增加">链表的增加</h4><p><b>头插法：</b></p><p><a href="https://imgse.com/i/pPt5D1S"><imgsrc="https://s1.ax1x.com/2023/08/25/pPt5D1S.png"alt="pPt5D1S.png" /></a></p><p>根据上图我们可以看出，通过头插的方法插入的数据是逆序的，这点需要注意。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertNodeByHead</span><span class="params">(Node *headNode, <span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* newNode = <span class="built_in">creatNode</span>(data);</span><br><span class="line">    newNode-&gt;next = headNode-&gt;next;</span><br><span class="line">    headNode-&gt;next = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数是无返回值类型的，函数有两个参数，一个是头结点的地址，一个是需要写入的数据。</p><p>函数实现过程为：</p><ol type="1"><li>创建一个新节点并对数据域赋值。</li><li>将新节点的next指向头结点的next。</li><li>将头节点的next指向新节点。</li></ol><p><b>尾插法：</b></p><p><a href="https://imgse.com/i/pPt5fhV"><imgsrc="https://s1.ax1x.com/2023/08/25/pPt5fhV.png"alt="pPt5fhV.png" /></a></p><p>根据上图我们可以看出，通过尾插的方法插入的数据是正序的，这点正好和头插法相反，在数据输出时更方便，但是其具体实现代码与头插法相比会稍微复杂一点点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertNodeByTail</span><span class="params">(Node *headNode, <span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* newNode = <span class="built_in">creatNode</span>(data);</span><br><span class="line">    Node* tailNode = headNode;</span><br><span class="line">    <span class="keyword">while</span>(tailNode-&gt;next!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tailNode = tailNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    tailNode-&gt;next = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数是无返回值类型的，函数有两个参数，一个是头结点的地址，一个是需要写入的数据。</p><p>函数实现的过程为：</p><ol type="1"><li><p>找到表尾。</p></li><li><p>写入数据。</p></li></ol><p><b>指定位置插入(在去除表头的第<code>posData</code>位前增加)</b></p><p>函数插入数据过程：</p><ol type="1"><li><p>判断链表是否为空，为空则返回链表为空。</p></li><li><p>链表不为空：</p><ul><li>寻找目标位置，如果没找到，则返回数据不存在。</li><li>找到了目标，则写入数据。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertNodeByPos</span><span class="params">(Node *headNode, <span class="type">int</span> insertData, <span class="type">int</span> posData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* newNode = <span class="built_in">creatNode</span>(insertData);</span><br><span class="line">    Node* posNode = headNode;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(posNode-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;链表为空&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(num &lt; posData - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(posNode == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;数据越界&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            posNode = posNode-&gt;next;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        newNode-&gt;next = posNode-&gt;next;</span><br><span class="line">        posNode-&gt;next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数是无返回值类型的，函数有三个参数，一个是头结点的地址，一个是写入的数据，最后一个是目标位置的数据。</p><hr /><h4 id="链表的删除">链表的删除</h4><p>链表的删除即节点的删除，由于每个节点都是通过指针来实现连接的，所以我们只需要将被删除的节点的前驱节点和后继节点的指针域指向做适当的更改即可完成删除</p><p><a href="https://imgse.com/i/pPtIhVA"><imgsrc="https://s1.ax1x.com/2023/08/25/pPtIhVA.png"alt="pPtIhVA.png" /></a></p><p><b>表头删除</b></p><p>函数实现过程：</p><ol type="1"><li><p>找到头结点。</p></li><li><p>删除头结点。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteNodeByHead</span><span class="params">(Node* headNode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* deletNode = headNode-&gt;next;</span><br><span class="line">    headNode-&gt;next = deletNode-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> deletNode;</span><br><span class="line">    deletNode = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数是无返回值类型的，函数只有一个参数，即头结点的地址。</p><p><b>注：删除的表头是带数据的头结点，而不是整个链表的那个空表头。</b></p><p><b>表尾删除</b></p><p>函数的实现过程：</p><ol type="1"><li>创建一个尾节点，该尾节点初始指向头结点（表示从表头开始寻找）。<br /></li><li>创建一个尾节点的前驱节点，初始指向NULL。<br /></li><li>寻找尾节点。<br /></li><li>删除尾节点。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteNodeByTail</span><span class="params">(Node *headNode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* tailNode = headNode;</span><br><span class="line">    Node* tailNodeFront = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(headNode-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tailNodeFront = tailNode;</span><br><span class="line">        tailNode = tailNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    tailNodeFront-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">delete</span> tailNode;</span><br><span class="line">    tailNode = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数无返回值，有一个参数，即链表的头结点。</p><p><b>指定位置删除(删除去除表头的第<code>posData</code>位数据)</b></p><p>函数实现过程：</p><ol type="1"><li>判断链表是否为空，为空则结束。</li><li>不为空，则寻找目标数据。</li><li>找到目标数据后删除该节点。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteNodeByPos</span><span class="params">(Node* headNode, <span class="type">int</span> posData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* posNode = headNode-&gt;next;</span><br><span class="line">    Node* posNodeFront = headNode;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(posNode == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;无法删除，链表为空&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(num &lt; posData - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(posNode == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;数据越界&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            posNodeFront = posNode;</span><br><span class="line">            posNode = posNode-&gt;next;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        posNodeFront-&gt;next = posNode-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> posNode;</span><br><span class="line">        posNode = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数无返回值，有两个参数，一个是链表的头结点，一个的目标位置的数据。</p><hr /><h4 id="链表的修改">链表的修改</h4><p>函数的实现过程：</p><ol type="1"><li>判断链表是否为空，为空则结束。</li><li>不为空则寻找被修改的数据在链表中的位置。</li><li>没找到对应数据，则结束。</li><li>找到了，则把数据写入进去。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">changeNode</span><span class="params">(Node *headNode, <span class="type">int</span> changeData, <span class="type">int</span> posData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* posNode = headNode-&gt;next;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(posNode == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;无法删除，链表为空&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(num &lt; posData - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(posNode-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;数据越界&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            posNode = posNode-&gt;next;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        posNode-&gt;data = changeData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数是无返回值类型的额，有三个参数，一个是链表的表头，一个是写入的数据，最后一个是被修改的数据。</p><hr /><h4 id="链表的查询">链表的查询</h4><p>链表查询的实现其实和链表的修改差不多，在代码上会比链表的修改更简单，当我们找到目标数据后，根据需求返回相应的信息即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询并返回目标数据第一次出现的位置，不存在则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FindNode</span><span class="params">(Node *headNode, <span class="type">int</span> findData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* posNode = headNode-&gt;next;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(posNode == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;链表为空&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(posNode-&gt;data != findData)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(posNode-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;未找到该数据&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            posNode = posNode-&gt;next;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数返回目标数据第一次出现的位置，有两个参数，一个是链表的表头，一个是查询的数据。</p><hr /><h4 id="链表的打印">链表的打印</h4><p>链表的打印就是通过遍历将链表的中的数据一个一个输出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(Node *headNode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *p = headNode-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;p-&gt;data;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数是无返回值类型的，仅有一个参数，即需要打印的链表的表头。</p><hr /><h2 id="真正的题解">真正的题解：</h2><blockquote><p>正所谓“工欲善其事必先利其器”，在完成了链表的创建后，我们终于可以开始正式解题了！</p></blockquote><p>首先声明出操作链表的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">creatNode</span><span class="params">(<span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode* newNode = <span class="keyword">new</span> ListNode;</span><br><span class="line">    newNode-&gt;val = data;</span><br><span class="line">    newNode-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(ListNode* headNode, <span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode* newNode = <span class="built_in">creatNode</span>(data);</span><br><span class="line">    ListNode* tailNode = headNode;</span><br><span class="line">    <span class="keyword">while</span> (tailNode-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tailNode = tailNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    tailNode-&gt;next = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迫于题目的需求，我们这里要使用非空表头，对第一组数据特殊处理：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ListNode* ans;</span><br><span class="line"><span class="type">int</span> cache = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (l1-&gt;val + l2-&gt;val &gt;= <span class="number">10</span>)</span><br><span class="line">    cache = <span class="number">1</span>;</span><br><span class="line">ans = <span class="built_in">creatNode</span>(l1-&gt;val + l2-&gt;val - cache * <span class="number">10</span>);</span><br><span class="line">l1 = l1-&gt;next;</span><br><span class="line">l2 = l2-&gt;next;</span><br></pre></td></tr></table></figure><p>剩下的数据正常处理：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 != <span class="literal">nullptr</span> &amp;&amp; l2 != <span class="literal">nullptr</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//两链表均未用尽，相加并计算进位</span></span><br><span class="line">        <span class="type">int</span> sum = l1-&gt;val + l2-&gt;val + cache;</span><br><span class="line">        sum &gt;= <span class="number">10</span> ? cache = <span class="number">1</span>, sum -= <span class="number">10</span> : cache = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">push_back</span>(ans, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (l1 == <span class="literal">nullptr</span> &amp;&amp; l2 == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//两链表都用尽，若有进位则向后再输出一位，返回ans</span></span><br><span class="line">        <span class="keyword">if</span> (cache == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">push_back</span>(ans, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (l1 == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//l1尽l2未尽，计算进位并合并l2剩余部分</span></span><br><span class="line">        <span class="keyword">while</span> (l2 != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> num = l2-&gt;val + cache;</span><br><span class="line">            num &gt;= <span class="number">10</span> ? cache = <span class="number">1</span>, num -= <span class="number">10</span> : cache = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">push_back</span>(ans, num);</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cache == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">push_back</span>(ans, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//l2尽l1未尽，计算进位并合并l1剩余部分</span></span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> num = l1-&gt;val + cache;</span><br><span class="line">            num &gt;= <span class="number">10</span> ? cache = <span class="number">1</span>, num -= <span class="number">10</span> : cache = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">push_back</span>(ans, num);</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cache == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">push_back</span>(ans, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    l1 = l1-&gt;next;</span><br><span class="line">    l2 = l2-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPNCw4K"><imgsrc="https://s1.ax1x.com/2023/08/25/pPNCw4K.png"alt="pPNCw4K.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/25 15:16:28</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode题解——1.两数之和</title>
      <link href="/2023/08/24/LeetCode_1/"/>
      <url>/2023/08/24/LeetCode_1/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="两数之和">两数之和</h2><h3 id="题目预览">题目预览：</h3><p>给定一个整数数组 <span class="math inline">\(nums\)</span>和一个整数目标值 <span class="math inline">\(target\)</span>，请你在该数组中找出和为目标值 <spanclass="math inline">\(target\)</span>的那两个整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><h4 id="示例1">示例1</h4><blockquote><p><b>输入</b>：nums = [2,7,11,15], target = 9<br /><b>输出</b>：[0,1]<br /><b>解释</b>：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</p></blockquote><h4 id="示例2">示例2</h4><blockquote><p><b>输入</b>：nums = [3,2,4], target = 6<br /><b>输出</b>：[1,2]</p></blockquote><h4 id="示例3">示例3</h4><blockquote><p><b>输入</b>：nums = [3,3], target = 6<br /><b>输出</b>：[0,1]</p></blockquote><p>提示：</p><ul><li><p><span class="math inline">\(2\)</span> &lt;= nums.length &lt;=<span class="math inline">\({10}^{4}\)</span></p></li><li><p><span class="math inline">\({-10}^{9}\)</span> &lt;= nums[i]&lt;= <span class="math inline">\({10}^{9}\)</span></p></li><li><p><span class="math inline">\({-10}^{9}\)</span> &lt;= target &lt;=<span class="math inline">\({10}^{9}\)</span></p></li><li><p>只会存在一个有效答案</p></li></ul><p><b>进阶</b>：你可以想出一个时间复杂度小于<spanclass="math inline">\(O({n}^{2})\)</span>的算法吗？</p><hr /><p>以下是题解：</p><h3 id="思路一">思路一：</h3><p>大力出奇迹——嵌套for循环</p><h4 id="优点">优点:</h4><ol type="1"><li><p>思路清晰</p></li><li><p>空间复杂度低至<span class="math inline">\(O(1)\)</span></p></li></ol><h4 id="缺点">缺点:</h4><ol type="1"><li>时间复杂度高达<span class="math inline">\(O({n}^{2})\)</span></li></ol><h4 id="思路简析">思路简析：</h4><p>两层for循环，一层控制一个数，从前往后搜，直到查找到相加为<code>target</code>的两数为止<br />代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;nums.<span class="built_in">size</span>();j++)</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]==target)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(j);</span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPtUn3T"><imgsrc="https://s1.ax1x.com/2023/08/25/pPtUn3T.png"alt="pPtUn3T.png" /></a></p><h3 id="思路一升级版">思路一(升级版)：</h3><p>快速排序+二分查找</p><h4 id="优点-1">优点:</h4><ol type="1"><li>对时间复杂度进行了优化，实现了<spanclass="math inline">\(O(nlogn)\)</span>的时间复杂度</li></ol><h4 id="缺点-1">缺点:</h4><ol type="1"><li>与原思路一相比，过程更复杂</li><li>牺牲空间换时间，需要一个结构体容器储存下标，空间复杂度为<spanclass="math inline">\(O(n)\)</span></li></ol><h3 id="历程">历程：</h3><h4 id="第一版">第一版</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="type">int</span> Len=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//快排部分</span></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>())</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//计算要查找的数</span></span><br><span class="line">            <span class="type">int</span> Num = target - nums[i];</span><br><span class="line">            <span class="comment">//二分查找</span></span><br><span class="line">            <span class="type">int</span> Low = i + <span class="number">1</span>, High = Len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (Low &lt;= High)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> Middle = (High + Low) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (nums[Middle] == Num)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(Middle);</span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (Num &lt; nums[Middle])</span><br><span class="line">                    High = Middle - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    Low = Middle + <span class="number">1</span>;</span><br><span class="line">            &#125;                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试发现致命问题——排序后数组下标发生了改变，输出的答案是排序后的下标。于是加入结构体，同时修改<code>sort</code>排序的逻辑：</p><h4 id="第二版">第二版</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">+   <span class="keyword">struct</span> <span class="title class_">Num</span> &#123;</span><br><span class="line">+       <span class="type">int</span> Value;</span><br><span class="line">+       <span class="type">int</span> id;</span><br><span class="line">+       <span class="built_in">Num</span>(<span class="type">int</span> Value,<span class="type">int</span> id): <span class="built_in">Value</span>(Value),<span class="built_in">id</span>(id) &#123;&#125;;</span><br><span class="line">+   &#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">+       vector&lt;Num&gt; temp;</span><br><span class="line">        <span class="type">int</span> Len=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Len;i++)</span><br><span class="line">            temp.<span class="built_in">push_back</span>(<span class="built_in">Num</span>(nums[i],i));</span><br><span class="line">+       <span class="built_in">sort</span>(temp.<span class="built_in">begin</span>(),temp.<span class="built_in">end</span>(),[&amp;](<span class="type">const</span> Num&amp;a,<span class="type">const</span> Num&amp;b)-&gt;<span class="type">bool</span>&#123;</span><br><span class="line">+           <span class="keyword">return</span> a.Value&lt;b.Value;</span><br><span class="line">+       &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> Num = target - temp[i].Value;</span><br><span class="line">            <span class="type">int</span> Low = i + <span class="number">1</span>, High = Len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (Low &lt;= High)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> Middle = (High + Low) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (temp[Middle].Value == Num)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(temp[i].id);</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(temp[Middle].id);</span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (Num &lt; temp[Middle].Value)</span><br><span class="line">                    High = Middle - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    Low = Middle + <span class="number">1</span>;</span><br><span class="line">            &#125;                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结果-1">结果</h4><p><a href="https://imgse.com/i/pPtUmCV"><imgsrc="https://s1.ax1x.com/2023/08/25/pPtUmCV.png"alt="pPtUmCV.png" /></a></p><div style="text-align:right;"><p>本篇博客撰写于2023/8/24 23:05:26</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Git(二)</title>
      <link href="/2023/08/21/Git-2/"/>
      <url>/2023/08/21/Git-2/</url>
      
        <content type="html"><![CDATA[<h1 id="关于git二">关于Git(二)</h1><hr /><h3 id="四版本对比">四、版本对比</h3><p>目的：对比版本之间有哪些不同</p><h4 id="准备工作">准备工作</h4><ol type="1"><li>创建一个叫做 MyProject2 的新文件夹作为本次演示的项目，初始化Git</li><li>创建一个 game.py 的文本，将下边代码拷贝进去：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">secret = random.randint(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">temp = <span class="built_in">input</span>(<span class="string">&quot;猜数字时间~：&quot;</span>)</span><br><span class="line">guess = <span class="built_in">int</span>(temp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> guess != secret:</span><br><span class="line">    temp = <span class="built_in">input</span>(<span class="string">&quot;哎呀，猜错了，请重新输入吧：&quot;</span>)</span><br><span class="line">    guess = <span class="built_in">int</span>(temp)</span><br><span class="line">    <span class="keyword">if</span> guess == secret:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;bingo！&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> guess &gt; secret:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;大了，大了~~~&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;小了，小了~~~&quot;</span>)</span><br><span class="line">            </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;游戏结束^_^&quot;</span>)</span><br></pre></td></tr></table></figure><p>再创建一个 README.md 文件，写清楚这是一个课后作业的项目：</p><blockquote><p>课后作业：文字游戏</p></blockquote><ol start="3" type="1"><li>执行 git add README.md game.py 命令将文件添加到暂存区域，接着执行git commit -m "猜数字游戏" 提交项目的第一个快照</li><li>更改代码如下：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">times = <span class="number">3</span></span><br><span class="line">secret = random.randint(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">guess = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;猜数字时间~：&quot;</span>, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (guess != secret) <span class="keyword">and</span> (times &gt; <span class="number">0</span>):</span><br><span class="line">    temp = <span class="built_in">input</span>()</span><br><span class="line">    guess = <span class="built_in">int</span>(temp)</span><br><span class="line">    times = times - <span class="number">1</span> <span class="comment"># 用户每输入一次，可用机会就-1</span></span><br><span class="line">    <span class="keyword">if</span> guess == secret:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;bingo！&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> guess &gt; secret:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;大了，大了~~~&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;小了，小了~~~&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> times &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;再试一次吧：&quot;</span>, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;机会用光咯T_T&quot;</span>)</span><br><span class="line">            </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;游戏结束^_^&quot;</span>)</span><br></pre></td></tr></table></figure><p>更改README文件</p><blockquote><p>课后作业：文字游戏_pro</p></blockquote><h4 id="比较暂存区域与工作目录">比较暂存区域与工作目录</h4><blockquote><p>直接执行<code>git diff</code>命令是比较暂存区域与工作目录的文件内容：这里可能出现一个问题，直接执行的结果出现中文乱码。在cmd界面的冒号：后面输入q退出，使用Notepad++打开README文件，点击编码→转为UTF-8编码。（旧版本中选择UTF-8（无BOM），新版中的UTF-8默认为无BOM）重新执行gitdiff发现还是不行！在查遍各网站论坛之后，终于找到了解决方法<br />执行以下四条命令：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config --global i18n.commitencoding utf-8</span><br><span class="line">git config --global i18n.logoutputencoding utf-8</span><br><span class="line"></span><br><span class="line">export LESSCHARSET=utf-8 ## linux bash配置环境变量</span><br><span class="line">set LESSCHARSET=utf-8 #windows配置环境变量</span><br></pre></td></tr></table></figure><hr /><div style="text-align:right;"><p>本篇博客撰写于2023/8/21 20:58:29</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Git(一)</title>
      <link href="/2023/08/21/Git/"/>
      <url>/2023/08/21/Git/</url>
      
        <content type="html"><![CDATA[<h1 id="关于git一">关于Git(一)</h1><h2 id="什么是git">什么是git</h2><blockquote><p>git（读音为/gɪt/）是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。也是LinusTorvalds为了帮助管理Linux内核开发而开发的一个开放源码的版本控制软件。 <ahref="https://imgse.com/i/pPGUfSg"><imgsrc="https://s1.ax1x.com/2023/08/21/pPGUfSg.png"alt="pPGUfSg.png" /></a></p></blockquote><hr /><h2 id="安装流程">安装流程</h2><blockquote><p>我怎么安装git？</p></blockquote><p>windows安装：进入<ahref="https://git-scm.com/">git官网</a>下载安装，然后使用cmd命令行或GitBash配置: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;yourname&quot;</span><br><span class="line">git config --global user.email &quot;youremail@xx.xx&quot;</span><br><span class="line">#检查信息是否写入成功</span><br><span class="line">git config --list </span><br></pre></td></tr></table></figure> *** ## 理论基础&gt;我为什么可以用git实现版本控制？</p><p>Git 记录的是什么？</p><p><a href="https://imgse.com/i/pPG8aW9"><imgsrc="https://s1.ax1x.com/2023/08/21/pPG8aW9.png"alt="pPG8aW9.png" /></a></p><p>如上，如果每个版本中有文件发生变动，Git会将整个文件复制并保存起来。这种设计看似会多消耗更多的空间，但在分支管理时却是带来了很多的益处和便利。</p><h3 id="三棵树">三棵树</h3><blockquote><p>我家门口有两棵树，一棵是枣树，另一颗也是枣树——鲁迅</p></blockquote><p>你的本地仓库有 Git 维护的三棵“树”组成，这是 Git的核心框架。这三棵树分别是： * 工作区域 * 暂存区域 * Git 仓库</p><p><a href="https://imgse.com/i/pPG80Q1"><imgsrc="https://s1.ax1x.com/2023/08/21/pPG80Q1.png"alt="pPG80Q1.png" /></a></p><ul><li><p>工作区域（WorkingDirectory）就是你平时存放项目代码的地方。</p></li><li><p>暂存区域（Stage）用于临时存放你的改动，事实上它只是一个文件，保存即将提交的文件列表信息。</p></li><li><p>Git仓库（Repository）就是安全存放数据的位置，这里边有你提交的所有版本的数据。其中，HEAD指向最新放入仓库的版本（这第三棵树，确切的说，应该是 Git 仓库中 HEAD指向的版本）。</p></li></ul><p>Git 的工作流程一般是：</p><ol type="1"><li><p>在工作目录中添加、修改文件；</p></li><li><p>将需要进行版本管理的文件放入暂存区域；</p></li><li><p>将暂存区域的文件提交到 Git 仓库。</p></li></ol><p>因此，Git 管理的文件有三种状态： * 已修改（modified） *已暂存（staged） * 已提交（committed）</p><p>依次对应上边的每一个流程。</p><hr /><h2 id="开始使用">开始使用</h2><blockquote><p>这东西怎么用啊？</p></blockquote><h3 id="一初始化git">一、初始化Git</h3><p>在自己方便的盘中新建一个文件夹，这里以MyProject为例，注意路径中不要含有中文字符。操作如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#以cmd为例，Git Bash做法相似:</span><br><span class="line">    #初始状态在C盘中，更改路径</span><br><span class="line">    C:\Users\xx&gt;F:</span><br><span class="line">    F:\&gt;</span><br><span class="line">    F:\&gt;cd MyProject</span><br><span class="line">    F:\MyProject&gt;</span><br><span class="line">    #初始化Git项目，成功后创建有一个.git隐藏文件</span><br><span class="line">    F:\MyProject&gt;git init</span><br><span class="line">    Initialized empty Git repository in F:/MyProject/.git/</span><br><span class="line">    #在文件夹MyProject中添加一个文本文件README，md格式指Markdown格式</span><br><span class="line">    #然后输入以下命令将文件加入暂存区</span><br><span class="line">    F:\MyProject&gt;git add README.md</span><br><span class="line">    #将文件提交到git仓库（-m表示添加本次提交的说明，强制要求写的）</span><br><span class="line">    F:\MyProject&gt;git commit -m &quot;add a readme file&quot;</span><br><span class="line">    [main (root-commit) 9e08cf4] add a readme file</span><br><span class="line">    1 file changed, 1 insertion(+)</span><br><span class="line">    create mode 100644 README.md</span><br><span class="line">    #恭喜你，你的仓库喜加一了</span><br></pre></td></tr></table></figure> &gt;如何将GItHub上别人的代码“据为己有”？<br />F:&gt;Clone&gt;git clone 目标</p><hr /><h3 id="二状态">二、状态</h3><p>当物品越来越多，我们怎么知道哪些文件是新添加的，哪些文件已经加入了暂存区域呢？作为世界上最伟大的版本控制系统，Git早已有了相应的解决方案。你在随时随地都可以使用<code>git status</code>查看当前状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">F:\MyProject&gt;git status</span><br><span class="line">On branch main</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p><code>On branch main</code>:我们位于一个叫做<code>main</code>的分支里，这是默认的分支<code>nothing to commit, working directory clean</code>:说明你的工作目录目前是“干净的”，没有需要提交的文件（即自上次提交后，工作目录中的内容未发生改变）。</p><p>在工作目录中添加LICENSE文件(去掉后缀，这里使用VSCode打开)：&gt;Copyright (C) &lt;year&gt; &lt;copyright holders&gt; Permission ishereby granted, free of charge, to any person obtaining a copy of thissoftware and associated documentation files (the "Software"), to deal inthe Software without restriction, including without limitation therights to use, copy, modify, merge, publish, distribute, sublicense,and/or sell copies of the Software, and to permit persons to whom theSoftware is furnished to do so, subject to the following conditions: Theabove copyright notice and this permission notice shall be included inall copies or substantial portions of the Software. THE SOFTWARE ISPROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESSFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISINGFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHERDEALINGS IN THE SOFTWARE.</p><p>输入<code>git status</code>命令，提示如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">F:\MyProject&gt;git status</span><br><span class="line">On branch main</span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">        LICENSE(红色)</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure><p><code>Untracked files</code>说明存在未跟踪的文件（即红色的那个）</p><p>所谓的“未跟踪”文件，是指那些新添加的并且未被加入到暂存区域或提交的文件。它们处于一个逍遥法外的状态，但你一旦将它们加入暂存区域或提交到Git 仓库，它们就开始受到 Git 的“跟踪”。</p><p>这里圆括号中的英文是 git给我们的建议：使用<code>git add &lt;file&gt;</code>将待提交的文件添加到暂存区域。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">F:\MyProject&gt;git add LICENSE</span><br><span class="line"></span><br><span class="line">F:\MyProject&gt;git status</span><br><span class="line">On branch main</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        new file:   LICENSE(绿色)</span><br></pre></td></tr></table></figure><p><code>use "git reset HEAD &lt;file&gt;..." to unstage</code>的意思是:</p><blockquote><p>如果你反悔了，你可以使用<code>git reset HEAD</code>恢复暂存区域</p></blockquote><p>如果后面接文件名，表示恢复该文件；如果不接文件名，则表示上一次添加的文件。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">F:\MyProject&gt;git reset HEAD</span><br><span class="line"></span><br><span class="line">F:\MyProject&gt;git status</span><br><span class="line">On branch main</span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">        LICENSE(红色)</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure></p><p>再次添加到暂存区域，然后执行<code>git commit -m "add a license file"</code>命令：</p><blockquote><p><code>-m</code>是message的缩写，即添加对应信息</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">F:\MyProject&gt;git add LICENSE</span><br><span class="line"></span><br><span class="line">F:\MyProject&gt;git status</span><br><span class="line">On branch main</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        new file:   LICENSE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">F:\MyProject&gt;git commit -m &quot;add a license file&quot;</span><br><span class="line">[main 9fdf9f4] add a license file</span><br><span class="line"> 1 file changed, 7 insertions(+)</span><br><span class="line"> create mode 100644 LICENSE</span><br><span class="line"></span><br><span class="line">F:\MyProject&gt;git status</span><br><span class="line">On branch main</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><h4 id="关于修改">关于修改</h4><p>突然发现版权那块忘了写上自己的名字了…… 打开 LICENSE文件，将<code>Copyright (C) &lt;year&gt; &lt;copyright holders&gt;</code>改为<code>Copyright (C) 2023 Lwt</code>，保存。<br />执行<code>git status</code>命令： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">F:\MyProject&gt;git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   LICENSE(红色)</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>由于你对工作目录的文件进行了修改，导致这个文件和暂存区域的对应文件不匹配了，所以Git 又给你提出两条建议：</p><ul><li>使用<code>git add</code>命令将工作目录的新版本覆盖暂存区域的旧版本，然后准备提交</li><li>使用<code>git checkout</code>命令将暂存区域的旧版本覆盖工作目录的新版本（危险操作：相当于丢弃工作目录的修改）</li></ul><p>还有一种情况我们没分析，大家先把新版本的文件覆盖掉暂存区域的旧版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">F:\MyProject&gt;git add LICENSE</span><br><span class="line"></span><br><span class="line">F:\MyProject&gt;git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        modified:   LICENSE(绿色)</span><br></pre></td></tr></table></figure><p>然后我们打开 LICENSE文件，将<code>Lwt</code>改为<code>Lwt.com</code>，保存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">F:\MyProject&gt;git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        modified:   LICENSE(绿色)</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   LICENSE(红色)</span><br></pre></td></tr></table></figure><p>这次情况是：被绿的 LICENSE说明文件存放在暂存区域（待提交），同时红色的 LICENSE说明文件还在工作目录等待添加到暂存区域。</p><p>这种情况你应该意识到这里存在两个不同版本的 LICENSE文件，这时如果你直接执行<code>commit</code>命令，那么提交的是暂存区域的版本（Lwt），如果你希望提交工作目录的新版本（Lwt.com），那么你需要先执行add 命令覆盖暂存区域，然后再提交</p><h4 id="一步到位">一步到位</h4><p>从工作目录一步添加到仓库：<code>git commit -am “说明”</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F:\MyProject&gt;git commit -am &quot;change the license file&quot;</span><br></pre></td></tr></table></figure><blockquote><p><code>-am</code>即<code>-a</code>与<code>-m</code><br /><code>git log</code>查看历史操作记录</p></blockquote><hr /><h3 id="三回到过去">三、回到过去</h3><blockquote><p>轻松的实现了时间穿越呢！</p></blockquote><p>有关回退的命令有两个：reset 和 checkout</p><p><a href="https://imgse.com/i/pPG8dzR"><imgsrc="https://s1.ax1x.com/2023/08/21/pPG8dzR.png"alt="pPG8dzR.png" /></a></p><p>先执行git log命令，将此时的Git仓库可视化</p><p><a href="https://imgse.com/i/pPG8Bsx"><imgsrc="https://s1.ax1x.com/2023/08/21/pPG8Bsx.png"alt="pPG8Bsx.png" /></a></p><p>三棵树的情况：</p><p><a href="https://imgse.com/i/pPG8seK"><imgsrc="https://s1.ax1x.com/2023/08/21/pPG8seK.png"alt="pPG8seK.png" /></a></p><h4 id="回滚快照">回滚快照</h4><blockquote><p>注：快照即提交的版本，每个版本我们称之为一个快照。</p></blockquote><p>现在我们利用 reset 命令回滚快照，并看看 Git仓库和三棵树分别发生了什么。</p><p>执行<code>git reset HEAD~</code>命令：</p><blockquote><p>注：<code>HEAD</code>表示最新提交的快照，而<code>HEAD~</code>表示<code>HEAD</code>的上一个快照，<code>HEAD~~</code>表示上上个快照，如果想表示上10个快照，则可以用<code>HEAD ~10</code></p></blockquote><p>此时我们的快照回滚到了第二棵树（暂存区域）</p><p><a href="https://imgse.com/i/pPG8ydO"><imgsrc="https://s1.ax1x.com/2023/08/21/pPG8ydO.png"alt="pPG8ydO.png" /></a></p><p><a href="https://imgse.com/i/pPG8DL6"><imgsrc="https://s1.ax1x.com/2023/08/21/pPG8DL6.png"alt="pPG8DL6.png" /></a></p><p><code>git reset HEAD~</code>命令其实是<code>git reset --mixed HEAD~</code>的缩写，<code>--mixed</code>选项是默认的。</p><blockquote><p><b>默认</b><br /><code>git reset HEAD~</code>命令其实影响了两棵树：首先是移动<code>HEAD</code>的指向，将其指向上一个快照（<code>HEAD~</code>）；然后再将该位置的快照回滚到暂存区域。<br /><b><code>--soft</code>选项</b><br /><code>git reset --soft HEAD~</code>命令就相当于只移动 HEAD的指向，但并不会将快照回滚到暂存区域。相当于撤消了上一次的提交（commit）。一不小心提交了，后悔了，那么你就执行<code>git reset --soft HEAD~</code>命令即可（此时执行<code>git log</code>命令，也不会再看到已经撤消了的那个提交）。<br /><b><code>--hard</code>选项</b><br /><code>reset</code>不仅移动<code>HEAD</code>的指向，将快照回滚动到暂存区域，它还将暂存区域的文件还原到工作目录。</p></blockquote><h4 id="回滚指定快照">回滚指定快照</h4><p><code>reset</code>不仅可以回滚指定快照，还可以回滚个别文件。</p><p>命令格式为：<code>git reset 快照 文件名/路径</code></p><p>这样，它就会将忽略移动<code>HEAD</code>的指向这一步（因为你只是回滚快照的部分内容，并不是整个快照，所以<code>HEAD</code>的指向不应该发生改变），直接将指定快照的指定文件回滚到暂存区域。</p><h4 id="不仅可以往回滚还可以往前滚">不仅可以往回滚，还可以往前滚！</h4><p>这里需要强调的是：<code>reset</code>不仅是一个“复古”的命令，它不仅可以回到过去，还可以去到“未来”。</p><p>唯一的一个前提条件是：你需要知道指定快照的 ID 号。</p><p>那如果不小心把命令窗口关了不记得ID号怎么办？<br />命令：<code>git reflog</code><br />显示Git记录的每一次操作的版本ID号</p><hr /><div style="text-align:right;"><p>本篇博客撰写于2023/8/21 10:42:20</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欢迎</title>
      <link href="/2023/08/20/Welcome/"/>
      <url>/2023/08/20/Welcome/</url>
      
        <content type="html"><![CDATA[<h1 id="欢迎访问我的博客">欢迎访问我的博客</h1><h2 id="在这里我将分享以下内容">在这里我将分享以下内容：</h2><ul><li><p>有关编程的心得</p></li><li><p>开发中遇到的问题</p></li><li><p>一些学科的知识归纳<br />......</p></li></ul><hr /><p>希望我的博客能为饱受困扰的你解决问题</p><div style="text-align:right;"><p>本篇博客撰写于2023/8/20 18:43:42</p>]]></content>
      
      
      <categories>
          
          <category> 欢迎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 欢迎 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
