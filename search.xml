<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LeetCode题解——2.两数相加</title>
      <link href="/2023/08/25/LeetCode_2/"/>
      <url>/2023/08/25/LeetCode_2/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="两数相加">两数相加</h2><h3 id="题目预览">题目预览：</h3><p>给你两个<b>非空</b>的链表，表示两个非负的整数。它们每位数字都是按照<b>逆序</b>的方式存储的，并且每个节点只能存储<b>一位</b>数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><h4 id="示例1">示例1</h4><blockquote><p><b>输入</b>：l1 = [2,4,3], l2 = [5,6,4]<br /><b>输出</b>：[7,0,8]<br /><b>解释</b>：342 + 465 = 807</p></blockquote><h4 id="示例2">示例2</h4><blockquote><p><b>输入</b>：l1 = [0], l2 = [0]<br /><b>输出</b>：[0]</p></blockquote><h4 id="示例3">示例3</h4><blockquote><p><b>输入</b>：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]<br /><b>输出</b>：[8,9,9,9,0,0,0,1]</p></blockquote><hr /><p>以下是题解：</p><h2 id="思路">思路:</h2><p>创建一个链表<code>ans</code>储存结果，对<code>l1</code>,<code>l2</code>依次逆序相加，同时用<code>cache</code>记录进位。<br />思路比较清晰，主要难点在于如何生成链表</p><h3 id="生成一个链表">生成一个链表：</h3><hr /><h4 id="创建链表的总体思路">创建链表的总体思路：</h4><ul><li>创建一个结构体或多个结构体，结构体里面包含数据域和指针域。</li><li>创建一个表头，可以是空表头，也可以是存放数据的表头。</li><li>创建一个节点，用来后续对链表进行增删改查等操作。</li><li>将各个功能模块化，封装成一个个函数。</li><li><hr /></li></ul><h4 id="创建结构体">创建结构体</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="comment">//可替换为任意类型+data</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span>* next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结构体中的data用来存放数据，next为另一结构体的地址，用于访问其中储存的数据内容。</p><hr /><h4 id="创建表头">创建表头</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">creatList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* headNode = <span class="keyword">new</span> Node;</span><br><span class="line">    <span class="comment">//变量使用前必须被初始化</span></span><br><span class="line">    headNode-&gt;data = <span class="number">1</span>; <span class="comment">//不包含该语句即创建空表头</span></span><br><span class="line">    headNode-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回表头地址</span></span><br><span class="line">    <span class="keyword">return</span> headNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h4 id="创建节点">创建节点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">creatNode</span><span class="params">(<span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* newNode = <span class="keyword">new</span> Node;</span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h4 id="链表的增加">链表的增加</h4><p><b>头插法：</b></p><p><a href="https://imgse.com/i/pPt5D1S"><imgsrc="https://s1.ax1x.com/2023/08/25/pPt5D1S.png"alt="pPt5D1S.png" /></a></p><p>根据上图我们可以看出，通过头插的方法插入的数据是逆序的，这点需要注意。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertNodeByHead</span><span class="params">(Node *headNode, <span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* newNode = <span class="built_in">creatNode</span>(data);</span><br><span class="line">    newNode-&gt;next = headNode-&gt;next;</span><br><span class="line">    headNode-&gt;next = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数是无返回值类型的，函数有两个参数，一个是头结点的地址，一个是需要写入的数据。</p><p>函数实现过程为：</p><ol type="1"><li>创建一个新节点并对数据域赋值。</li><li>将新节点的next指向头结点的next。</li><li>将头节点的next指向新节点。</li></ol><p><b>尾插法：</b></p><p><a href="https://imgse.com/i/pPt5fhV"><imgsrc="https://s1.ax1x.com/2023/08/25/pPt5fhV.png"alt="pPt5fhV.png" /></a></p><p>根据上图我们可以看出，通过尾插的方法插入的数据是正序的，这点正好和头插法相反，在数据输出时更方便，但是其具体实现代码与头插法相比会稍微复杂一点点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertNodeByTail</span><span class="params">(Node *headNode, <span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* newNode = <span class="built_in">creatNode</span>(data);</span><br><span class="line">    Node* tailNode = headNode;</span><br><span class="line">    <span class="keyword">while</span>(tailNode-&gt;next!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tailNode = tailNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    tailNode-&gt;next = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数是无返回值类型的，函数有两个参数，一个是头结点的地址，一个是需要写入的数据。</p><p>函数实现的过程为：<br />1. 找到表尾。 2. 写入数据。</p><p><b>指定位置插入(在去除表头的第<code>posData</code>位前增加)</b></p><p>函数插入数据过程： 1. 判断链表是否为空，为空则返回链表为空。 2.链表不为空：<br />* 寻找目标位置，如果没找到，则返回数据不存在。 *找到了目标，则写入数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertNodeByPos</span><span class="params">(Node *headNode, <span class="type">int</span> insertData, <span class="type">int</span> posData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* newNode = <span class="built_in">creatNode</span>(insertData);</span><br><span class="line">    Node* posNode = headNode;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(posNode-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;链表为空&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(num &lt; posData - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(posNode == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;数据越界&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            posNode = posNode-&gt;next;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        newNode-&gt;next = posNode-&gt;next;</span><br><span class="line">        posNode-&gt;next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数是无返回值类型的，函数有三个参数，一个是头结点的地址，一个是写入的数据，最后一个是目标位置的数据。</p><hr /><h4 id="链表的删除">链表的删除</h4><p>链表的删除即节点的删除，由于每个节点都是通过指针来实现连接的，所以我们只需要将被删除的节点的前驱节点和后继节点的指针域指向做适当的更改即可完成删除</p><p><a href="https://imgse.com/i/pPtIhVA"><imgsrc="https://s1.ax1x.com/2023/08/25/pPtIhVA.png"alt="pPtIhVA.png" /></a></p><p><b>表头删除</b></p><p>函数实现过程：</p><ol type="1"><li>找到头结点。</li><li>删除头结点。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteNodeByHead</span><span class="params">(Node* headNode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* deletNode = headNode-&gt;next;</span><br><span class="line">    headNode-&gt;next = deletNode-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> deletNode;</span><br><span class="line">    deletNode = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数是无返回值类型的，函数只有一个参数，即头结点的地址。</p><p><b>注：删除的表头是带数据的头结点，而不是整个链表的那个空表头。</b></p><p><b>表尾删除</b></p><p>函数的实现过程：</p><ol type="1"><li>创建一个尾节点，该尾节点初始指向头结点（表示从表头开始寻找）。<br /></li><li>创建一个尾节点的前驱节点，初始指向NULL。<br /></li><li>寻找尾节点。<br /></li><li>删除尾节点。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteNodeByTail</span><span class="params">(Node *headNode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* tailNode = headNode;</span><br><span class="line">    Node* tailNodeFront = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(headNode-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tailNodeFront = tailNode;</span><br><span class="line">        tailNode = tailNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    tailNodeFront-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">delete</span> tailNode;</span><br><span class="line">    tailNode = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数无返回值，有一个参数，即链表的头结点。</p><p><b>指定位置删除(删除去除表头的第<code>posData</code>位数据)</b></p><p>函数实现过程：</p><ol type="1"><li>判断链表是否为空，为空则结束。</li><li>不为空，则寻找目标数据。</li><li>找到目标数据后删除该节点。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteNodeByPos</span><span class="params">(Node* headNode, <span class="type">int</span> posData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* posNode = headNode-&gt;next;</span><br><span class="line">    Node* posNodeFront = headNode;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(posNode == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;无法删除，链表为空&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(num &lt; posData - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(posNode == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;数据越界&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            posNodeFront = posNode;</span><br><span class="line">            posNode = posNode-&gt;next;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        posNodeFront-&gt;next = posNode-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> posNode;</span><br><span class="line">        posNode = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数无返回值，有两个参数，一个是链表的头结点，一个的目标位置的数据。</p><hr /><h4 id="链表的修改">链表的修改</h4><p>函数的实现过程：</p><ol type="1"><li>判断链表是否为空，为空则结束。</li><li>不为空则寻找被修改的数据在链表中的位置。</li><li>没找到对应数据，则结束。</li><li>找到了，则把数据写入进去。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">changeNode</span><span class="params">(Node *headNode, <span class="type">int</span> changeData, <span class="type">int</span> posData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* posNode = headNode-&gt;next;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(posNode == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;无法删除，链表为空&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(num &lt; posData - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(posNode-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;数据越界&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            posNode = posNode-&gt;next;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        posNode-&gt;data = changeData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数是无返回值类型的额，有三个参数，一个是链表的表头，一个是写入的数据，最后一个是被修改的数据。</p><hr /><h4 id="链表的查询">链表的查询</h4><p>链表查询的实现其实和链表的修改差不多，在代码上会比链表的修改更简单，当我们找到目标数据后，根据需求返回相应的信息即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询并返回目标数据第一次出现的位置，不存在则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FindNode</span><span class="params">(Node *headNode, <span class="type">int</span> findData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* posNode = headNode-&gt;next;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(posNode == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;链表为空&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(posNode-&gt;data != findData)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(posNode-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;未找到该数据&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            posNode = posNode-&gt;next;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数返回目标数据第一次出现的位置，有两个参数，一个是链表的表头，一个是查询的数据。</p><hr /><h4 id="链表的打印">链表的打印</h4><p>链表的打印就是通过遍历将链表的中的数据一个一个输出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(Node *headNode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *p = headNode-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;p-&gt;data;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数是无返回值类型的，仅有一个参数，即需要打印的链表的表头。</p><hr /><h2 id="真正的题解">真正的题解：</h2><blockquote><p>正所谓“工欲善其事必先利其器”，在完成了链表的创建后，我们终于可以开始正式解题了！</p></blockquote><p>首先声明出操作链表的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">creatNode</span><span class="params">(<span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode* newNode = <span class="keyword">new</span> ListNode;</span><br><span class="line">    newNode-&gt;val = data;</span><br><span class="line">    newNode-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(ListNode* headNode, <span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode* newNode = <span class="built_in">creatNode</span>(data);</span><br><span class="line">    ListNode* tailNode = headNode;</span><br><span class="line">    <span class="keyword">while</span> (tailNode-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tailNode = tailNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    tailNode-&gt;next = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迫于题目的需求，我们这里要使用非空表头，对第一组数据特殊处理：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ListNode* ans;</span><br><span class="line"><span class="type">int</span> cache = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (l1-&gt;val + l2-&gt;val &gt;= <span class="number">10</span>)</span><br><span class="line">    cache = <span class="number">1</span>;</span><br><span class="line">ans = <span class="built_in">creatNode</span>(l1-&gt;val + l2-&gt;val - cache * <span class="number">10</span>);</span><br><span class="line">l1 = l1-&gt;next;</span><br><span class="line">l2 = l2-&gt;next;</span><br></pre></td></tr></table></figure><p>剩下的数据正常处理：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 != <span class="literal">nullptr</span> &amp;&amp; l2 != <span class="literal">nullptr</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//两链表均未用尽，相加并计算进位</span></span><br><span class="line">        <span class="type">int</span> sum = l1-&gt;val + l2-&gt;val + cache;</span><br><span class="line">        sum &gt;= <span class="number">10</span> ? cache = <span class="number">1</span>, sum -= <span class="number">10</span> : cache = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">push_back</span>(ans, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (l1 == <span class="literal">nullptr</span> &amp;&amp; l2 == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//两链表都用尽，若有进位则向后再输出一位，返回ans</span></span><br><span class="line">        <span class="keyword">if</span> (cache == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">push_back</span>(ans, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (l1 == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//l1尽l2未尽，计算进位并合并l2剩余部分</span></span><br><span class="line">        <span class="keyword">while</span> (l2 != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> num = l2-&gt;val + cache;</span><br><span class="line">            num &gt;= <span class="number">10</span> ? cache = <span class="number">1</span>, num -= <span class="number">10</span> : cache = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">push_back</span>(ans, num);</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cache == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">push_back</span>(ans, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//l2尽l1未尽，计算进位并合并l1剩余部分</span></span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> num = l1-&gt;val + cache;</span><br><span class="line">            num &gt;= <span class="number">10</span> ? cache = <span class="number">1</span>, num -= <span class="number">10</span> : cache = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">push_back</span>(ans, num);</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cache == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">push_back</span>(ans, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    l1 = l1-&gt;next;</span><br><span class="line">    l2 = l2-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPNCw4K"><imgsrc="https://s1.ax1x.com/2023/08/25/pPNCw4K.png"alt="pPNCw4K.png" /></a></p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode题解——1.两数之和</title>
      <link href="/2023/08/24/LeetCode_1/"/>
      <url>/2023/08/24/LeetCode_1/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode题解">LeetCode题解</h1><h2 id="两数之和">两数之和</h2><h3 id="题目预览">题目预览：</h3><p>给定一个整数数组<code>nums</code>和一个整数目标值<code>target</code>，请你在该数组中找出和为目标值<code>target</code>的那两个整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><h4 id="示例1">示例1</h4><blockquote><p><b>输入</b>：nums = [2,7,11,15], target = 9<br /><b>输出</b>：[0,1]<br /><b>解释</b>：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</p></blockquote><h4 id="示例2">示例2</h4><blockquote><p><b>输入</b>：nums = [3,2,4], target = 6<br /><b>输出</b>：[1,2]</p></blockquote><h4 id="示例3">示例3</h4><blockquote><p><b>输入</b>：nums = [3,3], target = 6<br /><b>输出</b>：[0,1]</p></blockquote><p><b>提示</b>： * <span class="math inline">\(2\)</span> &lt;=nums.length &lt;= <span class="math inline">\({10}^{4}\)</span> * <spanclass="math inline">\({-10}^{9}\)</span> &lt;= nums[i] &lt;= <spanclass="math inline">\({10}^{9}\)</span> * <spanclass="math inline">\({-10}^{9}\)</span> &lt;= target &lt;= <spanclass="math inline">\({10}^{9}\)</span> * 只会存在一个有效答案</p><p><b>进阶</b>：你可以想出一个时间复杂度小于<spanclass="math inline">\(O({n}^{2})\)</span>的算法吗？</p><hr /><p>以下是题解：</p><h3 id="思路一">思路一：</h3><p>大力出奇迹——嵌套for循环<br />#### 优点: 1. 思路清晰 2. 空间复杂度低至<spanclass="math inline">\(O(1)\)</span></p><h4 id="缺点">缺点:</h4><ol type="1"><li>时间复杂度高达<span class="math inline">\(O({n}^{2})\)</span></li></ol><h4 id="思路简析">思路简析：</h4><p>两层for循环，一层控制一个数，从前往后搜，直到查找到相加为<code>target</code>的两数为止<br />代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;nums.<span class="built_in">size</span>();j++)</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]==target)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(j);</span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">结果</h4><p><a href="https://imgse.com/i/pPtUn3T"><imgsrc="https://s1.ax1x.com/2023/08/25/pPtUn3T.png"alt="pPtUn3T.png" /></a></p><h3 id="思路一升级版">思路一(升级版)：</h3><p>快速排序+二分查找 #### 优点: 1. 对时间复杂度进行了优化，实现了<spanclass="math inline">\(O(nlogn)\)</span>的时间复杂度</p><h4 id="缺点-1">缺点:</h4><ol type="1"><li>与原思路一相比，过程更复杂</li><li>牺牲空间换时间，需要一个结构体容器储存下标，空间复杂度为<spanclass="math inline">\(O(n)\)</span></li></ol><h3 id="历程">历程：</h3><h4 id="第一版">第一版</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="type">int</span> Len=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//快排部分</span></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>())</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//计算要查找的数</span></span><br><span class="line">            <span class="type">int</span> Num = target - nums[i];</span><br><span class="line">            <span class="comment">//二分查找</span></span><br><span class="line">            <span class="type">int</span> Low = i + <span class="number">1</span>, High = Len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (Low &lt;= High)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> Middle = (High + Low) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (nums[Middle] == Num)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(Middle);</span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (Num &lt; nums[Middle])</span><br><span class="line">                    High = Middle - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    Low = Middle + <span class="number">1</span>;</span><br><span class="line">            &#125;                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试发现致命问题——排序后数组下标发生了改变，输出的答案是排序后的下标。于是加入结构体，同时修改<code>sort</code>排序的逻辑：</p><h4 id="第二版">第二版</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">+   <span class="keyword">struct</span> <span class="title class_">Num</span> &#123;</span><br><span class="line">+       <span class="type">int</span> Value;</span><br><span class="line">+       <span class="type">int</span> id;</span><br><span class="line">+       <span class="built_in">Num</span>(<span class="type">int</span> Value,<span class="type">int</span> id): <span class="built_in">Value</span>(Value),<span class="built_in">id</span>(id) &#123;&#125;;</span><br><span class="line">+   &#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">+       vector&lt;Num&gt; temp;</span><br><span class="line">        <span class="type">int</span> Len=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Len;i++)</span><br><span class="line">            temp.<span class="built_in">push_back</span>(<span class="built_in">Num</span>(nums[i],i));</span><br><span class="line">+       <span class="built_in">sort</span>(temp.<span class="built_in">begin</span>(),temp.<span class="built_in">end</span>(),[&amp;](<span class="type">const</span> Num&amp;a,<span class="type">const</span> Num&amp;b)-&gt;<span class="type">bool</span>&#123;</span><br><span class="line">+           <span class="keyword">return</span> a.Value&lt;b.Value;</span><br><span class="line">+       &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> Num = target - temp[i].Value;</span><br><span class="line">            <span class="type">int</span> Low = i + <span class="number">1</span>, High = Len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (Low &lt;= High)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> Middle = (High + Low) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (temp[Middle].Value == Num)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(temp[i].id);</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(temp[Middle].id);</span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (Num &lt; temp[Middle].Value)</span><br><span class="line">                    High = Middle - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    Low = Middle + <span class="number">1</span>;</span><br><span class="line">            &#125;                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结果-1">结果</h4><p><a href="https://imgse.com/i/pPtUmCV"><imgsrc="https://s1.ax1x.com/2023/08/25/pPtUmCV.png"alt="pPtUmCV.png" /></a></p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Git(二)</title>
      <link href="/2023/08/21/Git-2/"/>
      <url>/2023/08/21/Git-2/</url>
      
        <content type="html"><![CDATA[<h1 id="关于git二">关于Git(二)</h1><hr /><h3 id="四版本对比">四、版本对比</h3><p>目的：对比版本之间有哪些不同</p><h4 id="准备工作">准备工作</h4><ol type="1"><li>创建一个叫做 MyProject2 的新文件夹作为本次演示的项目，初始化Git</li><li>创建一个 game.py 的文本，将下边代码拷贝进去：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">secret = random.randint(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">temp = <span class="built_in">input</span>(<span class="string">&quot;猜数字时间~：&quot;</span>)</span><br><span class="line">guess = <span class="built_in">int</span>(temp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> guess != secret:</span><br><span class="line">    temp = <span class="built_in">input</span>(<span class="string">&quot;哎呀，猜错了，请重新输入吧：&quot;</span>)</span><br><span class="line">    guess = <span class="built_in">int</span>(temp)</span><br><span class="line">    <span class="keyword">if</span> guess == secret:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;bingo！&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> guess &gt; secret:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;大了，大了~~~&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;小了，小了~~~&quot;</span>)</span><br><span class="line">            </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;游戏结束^_^&quot;</span>)</span><br></pre></td></tr></table></figure><p>再创建一个 README.md 文件，写清楚这是一个课后作业的项目：</p><blockquote><p>课后作业：文字游戏</p></blockquote><ol start="3" type="1"><li>执行 git add README.md game.py 命令将文件添加到暂存区域，接着执行git commit -m "猜数字游戏" 提交项目的第一个快照</li><li>更改代码如下：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">times = <span class="number">3</span></span><br><span class="line">secret = random.randint(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">guess = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;猜数字时间~：&quot;</span>, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (guess != secret) <span class="keyword">and</span> (times &gt; <span class="number">0</span>):</span><br><span class="line">    temp = <span class="built_in">input</span>()</span><br><span class="line">    guess = <span class="built_in">int</span>(temp)</span><br><span class="line">    times = times - <span class="number">1</span> <span class="comment"># 用户每输入一次，可用机会就-1</span></span><br><span class="line">    <span class="keyword">if</span> guess == secret:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;bingo！&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> guess &gt; secret:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;大了，大了~~~&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;小了，小了~~~&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> times &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;再试一次吧：&quot;</span>, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;机会用光咯T_T&quot;</span>)</span><br><span class="line">            </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;游戏结束^_^&quot;</span>)</span><br></pre></td></tr></table></figure><p>更改README文件</p><blockquote><p>课后作业：文字游戏_pro</p></blockquote><h4 id="比较暂存区域与工作目录">比较暂存区域与工作目录</h4><blockquote><p>直接执行<code>git diff</code>命令是比较暂存区域与工作目录的文件内容：这里可能出现一个问题，直接执行的结果出现中文乱码。在cmd界面的冒号：后面输入q退出，使用Notepad++打开README文件，点击编码→转为UTF-8编码。（旧版本中选择UTF-8（无BOM），新版中的UTF-8默认为无BOM）重新执行gitdiff发现还是不行！在查遍各网站论坛之后，终于找到了解决方法<br />执行以下四条命令：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config --global i18n.commitencoding utf-8</span><br><span class="line">git config --global i18n.logoutputencoding utf-8</span><br><span class="line"></span><br><span class="line">export LESSCHARSET=utf-8 ## linux bash配置环境变量</span><br><span class="line">set LESSCHARSET=utf-8 #windows配置环境变量</span><br></pre></td></tr></table></figure><hr /><div style="text-align:right;"><p>本篇博客撰写于2023/8/21 20:58:29</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Git(一)</title>
      <link href="/2023/08/21/Git/"/>
      <url>/2023/08/21/Git/</url>
      
        <content type="html"><![CDATA[<h1 id="关于git一">关于Git(一)</h1><h2 id="什么是git">什么是git</h2><blockquote><p>git（读音为/gɪt/）是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。也是LinusTorvalds为了帮助管理Linux内核开发而开发的一个开放源码的版本控制软件。 <ahref="https://imgse.com/i/pPGUfSg"><imgsrc="https://s1.ax1x.com/2023/08/21/pPGUfSg.png"alt="pPGUfSg.png" /></a></p></blockquote><hr /><h2 id="安装流程">安装流程</h2><blockquote><p>我怎么安装git？</p></blockquote><p>windows安装：进入<ahref="https://git-scm.com/">git官网</a>下载安装，然后使用cmd命令行或GitBash配置: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;yourname&quot;</span><br><span class="line">git config --global user.email &quot;youremail@xx.xx&quot;</span><br><span class="line">#检查信息是否写入成功</span><br><span class="line">git config --list </span><br></pre></td></tr></table></figure> *** ## 理论基础&gt;我为什么可以用git实现版本控制？</p><p>Git 记录的是什么？</p><p><a href="https://imgse.com/i/pPG8aW9"><imgsrc="https://s1.ax1x.com/2023/08/21/pPG8aW9.png"alt="pPG8aW9.png" /></a></p><p>如上，如果每个版本中有文件发生变动，Git会将整个文件复制并保存起来。这种设计看似会多消耗更多的空间，但在分支管理时却是带来了很多的益处和便利。</p><h3 id="三棵树">三棵树</h3><blockquote><p>我家门口有两棵树，一棵是枣树，另一颗也是枣树——鲁迅</p></blockquote><p>你的本地仓库有 Git 维护的三棵“树”组成，这是 Git的核心框架。这三棵树分别是： * 工作区域 * 暂存区域 * Git 仓库</p><p><a href="https://imgse.com/i/pPG80Q1"><imgsrc="https://s1.ax1x.com/2023/08/21/pPG80Q1.png"alt="pPG80Q1.png" /></a></p><ul><li><p>工作区域（WorkingDirectory）就是你平时存放项目代码的地方。</p></li><li><p>暂存区域（Stage）用于临时存放你的改动，事实上它只是一个文件，保存即将提交的文件列表信息。</p></li><li><p>Git仓库（Repository）就是安全存放数据的位置，这里边有你提交的所有版本的数据。其中，HEAD指向最新放入仓库的版本（这第三棵树，确切的说，应该是 Git 仓库中 HEAD指向的版本）。</p></li></ul><p>Git 的工作流程一般是：</p><ol type="1"><li><p>在工作目录中添加、修改文件；</p></li><li><p>将需要进行版本管理的文件放入暂存区域；</p></li><li><p>将暂存区域的文件提交到 Git 仓库。</p></li></ol><p>因此，Git 管理的文件有三种状态： * 已修改（modified） *已暂存（staged） * 已提交（committed）</p><p>依次对应上边的每一个流程。</p><hr /><h2 id="开始使用">开始使用</h2><blockquote><p>这东西怎么用啊？</p></blockquote><h3 id="一初始化git">一、初始化Git</h3><p>在自己方便的盘中新建一个文件夹，这里以MyProject为例，注意路径中不要含有中文字符。操作如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#以cmd为例，Git Bash做法相似:</span><br><span class="line">    #初始状态在C盘中，更改路径</span><br><span class="line">    C:\Users\xx&gt;F:</span><br><span class="line">    F:\&gt;</span><br><span class="line">    F:\&gt;cd MyProject</span><br><span class="line">    F:\MyProject&gt;</span><br><span class="line">    #初始化Git项目，成功后创建有一个.git隐藏文件</span><br><span class="line">    F:\MyProject&gt;git init</span><br><span class="line">    Initialized empty Git repository in F:/MyProject/.git/</span><br><span class="line">    #在文件夹MyProject中添加一个文本文件README，md格式指Markdown格式</span><br><span class="line">    #然后输入以下命令将文件加入暂存区</span><br><span class="line">    F:\MyProject&gt;git add README.md</span><br><span class="line">    #将文件提交到git仓库（-m表示添加本次提交的说明，强制要求写的）</span><br><span class="line">    F:\MyProject&gt;git commit -m &quot;add a readme file&quot;</span><br><span class="line">    [main (root-commit) 9e08cf4] add a readme file</span><br><span class="line">    1 file changed, 1 insertion(+)</span><br><span class="line">    create mode 100644 README.md</span><br><span class="line">    #恭喜你，你的仓库喜加一了</span><br></pre></td></tr></table></figure> &gt;如何将GItHub上别人的代码“据为己有”？<br />F:&gt;Clone&gt;git clone 目标</p><hr /><h3 id="二状态">二、状态</h3><p>当物品越来越多，我们怎么知道哪些文件是新添加的，哪些文件已经加入了暂存区域呢？作为世界上最伟大的版本控制系统，Git早已有了相应的解决方案。你在随时随地都可以使用<code>git status</code>查看当前状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">F:\MyProject&gt;git status</span><br><span class="line">On branch main</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p><code>On branch main</code>:我们位于一个叫做<code>main</code>的分支里，这是默认的分支<code>nothing to commit, working directory clean</code>:说明你的工作目录目前是“干净的”，没有需要提交的文件（即自上次提交后，工作目录中的内容未发生改变）。</p><p>在工作目录中添加LICENSE文件(去掉后缀，这里使用VSCode打开)：&gt;Copyright (C) &lt;year&gt; &lt;copyright holders&gt; Permission ishereby granted, free of charge, to any person obtaining a copy of thissoftware and associated documentation files (the "Software"), to deal inthe Software without restriction, including without limitation therights to use, copy, modify, merge, publish, distribute, sublicense,and/or sell copies of the Software, and to permit persons to whom theSoftware is furnished to do so, subject to the following conditions: Theabove copyright notice and this permission notice shall be included inall copies or substantial portions of the Software. THE SOFTWARE ISPROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESSFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISINGFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHERDEALINGS IN THE SOFTWARE.</p><p>输入<code>git status</code>命令，提示如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">F:\MyProject&gt;git status</span><br><span class="line">On branch main</span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">        LICENSE(红色)</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure><p><code>Untracked files</code>说明存在未跟踪的文件（即红色的那个）</p><p>所谓的“未跟踪”文件，是指那些新添加的并且未被加入到暂存区域或提交的文件。它们处于一个逍遥法外的状态，但你一旦将它们加入暂存区域或提交到Git 仓库，它们就开始受到 Git 的“跟踪”。</p><p>这里圆括号中的英文是 git给我们的建议：使用<code>git add &lt;file&gt;</code>将待提交的文件添加到暂存区域。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">F:\MyProject&gt;git add LICENSE</span><br><span class="line"></span><br><span class="line">F:\MyProject&gt;git status</span><br><span class="line">On branch main</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        new file:   LICENSE(绿色)</span><br></pre></td></tr></table></figure><p><code>use "git reset HEAD &lt;file&gt;..." to unstage</code>的意思是:</p><blockquote><p>如果你反悔了，你可以使用<code>git reset HEAD</code>恢复暂存区域</p></blockquote><p>如果后面接文件名，表示恢复该文件；如果不接文件名，则表示上一次添加的文件。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">F:\MyProject&gt;git reset HEAD</span><br><span class="line"></span><br><span class="line">F:\MyProject&gt;git status</span><br><span class="line">On branch main</span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">        LICENSE(红色)</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure></p><p>再次添加到暂存区域，然后执行<code>git commit -m "add a license file"</code>命令：</p><blockquote><p><code>-m</code>是message的缩写，即添加对应信息</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">F:\MyProject&gt;git add LICENSE</span><br><span class="line"></span><br><span class="line">F:\MyProject&gt;git status</span><br><span class="line">On branch main</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        new file:   LICENSE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">F:\MyProject&gt;git commit -m &quot;add a license file&quot;</span><br><span class="line">[main 9fdf9f4] add a license file</span><br><span class="line"> 1 file changed, 7 insertions(+)</span><br><span class="line"> create mode 100644 LICENSE</span><br><span class="line"></span><br><span class="line">F:\MyProject&gt;git status</span><br><span class="line">On branch main</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><h4 id="关于修改">关于修改</h4><p>突然发现版权那块忘了写上自己的名字了…… 打开 LICENSE文件，将<code>Copyright (C) &lt;year&gt; &lt;copyright holders&gt;</code>改为<code>Copyright (C) 2023 Lwt</code>，保存。<br />执行<code>git status</code>命令： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">F:\MyProject&gt;git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   LICENSE(红色)</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>由于你对工作目录的文件进行了修改，导致这个文件和暂存区域的对应文件不匹配了，所以Git 又给你提出两条建议：</p><ul><li>使用<code>git add</code>命令将工作目录的新版本覆盖暂存区域的旧版本，然后准备提交</li><li>使用<code>git checkout</code>命令将暂存区域的旧版本覆盖工作目录的新版本（危险操作：相当于丢弃工作目录的修改）</li></ul><p>还有一种情况我们没分析，大家先把新版本的文件覆盖掉暂存区域的旧版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">F:\MyProject&gt;git add LICENSE</span><br><span class="line"></span><br><span class="line">F:\MyProject&gt;git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        modified:   LICENSE(绿色)</span><br></pre></td></tr></table></figure><p>然后我们打开 LICENSE文件，将<code>Lwt</code>改为<code>Lwt.com</code>，保存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">F:\MyProject&gt;git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        modified:   LICENSE(绿色)</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   LICENSE(红色)</span><br></pre></td></tr></table></figure><p>这次情况是：被绿的 LICENSE说明文件存放在暂存区域（待提交），同时红色的 LICENSE说明文件还在工作目录等待添加到暂存区域。</p><p>这种情况你应该意识到这里存在两个不同版本的 LICENSE文件，这时如果你直接执行<code>commit</code>命令，那么提交的是暂存区域的版本（Lwt），如果你希望提交工作目录的新版本（Lwt.com），那么你需要先执行add 命令覆盖暂存区域，然后再提交</p><h4 id="一步到位">一步到位</h4><p>从工作目录一步添加到仓库：<code>git commit -am “说明”</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F:\MyProject&gt;git commit -am &quot;change the license file&quot;</span><br></pre></td></tr></table></figure><blockquote><p><code>-am</code>即<code>-a</code>与<code>-m</code><br /><code>git log</code>查看历史操作记录</p></blockquote><hr /><h3 id="三回到过去">三、回到过去</h3><blockquote><p>轻松的实现了时间穿越呢！</p></blockquote><p>有关回退的命令有两个：reset 和 checkout</p><p><a href="https://imgse.com/i/pPG8dzR"><imgsrc="https://s1.ax1x.com/2023/08/21/pPG8dzR.png"alt="pPG8dzR.png" /></a></p><p>先执行git log命令，将此时的Git仓库可视化</p><p><a href="https://imgse.com/i/pPG8Bsx"><imgsrc="https://s1.ax1x.com/2023/08/21/pPG8Bsx.png"alt="pPG8Bsx.png" /></a></p><p>三棵树的情况：</p><p><a href="https://imgse.com/i/pPG8seK"><imgsrc="https://s1.ax1x.com/2023/08/21/pPG8seK.png"alt="pPG8seK.png" /></a></p><h4 id="回滚快照">回滚快照</h4><blockquote><p>注：快照即提交的版本，每个版本我们称之为一个快照。</p></blockquote><p>现在我们利用 reset 命令回滚快照，并看看 Git仓库和三棵树分别发生了什么。</p><p>执行<code>git reset HEAD~</code>命令：</p><blockquote><p>注：<code>HEAD</code>表示最新提交的快照，而<code>HEAD~</code>表示<code>HEAD</code>的上一个快照，<code>HEAD~~</code>表示上上个快照，如果想表示上10个快照，则可以用<code>HEAD ~10</code></p></blockquote><p>此时我们的快照回滚到了第二棵树（暂存区域）</p><p><a href="https://imgse.com/i/pPG8ydO"><imgsrc="https://s1.ax1x.com/2023/08/21/pPG8ydO.png"alt="pPG8ydO.png" /></a></p><p><a href="https://imgse.com/i/pPG8DL6"><imgsrc="https://s1.ax1x.com/2023/08/21/pPG8DL6.png"alt="pPG8DL6.png" /></a></p><p><code>git reset HEAD~</code>命令其实是<code>git reset --mixed HEAD~</code>的缩写，<code>--mixed</code>选项是默认的。</p><blockquote><p><b>默认</b><br /><code>git reset HEAD~</code>命令其实影响了两棵树：首先是移动<code>HEAD</code>的指向，将其指向上一个快照（<code>HEAD~</code>）；然后再将该位置的快照回滚到暂存区域。<br /><b><code>--soft</code>选项</b><br /><code>git reset --soft HEAD~</code>命令就相当于只移动 HEAD的指向，但并不会将快照回滚到暂存区域。相当于撤消了上一次的提交（commit）。一不小心提交了，后悔了，那么你就执行<code>git reset --soft HEAD~</code>命令即可（此时执行<code>git log</code>命令，也不会再看到已经撤消了的那个提交）。<br /><b><code>--hard</code>选项</b><br /><code>reset</code>不仅移动<code>HEAD</code>的指向，将快照回滚动到暂存区域，它还将暂存区域的文件还原到工作目录。</p></blockquote><h4 id="回滚指定快照">回滚指定快照</h4><p><code>reset</code>不仅可以回滚指定快照，还可以回滚个别文件。</p><p>命令格式为：<code>git reset 快照 文件名/路径</code></p><p>这样，它就会将忽略移动<code>HEAD</code>的指向这一步（因为你只是回滚快照的部分内容，并不是整个快照，所以<code>HEAD</code>的指向不应该发生改变），直接将指定快照的指定文件回滚到暂存区域。</p><h4 id="不仅可以往回滚还可以往前滚">不仅可以往回滚，还可以往前滚！</h4><p>这里需要强调的是：<code>reset</code>不仅是一个“复古”的命令，它不仅可以回到过去，还可以去到“未来”。</p><p>唯一的一个前提条件是：你需要知道指定快照的 ID 号。</p><p>那如果不小心把命令窗口关了不记得ID号怎么办？<br />命令：<code>git reflog</code><br />显示Git记录的每一次操作的版本ID号</p><hr /><div style="text-align:right;"><p>本篇博客撰写于2023/8/21 10:42:20</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欢迎</title>
      <link href="/2023/08/20/Welcome/"/>
      <url>/2023/08/20/Welcome/</url>
      
        <content type="html"><![CDATA[<h1 id="欢迎访问我的博客">欢迎访问我的博客</h1><h2 id="在这里我将分享以下内容">在这里我将分享以下内容：</h2><ul><li>有关编程的心得</li><li>开发中遇到的问题</li><li>一些学科的知识归纳<br />......<br />*** 希望我的博客能为饱受困扰的你解决问题<br /><div style="text-align:right;">本篇博客撰写于2023/8/20 18:43:42</li></ul>]]></content>
      
      
      <categories>
          
          <category> 欢迎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 欢迎 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
